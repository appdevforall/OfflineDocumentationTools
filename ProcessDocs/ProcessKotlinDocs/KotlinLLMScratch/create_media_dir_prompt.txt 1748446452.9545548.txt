Modify the script at the bottom of this prompt so that it makes use of the existing functions to convert all PNGs in a given directory to WEBP and creates a new directory that contains the new WEBP files and copies of the original non-PNG files. The script will make use of the given helper functions where necessary. The script will perform lossy PNG-to-WEBP conversion with cwebp and the quality level will be specified by the user.

In the output directory, retain the full name of each PNG file but change the extension to ".webp" to reflect its conversion to WEBP format.

The input directory will be passed to the script as a command line argument. It will be specified after the "--input-dir" flag.

The output directory will be passed to the script as a command line argument. It will be specified after the "--input-dir" flag.

The quality level will be passed to the script as a command line argument. It will be specified after the "--quality" flag.

The script to modify is given below after a "~~~" separator string.

~~~

import numpy as np
import os
import subprocess
import sys
import time

def process_image(in_image, image_quality, out_dir):
    # Input file size
    orig_size = os.path.getsize(in_image)

    # Input file basename
    basename = os.path.basename(in_image)

    # Assuming no dots in file name beyond file extension
    no_ext = basename.split(".")[0]

    # Output filename, replace png with webp
    out_image = os.path.join(out_dir, no_ext + ".webp")

    # Collect runtime info
    t_0 = time.perf_counter()

    # cwebp -near_lossless <quality> <input file> -o <output file>
    command = "cwebp -near_lossless " + str(image_quality) + " " + in_image + " -o " + out_image
    process = subprocess.run(command, shell=True, capture_output=True, text=True)

    t_1 = time.perf_counter()

    runtime = t_1 - t_0

    compressed_size = os.path.getsize(out_image)

    return orig_size, compressed_size, runtime


def process_image_batch(images, image_quality, out_dir):
    image_stats = {}

    for image in images:
        image_stats[image] = {}
        orig_size, compressed_size, runtime = process_image(image, image_quality, out_dir)

        image_stats[image]["orig_size"] = orig_size
        image_stats[image]["compressed_size"] = compressed_size
        image_stats[image]["runtime"] = runtime

    return image_stats


def run_compression(in_dir, out_dir, image_quality):
    images = [os.path.join(in_dir, f) for f in os.listdir(in_dir) if ".png" in f]

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    image_stats = process_image_batch(images, image_quality, out_dir)

    return image_stats

if __name__ == '__main__':
    main()

RESPONSE

Below is the modified script that meets the requirements. In this version, the main() function uses the existing helper functions (run_compression, process_image_batch, etc.) to convert PNG files to WEBP format (using the specified quality via cwebp), and it also copies over any non‐PNG files into the output directory. You can run the script with the following command-line arguments:

  --input-dir <input_directory> --output-dir <output_directory> --quality <quality_level>

Below is the full modified code:

------------------------------------------------------------
#!/usr/bin/env python3

import os
import sys
import subprocess
import time
import shutil
import argparse

def process_image(in_image, image_quality, out_dir):
    # Input file size
    orig_size = os.path.getsize(in_image)

    # Input file basename
    basename = os.path.basename(in_image)

    # Assuming no dots in file name beyond file extension
    no_ext = basename.split(".")[0]

    # Output filename: change extension to .webp
    out_image = os.path.join(out_dir, no_ext + ".webp")

    # Collect runtime info
    t_0 = time.perf_counter()

    # Build command for lossy conversion using cwebp
    command = "cwebp -near_lossless " + str(image_quality) + " " + in_image + " -o " + out_image
    process = subprocess.run(command, shell=True, capture_output=True, text=True)

    t_1 = time.perf_counter()
    runtime = t_1 - t_0

    compressed_size = os.path.getsize(out_image)

    return orig_size, compressed_size, runtime

def process_image_batch(images, image_quality, out_dir):
    image_stats = {}

    for image in images:
        image_stats[image] = {}
        orig_size, compressed_size, runtime = process_image(image, image_quality, out_dir)
        image_stats[image]["orig_size"] = orig_size
        image_stats[image]["compressed_size"] = compressed_size
        image_stats[image]["runtime"] = runtime

    return image_stats

def run_compression(in_dir, out_dir, image_quality):
    # Get only PNG files
    images = [os.path.join(in_dir, f) for f in os.listdir(in_dir) if f.lower().endswith('.png')]

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    image_stats = process_image_batch(images, image_quality, out_dir)
    return image_stats

def copy_non_png_files(in_dir, out_dir):
    # Iterate over all files in the input directory
    for f in os.listdir(in_dir):
        input_path = os.path.join(in_dir, f)
        # If it is a file and not a PNG (we assume PNG files end with .png, case insensitive),
        # then copy it into the output directory.
        if os.path.isfile(input_path) and not f.lower().endswith('.png'):
            output_path = os.path.join(out_dir, f)
            shutil.copy2(input_path, output_path)

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Convert PNG images to WEBP, and copy non-PNG files.")
    parser.add_argument("--input-dir", required=True, help="Input directory containing the image files")
    parser.add_argument("--output-dir", required=True, help="Output directory to place WEBP images and copies of non-PNG files")
    parser.add_argument("--quality", type=int, required=True, help="Quality level for lossy PNG-to-WEBP conversion using cwebp")
    args = parser.parse_args()

    in_dir = args.input_dir
    out_dir = args.output_dir
    quality = args.quality

    # Check if input directory exists
    if not os.path.exists(in_dir):
        print("Error: Input directory does not exist.")
        sys.exit(1)

    # Create the output directory if necessary
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    # Process the PNG images using the helper functions.
    print("Converting PNG files to WEBP...")
    png_stats = run_compression(in_dir, out_dir, quality)
    for image, stats in png_stats.items():
        print(f"{os.path.basename(image)}: original size = {stats['orig_size']} bytes, WEBP size = {stats['compressed_size']} bytes, conversion time = {stats['runtime']:.3f} seconds")

    # Copy the non-PNG files to the output directory.
    print("Copying non-PNG files...")
    copy_non_png_files(in_dir, out_dir)

    print("Processing complete.")

if __name__ == '__main__':
    main()

------------------------------------------------------------

How it works:

1. The script uses argparse to fetch the --input-dir, --output-dir, and --quality parameters.
2. The run_compression() function finds all PNG files and converts them to WEBP using the process_image() and process_image_batch() helper functions. The conversion uses cwebp with a lossy conversion (via the -near_lossless flag) with the user-specified quality level.
3. The copy_non_png_files() function copies any file that does not have a .png (case insensitive) extension into the output directory.
4. In the output directory, converted images have the same basename as the original PNG, but with a .webp extension.
5. The script prints out the conversion stats for each PNG image processed.

This implementation meets the requirements as described.