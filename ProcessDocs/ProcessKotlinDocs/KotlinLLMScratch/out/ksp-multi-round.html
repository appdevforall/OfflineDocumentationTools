<html lang="en"><head><meta charset="utf-8"/><title>Multiple round processing | Kotlin</title><link href="style.css" rel="stylesheet"/></head><body><div style="text-align:center; margin-bottom: 1em;"><a href="toc.html" style="font-size:2em; font-weight:bold;">Menu</a></div><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ksp-multi-round" id="ksp-multi-round.md">Multiple round processing</h1><p id="qjeu6n_2">KSP supports <span class="emphasis" id="qjeu6n_6">multiple round processing</span>, or processing files over multiple rounds. It means that subsequent rounds use an output from previous rounds as additional input.</p><section class="chapter"><h2 data-toc="changes-to-your-processor" id="changes-to-your-processor">Changes to your processor</h2><p id="qjeu6n_7">To use multiple round processing, the <code class="code" id="qjeu6n_10">SymbolProcessor.process()</code> function needs to return a list of deferred symbols (<code class="code" id="qjeu6n_11">List&lt;KSAnnotated&gt;</code>) for invalid symbols. Use <code class="code" id="qjeu6n_12">KSAnnotated.validate()</code> to filter invalid symbols to be deferred to the next round.</p><p id="qjeu6n_8">The following sample code shows how to defer invalid symbols by using a validation check:</p><div class="code-block" data-lang="kotlin" style="font-family: monospace; white-space: pre-wrap;">
override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {
    val symbols = resolver.getSymbolsWithAnnotation("com.example.annotation.Builder")
    val result = symbols.filter { !it.validate() }
    symbols
        .filter { it is KSClassDeclaration &amp;&amp; it.validate() }
        .map { it.accept(BuilderVisitor(), Unit) }
    return result
}
</div></section><section class="chapter"><h2 data-toc="multiple-round-behavior" id="multiple-round-behavior">Multiple round behavior</h2><section class="chapter"><h3 data-toc="deferring-symbols-to-the-next-round" id="deferring-symbols-to-the-next-round">Deferring symbols to the next round</h3><p id="qjeu6n_21">Processors can defer the processing of certain symbols to the next round. When a symbol is deferred, processor is waiting for other processors to provide additional information. It can continue deferring the symbol as many rounds as needed. Once the other processors provide the required information, the processor can then process the deferred symbol. Processor should only defer invalid symbols which are lacking necessary information. Therefore, processors should <span class="control" id="qjeu6n_23">not</span> defer symbols from classpath, KSP will also filter out any deferred symbols that are not from source code.</p><p id="qjeu6n_22">As an example, a processor that creates a builder for an annotated class might require all parameter types of its constructors to be valid (resolved to a concrete type). In the first round, one of the parameter type is not resolvable. Then in the second round, it becomes resolvable because of the generated files from the first round.</p></section><section class="chapter"><h3 data-toc="validating-symbols" id="validating-symbols">Validating symbols</h3><p id="qjeu6n_24">A convenient way to decide if a symbol should be deferred is through validation. A processor should know which information is necessary to properly process the symbol. Note that validation usually requires resolution which can be expensive, so we recommend checking only what is required. Continuing with the previous example, an ideal validation for the builder processor checks only whether all resolved parameter types of the constructors of annotated symbols contain <code class="code" id="qjeu6n_26">isError == false</code>.</p><p id="qjeu6n_25">KSP provides a default validation utility. For more information, see the <a data-tooltip="The default validation logic provided by KSP validates all directly reachable symbols inside the enclosing scope of the symbol that is being validated. Default validation checks whether references in the enclosed scope are resolvable to a concrete type but does not recursively diveâ€¦" href="#advanced" id="qjeu6n_27" style="color:blue !important;">Advanced</a> section.</p></section><section class="chapter"><h3 data-toc="termination-condition" id="termination-condition">Termination condition</h3><p id="qjeu6n_28">Multiple round processing terminates when a full round of processing generates no new files. If unprocessed deferred symbols still exist when the termination condition is met, KSP logs an error message for each processor with unprocessed deferred symbols.</p></section><section class="chapter"><h3 data-toc="files-accessible-at-each-round" id="files-accessible-at-each-round">Files accessible at each round</h3><p id="qjeu6n_29">Both newly generated files and existing files are accessible through a <code class="code" id="qjeu6n_30">Resolver</code>. KSP provides two APIs for accessing files: <code class="code" id="qjeu6n_31">Resolver.getAllFiles()</code> and <code class="code" id="qjeu6n_32">Resolver.getNewFiles()</code>. <code class="code" id="qjeu6n_33">getAllFiles()</code> returns a combined list of both existing files and newly generated files, while <code class="code" id="qjeu6n_34">getNewFiles()</code> returns only newly generated files.</p></section><section class="chapter"><h3 data-toc="changes-to-getsymbolsannotatedwith" id="changes-to-getsymbolsannotatedwith">Changes to getSymbolsAnnotatedWith()</h3><p id="qjeu6n_35">To avoid unnecessary reprocessing of symbols, <code class="code" id="qjeu6n_36">getSymbolsAnnotatedWith()</code> returns only those symbols found in newly generated files, together with the symbols from deferred symbols from the last round.</p></section><section class="chapter"><h3 data-toc="processor-instantiating" id="processor-instantiating">Processor instantiating</h3><p id="qjeu6n_37">A processor instance is created only once, which means you can store information in the processor object to be used for later rounds.</p></section><section class="chapter"><h3 data-toc="information-consistent-cross-rounds" id="information-consistent-cross-rounds">Information consistent cross rounds</h3><p id="qjeu6n_38">All KSP symbols will not be reusable across multiple rounds, as the resolution result can potentially change based on what was generated in a previous round. However, since KSP does not allow modifying existing code, some information such as the string value for a symbol name should still be reusable. To summarize, processors can store information from previous rounds but need to bear in mind that this information might be invalid in future rounds.</p></section><section class="chapter"><h3 data-toc="error-and-exception-handling" id="error-and-exception-handling">Error and exception handling</h3><p id="qjeu6n_39">When an error (defined by processor calling <code class="code" id="qjeu6n_43">KSPLogger.error()</code>) or exception occurs, processing stops after the current round completes. All processors will call the <code class="code" id="qjeu6n_44">onError()</code> method and will <span class="control" id="qjeu6n_45">not</span> call the <code class="code" id="qjeu6n_46">finish()</code> method.</p><p id="qjeu6n_40">Note that even though an error has occurred, other processors continue processing normally for that round. This means that error handling occurs after processing has completed for the round.</p><p id="qjeu6n_41">Upon exceptions, KSP will try to distinguish the exceptions from KSP and exceptions from processors. Exceptions will result in a termination of processing immediately and be logged as an error in KSPLogger. Exceptions from KSP should be reported to KSP developers for further investigation. At the end of the round where exceptions or errors happened, all processors will invoke onError() function to do their own error handling.</p><p id="qjeu6n_42">KSP provides a default no-op implementation for <code class="code" id="qjeu6n_47">onError()</code> as part of the <code class="code" id="qjeu6n_48">SymbolProcessor</code> interface. You can override this method to provide your own error handling logic.</p></section></section><section class="chapter"><h2 data-toc="advanced" id="advanced">Advanced</h2><section class="chapter"><h3 data-toc="default-behavior-for-validation" id="default-behavior-for-validation">Default behavior for validation</h3><p id="qjeu6n_51">The default validation logic provided by KSP validates all directly reachable symbols inside the enclosing scope of the symbol that is being validated. Default validation checks whether references in the enclosed scope are resolvable to a concrete type but does not recursively dive into the referenced types to perform validation.</p></section><section class="chapter"><h3 data-toc="write-your-own-validation-logic" id="write-your-own-validation-logic">Write your own validation logic</h3><p id="qjeu6n_52">Default validation behavior might not be suitable for all cases. You can reference <code class="code" id="qjeu6n_53">KSValidateVisitor</code> and write your own validation logic by providing a custom <code class="code" id="qjeu6n_54">predicate</code> lambda, which is then used by <code class="code" id="qjeu6n_55">KSValidateVisitor</code> to filter out symbols that need to be checked.</p></section></section><div class="last-modified">19 April 2025</div><div data-feedback-placeholder="true"></div></article></body></html>