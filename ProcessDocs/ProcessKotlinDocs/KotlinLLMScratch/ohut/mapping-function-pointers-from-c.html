<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Kotlin Documentation
  </title>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div style="text-align: center; margin-bottom: 1em;">
   <a href="toc.html" style="font-size: 24px; text-decoration: none;">
    Menu
   </a>
  </div>
  <article class="article" data-shortcut-switcher="inactive">
   <h1 data-toc="mapping-function-pointers-from-c" id="mapping-function-pointers-from-c.md">
    Mapping function pointers from C â€“ tutorial
   </h1>
   <div class="micro-format" data-content='{"microFormat":["\u003cp id\u003d\"-rih9p7_13\"\u003eThis is the third part of the \u003cb id\u003d\"-rih9p7_15\"\u003eMapping Kotlin and C\u003c/b\u003e tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\u003c/p\u003e","\u003cp id\u003d\"-rih9p7_14\"\u003e\u003cimg alt\u003d\"First step\" src\u003d\"images/icon-1-done.svg\" class\u003d\"inline-icon-\" title\u003d\"First step\" id\u003d\"-rih9p7_16\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-primitive-data-types-from-c.html\" id\u003d\"-rih9p7_17\" data-tooltip\u003d\"This is the first part of the Mapping Kotlin and C tutorial series.\"\u003eMapping primitive data types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Second step\" src\u003d\"images/icon-2-done.svg\" class\u003d\"inline-icon-\" title\u003d\"Second step\" id\u003d\"-rih9p7_19\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-struct-union-types-from-c.html\" id\u003d\"-rih9p7_20\" data-tooltip\u003d\"This is the second part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous step.\"\u003eMapping struct and union types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Third step\" src\u003d\"images/icon-3.svg\" class\u003d\"inline-icon-\" title\u003d\"Third step\" id\u003d\"-rih9p7_22\" width\u003d\"20\" height\u003d\"20\"\u003e \u003cb id\u003d\"-rih9p7_23\"\u003eMapping function pointers\u003c/b\u003e\u003cbr\u003e \u003cimg alt\u003d\"Fourth step\" src\u003d\"images/icon-4-todo.svg\" class\u003d\"inline-icon-\" title\u003d\"Fourth step\" id\u003d\"-rih9p7_25\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-strings-from-c.html\" id\u003d\"-rih9p7_26\" data-tooltip\u003d\"This is the final part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\"\u003eMapping strings from C\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e"]}'>
   </div>
   <aside class="prompt" data-title="" data-type="warning" id="-rih9p7_3">
    <p id="-rih9p7_28">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="-rih9p7_30" style="color: blue;">
      Experimental
     </a>
     . All Kotlin declarations generated by the cinterop tool from C libraries should have the
     <code class="code" id="-rih9p7_31">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="-rih9p7_29">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.
    </p>
   </aside>
   <p id="-rih9p7_4">
    Let's explore which C function pointers are visible from Kotlin and examine advanced C interop-related use cases of Kotlin/Native and
    <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="-rih9p7_32" style="color: blue;">
     multiplatform
    </a>
    Gradle builds.
   </p>
   <p id="-rih9p7_5">
    In this tutorial, you'll:
   </p>
   <ul class="list _bullet" id="-rih9p7_6">
    <li class="list__item" id="-rih9p7_33">
     <p id="-rih9p7_35">
      <a data-tooltip="It's time to try using C functions from Kotlin code. Call the accept_fun() function and pass the C function pointer to a Kotlin lambda:" href="#pass-kotlin-function-as-a-c-function-pointer" id="-rih9p7_36" style="color: blue;">
       Learn how to pass Kotlin function as a C function pointer
      </a>
     </p>
    </li>
    <li class="list__item" id="-rih9p7_34">
     <p id="-rih9p7_37">
      <a data-tooltip="The next step is to invoke a C function pointer returned from the supply_fun() call:" href="#use-the-c-function-pointer-from-kotlin" id="-rih9p7_38" style="color: blue;">
       Use C function pointers from Kotlin
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="mapping-function-pointer-types-from-c" id="mapping-function-pointer-types-from-c">
     Mapping function pointer types from C
    </h2>
    <p id="-rih9p7_39">
     To understand the mapping between Kotlin and C, let's declare two functions: one that accepts a function pointer as a parameter and another that returns a function pointer.
    </p>
    <p id="-rih9p7_40">
     In the
     <a data-tooltip="This is the first part of the Mapping Kotlin and C tutorial series." href="mapping-primitive-data-types-from-c.html" id="-rih9p7_43" style="color: blue;">
      first part of the series
     </a>
     of the series, you've already created a C library with the necessary files. For this step, update the declarations in the
     <code class="code" id="-rih9p7_44">
      interop.def
     </code>
     file after the
     <code class="code" id="-rih9p7_45">
      ---
     </code>
     separator:
    </p>
    <div class="code-block" data-lang="c" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     ---

int myFun(int i) {
  return i+1;
}

typedef int  (*MyFun)(int);

void accept_fun(MyFun f) {
  f(42);
}

MyFun supply_fun() {
  return myFun;
}
    </div>
    <p id="-rih9p7_42">
     The
     <code class="code" id="-rih9p7_46">
      interop.def
     </code>
     file provides everything necessary to compile, run, or open the application in an IDE.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="-rih9p7_47">
     Let's see how C function pointers are mapped into Kotlin/Native and update your project:
    </p>
    <ol class="list _decimal" id="-rih9p7_48" type="1">
     <li class="list__item" id="-rih9p7_51">
      <p id="-rih9p7_53">
       In
       <code class="code" id="-rih9p7_55">
        src/nativeMain/kotlin
       </code>
       , update your
       <code class="code" id="-rih9p7_56">
        hello.kt
       </code>
       file from the
       <a data-tooltip="This is the second part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you've completed the previous step." href="mapping-struct-union-types-from-c.html" id="-rih9p7_57" style="color: blue;">
        previous tutorial
       </a>
       with the following content:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       import interop.*
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    accept_fun(/* fix me*/)
    val useMe = supply_fun()
}
      </div>
     </li>
     <li class="list__item" id="-rih9p7_52">
      <p id="-rih9p7_58">
       Use IntelliJ IDEA's
       <a data-external="true" href="https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_Declaration.html" id="-rih9p7_60" rel="noopener noreferrer" style="color: red;" target="_blank">
        Go to declaration
       </a>
       command (
       <kbd class="keystroke" data-bypass="true" id="-rih9p7_61">
        <span class="keystroke__value">
         Cmd + B
        </span>
       </kbd>
       /
       <kbd class="keystroke" data-bypass="true" id="-rih9p7_62">
        <span class="keystroke__value">
         Ctrl + B
        </span>
       </kbd>
       ) to navigate to the following generated API for C functions:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       fun myFun(i: kotlin.Int): kotlin.Int
fun accept_fun(f: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlin.Int) -&gt; kotlin.Int&gt;&gt;? /* from: interop.MyFun? */)
fun supply_fun(): kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlin.Int) -&gt; kotlin.Int&gt;&gt;? /* from: interop.MyFun? */
      </div>
     </li>
    </ol>
    <p id="-rih9p7_49">
     As you can see, C function pointers are represented in Kotlin using
     <code class="code" id="-rih9p7_63">
      CPointer&lt;CFunction&lt;...&gt;&gt;
     </code>
     . The
     <code class="code" id="-rih9p7_64">
      accept_fun()
     </code>
     function takes an optional function pointer as a parameter, while
     <code class="code" id="-rih9p7_65">
      supply_fun()
     </code>
     returns a function pointer.
    </p>
    <p id="-rih9p7_50">
     <code class="code" id="-rih9p7_66">
      CFunction&lt;(Int) -&gt; Int&gt;
     </code>
     represents the function signature, and
     <code class="code" id="-rih9p7_67">
      CPointer&lt;CFunction&lt;...&gt;&gt;?
     </code>
     represents a nullable function pointer. There is an
     <code class="code" id="-rih9p7_68">
      invoke
     </code>
     operator extension function available for all
     <code class="code" id="-rih9p7_69">
      CPointer&lt;CFunction&lt;...&gt;&gt;
     </code>
     types, allowing you to call function pointers as if they were regular Kotlin functions.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="pass-kotlin-function-as-a-c-function-pointer" id="pass-kotlin-function-as-a-c-function-pointer">
     Pass Kotlin function as a C function pointer
    </h2>
    <p id="-rih9p7_70">
     It's time to try using C functions from Kotlin code. Call the
     <code class="code" id="-rih9p7_74">
      accept_fun()
     </code>
     function and pass the C function pointer to a Kotlin lambda:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.staticCFunction
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun myFun() {
    accept_fun(staticCFunction&lt;Int, Int&gt; { it + 1 })
}
    </div>
    <p id="-rih9p7_72">
     This call uses the
     <code class="code" id="-rih9p7_75">
      staticCFunction {}
     </code>
     helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It allows only unbound and non-capturing lambda functions. For example, it cannot capture a local variable from the function, only globally visible declarations.
    </p>
    <p id="-rih9p7_73">
     Ensure that the function doesn't throw any exceptions. Throwing exceptions from a
     <code class="code" id="-rih9p7_76">
      staticCFunction {}
     </code>
     causes non-deterministic side effects.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-the-c-function-pointer-from-kotlin" id="use-the-c-function-pointer-from-kotlin">
     Use the C function pointer from Kotlin
    </h2>
    <p id="-rih9p7_77">
     The next step is to invoke a C function pointer returned from the
     <code class="code" id="-rih9p7_80">
      supply_fun()
     </code>
     call:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.invoke

@OptIn(ExperimentalForeignApi::class)
fun myFun2() {
    val functionFromC = supply_fun() ?: error("No function is returned")

    functionFromC(42)
}
    </div>
    <p id="-rih9p7_79">
     Kotlin turns the function pointer return type into a nullable
     <code class="code" id="-rih9p7_81">
      CPointer&lt;CFunction&lt;&gt;
     </code>
     object. You need to first explicitly check for
     <code class="code" id="-rih9p7_82">
      null
     </code>
     , which is why the
     <a data-tooltip="Null safety is a Kotlin feature designed to significantly reduce the risk of null references, also known as The Billion-Dollar Mistake." href="null-safety.html" id="-rih9p7_83" style="color: blue;">
      Elvis operator
     </a>
     is used in the code above. The cinterop tool allows you to call a C function pointer as a regular Kotlin function call:
     <code class="code" id="-rih9p7_84">
      functionFromC(42)
     </code>
     .
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="update-kotlin-code" id="update-kotlin-code">
     Update Kotlin code
    </h2>
    <p id="-rih9p7_85">
     Now that you've seen all the definitions, try to use them in your project. The code in the
     <code class="code" id="-rih9p7_89">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.invoke
import kotlinx.cinterop.staticCFunction

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    val cFunctionPointer = staticCFunction&lt;Int, Int&gt; { it + 1 }
    accept_fun(cFunctionPointer)

    val funFromC = supply_fun() ?: error("No function is returned")
    funFromC(42)
}
    </div>
    <p id="-rih9p7_87">
     To verify that everything works as expected, run the
     <code class="code" id="-rih9p7_90">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="Open the Main.kt file in the src/nativeMain/kotlin/ directory:" href="native-get-started.html#build-and-run-the-application" id="-rih9p7_91" style="color: blue;">
      in your IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     ./gradlew runDebugExecutableNative
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-step" id="next-step">
     Next step
    </h2>
    <p id="-rih9p7_92">
     In the next part of the series, you'll learn how strings are mapped between Kotlin and C:
    </p>
    <p id="-rih9p7_93">
     <span class="control" id="-rih9p7_95">
      <a data-tooltip="This is the final part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you've completed the previous steps." href="mapping-strings-from-c.html" id="-rih9p7_96" style="color: blue;">
       Proceed to the next part
      </a>
     </span>
    </p>
    <section class="chapter">
     <h3 data-toc="see-also" id="see-also">
      See also
     </h3>
     <p id="-rih9p7_97">
      Learn more in the
      <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="-rih9p7_98" style="color: blue;">
       Interoperability with C
      </a>
      documentation that covers more advanced scenarios.
     </p>
    </section>
   </section>
   <div class="last-modified">
    19 April 2025
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </article>
 </body>
</html>
