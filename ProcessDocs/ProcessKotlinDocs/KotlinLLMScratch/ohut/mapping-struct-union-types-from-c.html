<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Kotlin Documentation
  </title>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div style="text-align: center; margin-bottom: 1em;">
   <a href="toc.html" style="font-size: 24px; text-decoration: none;">
    Menu
   </a>
  </div>
  <article class="article" data-shortcut-switcher="inactive">
   <h1 data-toc="mapping-struct-union-types-from-c" id="mapping-struct-union-types-from-c.md">
    Mapping struct and union types from C â€“ tutorial
   </h1>
   <div class="micro-format" data-content='{"microFormat":["\u003cp id\u003d\"-ku0u2v_12\"\u003eThis is the second part of the \u003cb id\u003d\"-ku0u2v_14\"\u003eMapping Kotlin and C\u003c/b\u003e tutorial series. Before proceeding, make sure you\u0027ve completed the previous step.\u003c/p\u003e","\u003cp id\u003d\"-ku0u2v_13\"\u003e\u003cimg alt\u003d\"First step\" src\u003d\"images/icon-1-done.svg\" class\u003d\"inline-icon-\" title\u003d\"First step\" id\u003d\"-ku0u2v_15\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-primitive-data-types-from-c.html\" id\u003d\"-ku0u2v_16\" data-tooltip\u003d\"This is the first part of the Mapping Kotlin and C tutorial series.\"\u003eMapping primitive data types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Second step\" src\u003d\"images/icon-2.svg\" class\u003d\"inline-icon-\" title\u003d\"Second step\" id\u003d\"-ku0u2v_18\" width\u003d\"20\" height\u003d\"20\"\u003e \u003cb id\u003d\"-ku0u2v_19\"\u003eMapping struct and union types from C\u003c/b\u003e\u003cbr\u003e \u003cimg alt\u003d\"Third step\" src\u003d\"images/icon-3-todo.svg\" class\u003d\"inline-icon-\" title\u003d\"Third step\" id\u003d\"-ku0u2v_21\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-function-pointers-from-c.html\" id\u003d\"-ku0u2v_22\" data-tooltip\u003d\"This is the third part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\"\u003eMapping function pointers\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Fourth step\" src\u003d\"images/icon-4-todo.svg\" class\u003d\"inline-icon-\" title\u003d\"Fourth step\" id\u003d\"-ku0u2v_24\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-strings-from-c.html\" id\u003d\"-ku0u2v_25\" data-tooltip\u003d\"This is the final part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\"\u003eMapping strings from C\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e"]}'>
   </div>
   <aside class="prompt" data-title="" data-type="warning" id="-ku0u2v_3">
    <p id="-ku0u2v_27">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="-ku0u2v_29" style="color: blue;">
      Experimental
     </a>
     . All Kotlin declarations generated by the cinterop tool from C libraries should have the
     <code class="code" id="-ku0u2v_30">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="-ku0u2v_28">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.
    </p>
   </aside>
   <p id="-ku0u2v_4">
    Let's explore which C struct and union declarations are visible from Kotlin and examine advanced C interop-related use cases of Kotlin/Native and
    <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="-ku0u2v_31" style="color: blue;">
     multiplatform
    </a>
    Gradle builds.
   </p>
   <p id="-ku0u2v_5">
    In the tutorial, you'll learn:
   </p>
   <ul class="list _bullet" id="-ku0u2v_6">
    <li class="list__item" id="-ku0u2v_32">
     <p id="-ku0u2v_34">
      <a data-tooltip="To understand how Kotlin maps struct and union types, let's declare them in C and examine how they are represented in Kotlin." href="#mapping-struct-and-union-c-types" id="-ku0u2v_35" style="color: blue;">
       How struct and union types are mapped
      </a>
     </p>
    </li>
    <li class="list__item" id="-ku0u2v_33">
     <p id="-ku0u2v_36">
      <a data-tooltip="Using C struct and union types from Kotlin is straightforward thanks to the generated API. The only question is how to create new instances of these types." href="#use-struct-and-union-types-from-kotlin" id="-ku0u2v_37" style="color: blue;">
       How to use struct and union types from Kotlin
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="mapping-struct-and-union-c-types" id="mapping-struct-and-union-c-types">
     Mapping struct and union C types
    </h2>
    <p id="-ku0u2v_38">
     To understand how Kotlin maps struct and union types, let's declare them in C and examine how they are represented in Kotlin.
    </p>
    <p id="-ku0u2v_39">
     In the
     <a data-tooltip="This is the first part of the Mapping Kotlin and C tutorial series." href="mapping-primitive-data-types-from-c.html" id="-ku0u2v_42" style="color: blue;">
      previous tutorial
     </a>
     , you've already created a C library with the necessary files. For this step, update the declarations in the
     <code class="code" id="-ku0u2v_43">
      interop.def
     </code>
     file after the
     <code class="code" id="-ku0u2v_44">
      ---
     </code>
     separator:
    </p>
    <div class="code-block" data-lang="c" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     ---

typedef struct {
  int a;
  double b;
} MyStruct;

void struct_by_value(MyStruct s) {}
void struct_by_pointer(MyStruct* s) {}

typedef union {
  int a;
  MyStruct b;
  float c;
} MyUnion;

void union_by_value(MyUnion u) {}
void union_by_pointer(MyUnion* u) {}
    </div>
    <p id="-ku0u2v_41">
     The
     <code class="code" id="-ku0u2v_45">
      interop.def
     </code>
     file provides everything necessary to compile, run, or open the application in an IDE.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="-ku0u2v_46">
     Let's see how C struct and union types are mapped into Kotlin/Native and update your project:
    </p>
    <ol class="list _decimal" id="-ku0u2v_47" type="1">
     <li class="list__item" id="-ku0u2v_50">
      <p id="-ku0u2v_53">
       In
       <code class="code" id="-ku0u2v_55">
        src/nativeMain/kotlin
       </code>
       , update your
       <code class="code" id="-ku0u2v_56">
        hello.kt
       </code>
       file from the
       <a data-tooltip="This is the first part of the Mapping Kotlin and C tutorial series." href="mapping-primitive-data-types-from-c.html" id="-ku0u2v_57" style="color: blue;">
        previous tutorial
       </a>
       with the following content:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       import interop.*
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    struct_by_value(/* fix me*/)
    struct_by_pointer(/* fix me*/)
    union_by_value(/* fix me*/)
    union_by_pointer(/* fix me*/)
}
      </div>
     </li>
     <li class="list__item" id="-ku0u2v_51">
      <p id="-ku0u2v_58">
       To avoid compiler errors, add interoperability to the build process. For that, update your
       <code class="code" id="-ku0u2v_60">
        build.gradle(.kts)
       </code>
       build file with the following content:
      </p>
      <div class="tabs" data-anchors="[-ku0u2v_61,-ku0u2v_62]" data-group="build-script" id="-ku0u2v_59">
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="-ku0u2v_61">
        <div class="code-block" data-lang="kotlin" data-title="Kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
         kotlin {
    macosArm64("native") {    // macOS on Apple Silicon
    // macosX64("native") {   // macOS on x86_64 platforms
    // linuxArm64("native") { // Linux on ARM64 platforms 
    // linuxX64("native") {   // Linux on x86_64 platforms
    // mingwX64("native") {   // on Windows
        val main by compilations.getting
        val interop by main.cinterops.creating {
            definitionFile.set(project.file("src/nativeInterop/cinterop/interop.def"))
        }

        binaries {
            executable()
        }
    }
}
        </div>
       </div>
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="-ku0u2v_62">
        <div class="code-block" data-lang="groovy" data-title="Groovy" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
         kotlin {
    macosArm64("native") {    // Apple Silicon macOS
    // macosX64("native") {   // macOS on x86_64 platforms
    // linuxArm64("native") { // Linux on ARM64 platforms
    // linuxX64("native") {   // Linux on x86_64 platforms
    // mingwX64("native") {   // Windows
        compilations.main.cinterops {
            interop {   
                definitionFile = project.file('src/nativeInterop/cinterop/interop.def')
            }
        }

        binaries {
            executable()
        }
    }
}
        </div>
       </div>
      </div>
     </li>
     <li class="list__item" id="-ku0u2v_52">
      <p id="-ku0u2v_65">
       Use IntelliJ IDEA's
       <a data-external="true" href="https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_Declaration.html" id="-ku0u2v_67" rel="noopener noreferrer" style="color: red;" target="_blank">
        Go to declaration
       </a>
       command (
       <kbd class="keystroke" data-bypass="true" id="-ku0u2v_68">
        <span class="keystroke__value">
         Cmd + B
        </span>
       </kbd>
       /
       <kbd class="keystroke" data-bypass="true" id="-ku0u2v_69">
        <span class="keystroke__value">
         Ctrl + B
        </span>
       </kbd>
       ) to navigate to the following generated API for C functions, struct, and union:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       fun struct_by_value(s: kotlinx.cinterop.CValue&lt;interop.MyStruct&gt;)
fun struct_by_pointer(s: kotlinx.cinterop.CValuesRef&lt;interop.MyStruct&gt;?)

fun union_by_value(u: kotlinx.cinterop.CValue&lt;interop.MyUnion&gt;)
fun union_by_pointer(u: kotlinx.cinterop.CValuesRef&lt;interop.MyUnion&gt;?)
      </div>
     </li>
    </ol>
    <p id="-ku0u2v_48">
     Technically, there is no difference between struct and union types on the Kotlin side. The cinterop tool generates Kotlin types for both struct and union C declarations.
    </p>
    <p id="-ku0u2v_49">
     The generated API includes fully qualified package names for
     <code class="code" id="-ku0u2v_70">
      CValue&lt;T&gt;
     </code>
     and
     <code class="code" id="-ku0u2v_71">
      CValuesRef&lt;T&gt;
     </code>
     , reflecting their location in
     <code class="code" id="-ku0u2v_72">
      kotlinx.cinterop
     </code>
     .
     <code class="code" id="-ku0u2v_73">
      CValue&lt;T&gt;
     </code>
     represents a by-value structure parameter, while
     <code class="code" id="-ku0u2v_74">
      CValuesRef&lt;T&gt;?
     </code>
     is used to pass a pointer to a structure or a union.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-struct-and-union-types-from-kotlin" id="use-struct-and-union-types-from-kotlin">
     Use struct and union types from Kotlin
    </h2>
    <p id="-ku0u2v_75">
     Using C struct and union types from Kotlin is straightforward thanks to the generated API. The only question is how to create new instances of these types.
    </p>
    <p id="-ku0u2v_76">
     Let's take a look at the generated functions that take
     <code class="code" id="-ku0u2v_81">
      MyStruct
     </code>
     and
     <code class="code" id="-ku0u2v_82">
      MyUnion
     </code>
     as parameters. By-value parameters are represented as
     <code class="code" id="-ku0u2v_83">
      kotlinx.cinterop.CValue&lt;T&gt;
     </code>
     , while pointer-typed parameters use
     <code class="code" id="-ku0u2v_84">
      kotlinx.cinterop.CValuesRef&lt;T&gt;?
     </code>
     .
    </p>
    <p id="-ku0u2v_77">
     Kotlin provides a convenient API for creating and working with these types. Let's explore how to use it in practice.
    </p>
    <section class="chapter">
     <h3 data-toc="create-a-cvalue-t" id="create-a-cvalue-t">
      Create a CValue&lt;T&gt;
     </h3>
     <p id="-ku0u2v_86">
      <code class="code" id="-ku0u2v_90">
       CValue&lt;T&gt;
      </code>
      type is used to pass by-value parameters to a C function call. Use the
      <code class="code" id="-ku0u2v_91">
       cValue
      </code>
      function to create a
      <code class="code" id="-ku0u2v_92">
       CValue&lt;T&gt;
      </code>
      instance. The function requires a
      <a data-tooltip="Function types with receiver, such as A.(B) -&gt; C, can be instantiated with a special form of function literals â€“ function literals with receiver." href="lambdas.html#function-literals-with-receiver" id="-ku0u2v_93" style="color: blue;">
       lambda function with a receiver
      </a>
      to initialize the underlying C type in-place. The function is declared as follows:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      fun &lt;reified T : CStructVar&gt; cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;
     </div>
     <p id="-ku0u2v_88">
      Here's how to use
      <code class="code" id="-ku0u2v_94">
       cValue
      </code>
      and pass by-value parameters:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.cValue

@OptIn(ExperimentalForeignApi::class)
fun callValue() {

    val cStruct = cValue&lt;MyStruct&gt; {
        a = 42
        b = 3.14
    }
    struct_by_value(cStruct)

    val cUnion = cValue&lt;MyUnion&gt; {
        b.a = 5
        b.b = 2.7182
    }

    union_by_value(cUnion)
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="create-struct-and-union-as-cvaluesref-t" id="create-struct-and-union-as-cvaluesref-t">
      Create struct and union as CValuesRef&lt;T&gt;
     </h3>
     <p id="-ku0u2v_96">
      The
      <code class="code" id="-ku0u2v_104">
       CValuesRef&lt;T&gt;
      </code>
      type is used in Kotlin to pass a pointer-typed parameter of a C function. To allocate
      <code class="code" id="-ku0u2v_105">
       MyStruct
      </code>
      and
      <code class="code" id="-ku0u2v_106">
       MyUnion
      </code>
      in the native memory, use the following extension function on
      <code class="code" id="-ku0u2v_107">
       kotlinx.cinterop.NativePlacement
      </code>
      type:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      fun &lt;reified T : kotlinx.cinterop.CVariable&gt; alloc(): T
     </div>
     <p id="-ku0u2v_98">
      <code class="code" id="-ku0u2v_108">
       NativePlacement
      </code>
      represents native memory with functions similar to
      <code class="code" id="-ku0u2v_109">
       malloc
      </code>
      and
      <code class="code" id="-ku0u2v_110">
       free
      </code>
      . There are several implementations of
      <code class="code" id="-ku0u2v_111">
       NativePlacement
      </code>
      :
     </p>
     <ul class="list _bullet" id="-ku0u2v_99">
      <li class="list__item" id="-ku0u2v_112">
       <p id="-ku0u2v_114">
        The global implementation is
        <code class="code" id="-ku0u2v_115">
         kotlinx.cinterop.nativeHeap
        </code>
        , but you must call
        <code class="code" id="-ku0u2v_116">
         nativeHeap.free()
        </code>
        to release the memory after use.
       </p>
      </li>
      <li class="list__item" id="-ku0u2v_113">
       <p id="-ku0u2v_117">
        A safer alternative is
        <code class="code" id="-ku0u2v_119">
         memScoped()
        </code>
        , which creates a short-lived memory scope where all allocations are automatically freed at the end of the block:
       </p>
       <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
        fun &lt;R&gt; memScoped(block: kotlinx.cinterop.MemScope.() -&gt; R): R
       </div>
      </li>
     </ul>
     <p id="-ku0u2v_100">
      With
      <code class="code" id="-ku0u2v_120">
       memScoped()
      </code>
      , your code for calling functions with pointers can look like this:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.alloc
import kotlinx.cinterop.ptr

@OptIn(ExperimentalForeignApi::class)
fun callRef() {
    memScoped {
        val cStruct = alloc&lt;MyStruct&gt;()
        cStruct.a = 42
        cStruct.b = 3.14

        struct_by_pointer(cStruct.ptr)

        val cUnion = alloc&lt;MyUnion&gt;()
        cUnion.b.a = 5
        cUnion.b.b = 2.7182

        union_by_pointer(cUnion.ptr)
    }
}
     </div>
     <p id="-ku0u2v_102">
      Here, the
      <code class="code" id="-ku0u2v_121">
       ptr
      </code>
      extension property, which is available within the
      <code class="code" id="-ku0u2v_122">
       memScoped {}
      </code>
      block, converts
      <code class="code" id="-ku0u2v_123">
       MyStruct
      </code>
      and
      <code class="code" id="-ku0u2v_124">
       MyUnion
      </code>
      instances into native pointers.
     </p>
     <p id="-ku0u2v_103">
      Since memory is managed inside the
      <code class="code" id="-ku0u2v_125">
       memScoped {}
      </code>
      block, it's automatically freed at the end of the block. Avoid using pointers outside of this scope to prevent accessing deallocated memory. If you need longer-lived allocations (for example, for caching in a C library), consider using
      <code class="code" id="-ku0u2v_126">
       Arena()
      </code>
      or
      <code class="code" id="-ku0u2v_127">
       nativeHeap
      </code>
      .
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="conversion-between-cvalue-t-and-cvaluesref-t" id="conversion-between-cvalue-t-and-cvaluesref-t">
      Conversion between CValue&lt;T&gt; and CValuesRef&lt;T&gt;
     </h3>
     <p id="-ku0u2v_129">
      Sometimes you need to pass a struct as a value in one function call and then pass the same struct as a reference in another.
     </p>
     <p id="-ku0u2v_130">
      To do this, you'll need a
      <code class="code" id="-ku0u2v_135">
       NativePlacement
      </code>
      , but first, let's see how
      <code class="code" id="-ku0u2v_136">
       CValue&lt;T&gt;
      </code>
      is turned into a pointer:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.cValue
import kotlinx.cinterop.memScoped

@OptIn(ExperimentalForeignApi::class)
fun callMix_ref() {
    val cStruct = cValue&lt;MyStruct&gt; {
        a = 42
        b = 3.14
    }

    memScoped {
        struct_by_pointer(cStruct.ptr)
    }
}
     </div>
     <p id="-ku0u2v_132">
      Here again, the
      <code class="code" id="-ku0u2v_137">
       ptr
      </code>
      extension property from
      <code class="code" id="-ku0u2v_138">
       memScoped {}
      </code>
      turns
      <code class="code" id="-ku0u2v_139">
       MyStruct
      </code>
      instances into native pointers. These pointers are only valid inside the
      <code class="code" id="-ku0u2v_140">
       memScoped {}
      </code>
      block.
     </p>
     <p id="-ku0u2v_133">
      To turn a pointer back into a by-value variable, call the
      <code class="code" id="-ku0u2v_141">
       .readValue()
      </code>
      extension function:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      import interop.*
import kotlinx.cinterop.alloc
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.readValue

@OptIn(ExperimentalForeignApi::class)
fun callMix_value() {
    memScoped {
        val cStruct = alloc&lt;MyStruct&gt;()
        cStruct.a = 42
        cStruct.b = 3.14

        struct_by_value(cStruct.readValue())
    }
}
     </div>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="update-kotlin-code" id="update-kotlin-code">
     Update Kotlin code
    </h2>
    <p id="-ku0u2v_142">
     Now that you've learned how to use C declarations in Kotlin code, try to use them in your project. The final code in the
     <code class="code" id="-ku0u2v_146">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.alloc
import kotlinx.cinterop.cValue
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.ptr
import kotlinx.cinterop.readValue
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    val cUnion = cValue&lt;MyUnion&gt; {
        b.a = 5
        b.b = 2.7182
    }

    memScoped {
        union_by_value(cUnion)
        union_by_pointer(cUnion.ptr)
    }

    memScoped {
        val cStruct = alloc&lt;MyStruct&gt; {
            a = 42
            b = 3.14
        }

        struct_by_value(cStruct.readValue())
        struct_by_pointer(cStruct.ptr)
    }
}
    </div>
    <p id="-ku0u2v_144">
     To verify that everything works as expected, run the
     <code class="code" id="-ku0u2v_147">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="Open the Main.kt file in the src/nativeMain/kotlin/ directory:" href="native-get-started.html#build-and-run-the-application" id="-ku0u2v_148" style="color: blue;">
      in your IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     ./gradlew runDebugExecutableNative
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-step" id="next-step">
     Next step
    </h2>
    <p id="-ku0u2v_149">
     In the next part of the series, you'll learn how function pointers are mapped between Kotlin and C:
    </p>
    <p id="-ku0u2v_150">
     <span class="control" id="-ku0u2v_152">
      <a data-tooltip="This is the third part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you've completed the previous steps." href="mapping-function-pointers-from-c.html" id="-ku0u2v_153" style="color: blue;">
       Proceed to the next part
      </a>
     </span>
    </p>
    <section class="chapter">
     <h3 data-toc="see-also" id="see-also">
      See also
     </h3>
     <p id="-ku0u2v_154">
      Learn more in the
      <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="-ku0u2v_155" style="color: blue;">
       Interoperability with C
      </a>
      documentation that covers more advanced scenarios.
     </p>
    </section>
   </section>
   <div class="last-modified">
    19 April 2025
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </article>
 </body>
</html>
