<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Kotlin Documentation
  </title>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div style="text-align: center; margin-bottom: 1em;">
   <a href="toc.html" style="font-size: 24px; text-decoration: none;">
    Menu
   </a>
  </div>
  <article class="article" data-shortcut-switcher="inactive">
   <h1 data-toc="js-modules" id="js-modules.md">
    JavaScript modules
   </h1>
   <p id="j04xer_2">
    You can compile your Kotlin projects to JavaScript modules for various popular module systems. We currently support the following configurations for JavaScript modules:
   </p>
   <ul class="list _bullet" id="j04xer_3">
    <li class="list__item" id="j04xer_7">
     <p id="j04xer_11">
      <a data-external="true" href="https://github.com/umdjs/umd" id="j04xer_12" rel="noopener noreferrer" style="color: red;" target="_blank">
       Unified Module Definitions (UMD)
      </a>
      , which is compatible with both
      <span class="emphasis" id="j04xer_13">
       AMD
      </span>
      and
      <span class="emphasis" id="j04xer_14">
       CommonJS
      </span>
      . UMD modules are also able to be executed without being imported or when no module system is present. This is the default option for the
      <code class="code" id="j04xer_15">
       browser
      </code>
      and
      <code class="code" id="j04xer_16">
       nodejs
      </code>
      targets.
     </p>
    </li>
    <li class="list__item" id="j04xer_8">
     <p id="j04xer_17">
      <a data-external="true" href="https://github.com/amdjs/amdjs-api/wiki/AMD" id="j04xer_18" rel="noopener noreferrer" style="color: red;" target="_blank">
       Asynchronous Module Definitions (AMD)
      </a>
      , which is in particular used by the
      <a data-external="true" href="https://requirejs.org/" id="j04xer_19" rel="noopener noreferrer" style="color: red;" target="_blank">
       RequireJS
      </a>
      library.
     </p>
    </li>
    <li class="list__item" id="j04xer_9">
     <p id="j04xer_20">
      <a data-external="true" href="http://wiki.commonjs.org/wiki/Modules/1.1" id="j04xer_21" rel="noopener noreferrer" style="color: red;" target="_blank">
       CommonJS
      </a>
      , widely used by Node.js/npm (
      <code class="code" id="j04xer_22">
       require
      </code>
      function and
      <code class="code" id="j04xer_23">
       module.exports
      </code>
      object).
     </p>
    </li>
    <li class="list__item" id="j04xer_10">
     <p id="j04xer_24">
      Plain. Don't compile for any module system. You can access a module by its name in the global scope.
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="browser-targets" id="browser-targets">
     Browser targets
    </h2>
    <p id="j04xer_25">
     If you intend to run your code in a web browser environment and want to use a module system other than UMD, you can specify the desired module type in the
     <code class="code" id="j04xer_28">
      webpackTask
     </code>
     configuration block. For example, to switch to CommonJS, use:
    </p>
    <div class="code-block" data-lang="groovy" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     kotlin {
    js {
        browser {
            webpackTask {
                output.libraryTarget = "commonjs2"
            }
        }
        binaries.executable()
    }
}
    </div>
    <p id="j04xer_27">
     Webpack provides two different flavors of CommonJS,
     <code class="code" id="j04xer_29">
      commonjs
     </code>
     and
     <code class="code" id="j04xer_30">
      commonjs2
     </code>
     , which affect the way your declarations are made available. In most cases, you probably want
     <code class="code" id="j04xer_31">
      commonjs2
     </code>
     , which adds the
     <code class="code" id="j04xer_32">
      module.exports
     </code>
     syntax to the generated library. Alternatively, you can also opt for the
     <code class="code" id="j04xer_33">
      commonjs
     </code>
     option, which adheres strictly to the CommonJS specification. To learn more about the difference between
     <code class="code" id="j04xer_34">
      commonjs
     </code>
     and
     <code class="code" id="j04xer_35">
      commonjs2
     </code>
     , see the
     <a data-external="true" href="https://github.com/webpack/webpack/issues/1114" id="j04xer_36" rel="noopener noreferrer" style="color: red;" target="_blank">
      Webpack repository
     </a>
     .
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="javascript-libraries-and-node-js-files" id="javascript-libraries-and-node-js-files">
     JavaScript libraries and Node.js files
    </h2>
    <p id="j04xer_37">
     If you are creating a library for use in JavaScript or Node.js environments, and want to use a different module system, the instructions are slightly different.
    </p>
    <section class="chapter">
     <h3 data-toc="choose-the-target-module-system" id="choose-the-target-module-system">
      Choose the target module system
     </h3>
     <p id="j04xer_39">
      To select the target module system, set the
      <code class="code" id="j04xer_45">
       moduleKind
      </code>
      compiler option in the Gradle build script:
     </p>
     <div class="tabs" data-anchors="[j04xer_46,j04xer_47]" data-group="build-script" id="j04xer_40">
      <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="j04xer_46">
       <div class="code-block" data-lang="kotlin" data-title="Kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
        tasks.withType&lt;org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrLink&gt; {
    compilerOptions.moduleKind.set(org.jetbrains.kotlin.gradle.dsl.JsModuleKind.MODULE_COMMONJS)
}
       </div>
      </div>
      <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="j04xer_47">
       <div class="code-block" data-lang="groovy" data-title="Groovy" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
        compileKotlinJs.compilerOptions.moduleKind = org.jetbrains.kotlin.gradle.dsl.JsModuleKind.MODULE_COMMONJS
       </div>
      </div>
     </div>
     <p id="j04xer_41">
      The available values are:
      <code class="code" id="j04xer_50">
       umd
      </code>
      (default),
      <code class="code" id="j04xer_51">
       commonjs
      </code>
      ,
      <code class="code" id="j04xer_52">
       amd
      </code>
      ,
      <code class="code" id="j04xer_53">
       plain
      </code>
      .
     </p>
     <aside class="prompt" data-title="" data-type="note" id="j04xer_42">
      <p id="j04xer_54">
       This is different from adjusting
       <code class="code" id="j04xer_55">
        webpackTask.output.libraryTarget
       </code>
       . The library target changes the output
       <span class="emphasis" id="j04xer_56">
        generated by webpack
       </span>
       (after your code has already been compiled).
       <code class="code" id="j04xer_57">
        compilerOptions.moduleKind
       </code>
       changes the output generated
       <span class="emphasis" id="j04xer_58">
        by the Kotlin compiler
       </span>
       .
      </p>
     </aside>
     <p id="j04xer_43">
      In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      kotlin {
    js {
        useCommonJs()
        // ...
    }
}
     </div>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="jsmodule-annotation" id="jsmodule-annotation">
     @JsModule annotation
    </h2>
    <p id="j04xer_59">
     To tell Kotlin that an
     <code class="code" id="j04xer_67">
      external
     </code>
     class, package, function or property is a JavaScript module, you can use
     <code class="code" id="j04xer_68">
      @JsModule
     </code>
     annotation. Consider you have the following CommonJS module called "hello":
    </p>
    <div class="code-block" data-lang="javascript" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     module.exports.sayHello = function (name) { alert("Hello, " + name); }
    </div>
    <p id="j04xer_61">
     You should declare it like this in Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     @JsModule("hello")
external fun sayHello(name: String)
    </div>
    <section class="chapter">
     <h3 data-toc="apply-jsmodule-to-packages" id="apply-jsmodule-to-packages">
      Apply @JsModule to packages
     </h3>
     <p id="j04xer_69">
      Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an
      <span class="emphasis" id="j04xer_75">
       object
      </span>
      that has
      <span class="emphasis" id="j04xer_76">
       members
      </span>
      that are classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler can map imported JavaScript packages to Kotlin packages, using the following notation:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      @file:JsModule("extModule")

package ext.jspackage.name

external fun foo()

external class C
     </div>
     <p id="j04xer_71">
      Where the corresponding JavaScript module is declared like this:
     </p>
     <div class="code-block" data-lang="javascript" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      module.exports = {
  foo: { /* some code here */ },
  C: { /* some code here */ }
}
     </div>
     <p id="j04xer_73">
      Files marked with
      <code class="code" id="j04xer_77">
       @file:JsModule
      </code>
      annotation can't declare non-external members. The example below produces a compile-time error:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      @file:JsModule("extModule")

package ext.jspackage.name

external fun foo()

fun bar() = "!" + foo() + "!" // error here
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="import-deeper-package-hierarchies" id="import-deeper-package-hierarchies">
      Import deeper package hierarchies
     </h3>
     <p id="j04xer_78">
      In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new
      <code class="code" id="j04xer_85">
       .kt
      </code>
      file for each package you import.
     </p>
     <p id="j04xer_79">
      For example, let's make the example a bit more complicated:
     </p>
     <div class="code-block" data-lang="javascript" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      module.exports = {
  mylib: {
    pkg1: {
      foo: function () { /* some code here */ },
      bar: function () { /* some code here */ }
    },
    pkg2: {
      baz: function () { /* some code here */ }
    }
  }
}
     </div>
     <p id="j04xer_81">
      To import this module in Kotlin, you have to write two Kotlin source files:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      @file:JsModule("extModule")
@file:JsQualifier("mylib.pkg1")

package extlib.pkg1

external fun foo()

external fun bar()
     </div>
     <p id="j04xer_83">
      and
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      @file:JsModule("extModule")
@file:JsQualifier("mylib.pkg2")

package extlib.pkg2

external fun baz()
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="jsnonmodule-annotation" id="jsnonmodule-annotation">
      @JsNonModule annotation
     </h3>
     <p id="j04xer_86">
      When a declaration is marked as
      <code class="code" id="j04xer_90">
       @JsModule
      </code>
      , you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable
      <code class="code" id="j04xer_91">
       .js
      </code>
      files that you can copy to your project's static resources and include via a
      <code class="code" id="j04xer_92">
       &lt;script&gt;
      </code>
      tag. To tell Kotlin that it's okay to use a
      <code class="code" id="j04xer_93">
       @JsModule
      </code>
      declaration from a non-module environment, add the
      <code class="code" id="j04xer_94">
       @JsNonModule
      </code>
      annotation. For example, consider the following JavaScript code:
     </p>
     <div class="code-block" data-lang="javascript" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      function topLevelSayHello (name) { alert("Hello, " + name); }

if (module &amp;&amp; module.exports) {
  module.exports = topLevelSayHello;
}
     </div>
     <p id="j04xer_88">
      You could describe it from Kotlin as follows:
     </p>
     <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
      @JsModule("hello")
@JsNonModule
@JsName("topLevelSayHello")
external fun sayHello(name: String)
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="module-system-used-by-the-kotlin-standard-library" id="module-system-used-by-the-kotlin-standard-library">
      Module system used by the Kotlin Standard Library
     </h3>
     <p id="j04xer_95">
      Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. For most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on
      <code class="code" id="j04xer_96">
       kotlin-stdlib-js
      </code>
      , which is also available on NPM as the
      <a data-external="true" href="https://www.npmjs.com/package/kotlin" id="j04xer_97" rel="noopener noreferrer" style="color: red;" target="_blank">
       <code class="code" id="j04xer_98">
        kotlin
       </code>
      </a>
      package.
     </p>
    </section>
   </section>
   <div class="last-modified">
    19 April 2025
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </article>
 </body>
</html>
