<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Kotlin Documentation
  </title>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div style="text-align: center; margin-bottom: 1em;">
   <a href="toc.html" style="font-size: 24px; text-decoration: none;">
    Menu
   </a>
  </div>
  <article class="article" data-shortcut-switcher="inactive">
   <h1 data-toc="type-aliases" id="type-aliases.md">
    Type aliases
   </h1>
   <p id="-sc4epx_2">
    Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.
   </p>
   <p id="-sc4epx_3">
    It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:
   </p>
   <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
    typealias NodeSet = Set&lt;Network.Node&gt;

typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;
   </div>
   <p id="-sc4epx_5">
    You can provide different aliases for function types:
   </p>
   <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
    typealias MyHandler = (Int, String, Any) -&gt; Unit

typealias Predicate&lt;T&gt; = (T) -&gt; Boolean
   </div>
   <p id="-sc4epx_7">
    You can have new names for inner and nested classes:
   </p>
   <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
    class A {
    inner class Inner
}
class B {
    inner class Inner
}

typealias AInner = A.Inner
typealias BInner = B.Inner
   </div>
   <p id="-sc4epx_9">
    Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add
    <code class="code" id="-sc4epx_11">
     typealias Predicate&lt;T&gt;
    </code>
    and use
    <code class="code" id="-sc4epx_12">
     Predicate&lt;Int&gt;
    </code>
    in your code, the Kotlin compiler always expands it to
    <code class="code" id="-sc4epx_13">
     (Int) -&gt; Boolean
    </code>
    . Thus you can pass a variable of your type whenever a general function type is required and vice versa:
   </p>
   <div class="code-block" data-lang="kotlin" data-runnable="true" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
    typealias Predicate&lt;T&gt; = (T) -&gt; Boolean

fun foo(p: Predicate&lt;Int&gt;) = p(42)

fun main() {
    val f: (Int) -&gt; Boolean = { it &gt; 0 }
    println(foo(f)) // prints "true"

    val p: Predicate&lt;Int&gt; = { it &gt; 0 }
    println(listOf(1, -2).filter(p)) // prints "[1]"
}
   </div>
   <div class="last-modified">
    19 April 2025
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </article>
 </body>
</html>
