<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Kotlin Documentation
  </title>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div style="text-align: center; margin-bottom: 1em;">
   <a href="toc.html" style="font-size: 24px; text-decoration: none;">
    Menu
   </a>
  </div>
  <article class="article" data-shortcut-switcher="inactive">
   <h1 data-toc="mapping-strings-from-c" id="mapping-strings-from-c.md">
    Mapping strings from C â€“ tutorial
   </h1>
   <div class="micro-format" data-content='{"microFormat":["\u003cp id\u003d\"-480090_14\"\u003eThis is the final part of the \u003cb id\u003d\"-480090_16\"\u003eMapping Kotlin and C\u003c/b\u003e tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\u003c/p\u003e","\u003cp id\u003d\"-480090_15\"\u003e\u003cimg alt\u003d\"First step\" src\u003d\"images/icon-1-done.svg\" class\u003d\"inline-icon-\" title\u003d\"First step\" id\u003d\"-480090_17\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-primitive-data-types-from-c.html\" id\u003d\"-480090_18\" data-tooltip\u003d\"This is the first part of the Mapping Kotlin and C tutorial series.\"\u003eMapping primitive data types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Second step\" src\u003d\"images/icon-2-done.svg\" class\u003d\"inline-icon-\" title\u003d\"Second step\" id\u003d\"-480090_20\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-struct-union-types-from-c.html\" id\u003d\"-480090_21\" data-tooltip\u003d\"This is the second part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous step.\"\u003eMapping struct and union types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Third step\" src\u003d\"images/icon-3-done.svg\" class\u003d\"inline-icon-\" title\u003d\"Third step\" id\u003d\"-480090_23\" width\u003d\"20\" height\u003d\"20\"\u003e \u003ca href\u003d\"mapping-function-pointers-from-c.html\" id\u003d\"-480090_24\" data-tooltip\u003d\"This is the third part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you\u0027ve completed the previous steps.\"\u003eMapping function pointers\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\"Fourth step\" src\u003d\"images/icon-4.svg\" class\u003d\"inline-icon-\" title\u003d\"Fourth step\" id\u003d\"-480090_26\" width\u003d\"20\" height\u003d\"20\"\u003e \u003cb id\u003d\"-480090_27\"\u003eMapping strings from C\u003c/b\u003e\u003cbr\u003e\u003c/p\u003e"]}'>
   </div>
   <aside class="prompt" data-title="" data-type="warning" id="-480090_3">
    <p id="-480090_29">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="-480090_31" style="color: blue;">
      Experimental
     </a>
     . All Kotlin declarations generated by the cinterop tool from C libraries should have the
     <code class="code" id="-480090_32">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="-480090_30">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.
    </p>
   </aside>
   <p id="-480090_4">
    In the final part of the series, let's see how to deal with C strings in Kotlin/Native.
   </p>
   <p id="-480090_5">
    In this tutorial, you'll learn how to:
   </p>
   <ul class="list _bullet" id="-480090_6">
    <li class="list__item" id="-480090_33">
     <p id="-480090_36">
      <a data-tooltip="Let's try to use the API from Kotlin. Call the pass_string() function first:" href="#pass-kotlin-strings-to-c" id="-480090_37" style="color: blue;">
       Pass a Kotlin string to C
      </a>
     </p>
    </li>
    <li class="list__item" id="-480090_34">
     <p id="-480090_38">
      <a data-tooltip="Now take a returned char * from the return_string() function and turn it into a Kotlin string:" href="#read-c-strings-in-kotlin" id="-480090_39" style="color: blue;">
       Read a C string in Kotlin
      </a>
     </p>
    </li>
    <li class="list__item" id="-480090_35">
     <p id="-480090_40">
      <a data-tooltip="This time, use the copy_string() C function to write a C string to a given buffer. It takes two arguments: a pointer to the memory location where the string should be written and the allowed buffer size." href="#receive-c-string-bytes-from-kotlin" id="-480090_41" style="color: blue;">
       Receive C string bytes into a Kotlin string
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="working-with-c-strings" id="working-with-c-strings">
     Working with C strings
    </h2>
    <p id="-480090_42">
     C doesn't have a dedicated string type. Method signatures or documentation can help you identify whether a given
     <code class="code" id="-480090_47">
      char *
     </code>
     represents a C string in a particular context.
    </p>
    <p id="-480090_43">
     Strings in the C language are null-terminated, so a trailing zero character
     <code class="code" id="-480090_48">
      \0
     </code>
     is added to the end of a byte sequence to mark the end of a string. Usually,
     <a data-external="true" href="https://en.wikipedia.org/wiki/UTF-8" id="-480090_49" rel="noopener noreferrer" style="color: red;" target="_blank">
      UTF-8 encoded strings
     </a>
     are used. The UTF-8 encoding uses variable-width characters and is backward-compatible with
     <a data-external="true" href="https://en.wikipedia.org/wiki/ASCII" id="-480090_50" rel="noopener noreferrer" style="color: red;" target="_blank">
      ASCII
     </a>
     . Kotlin/Native uses UTF-8 character encoding by default.
    </p>
    <p id="-480090_44">
     To understand how strings are mapped between Kotlin and C, first create the library headers. In the
     <a data-tooltip="This is the first part of the Mapping Kotlin and C tutorial series." href="mapping-primitive-data-types-from-c.html" id="-480090_51" style="color: blue;">
      first part of the series
     </a>
     , you've already created a C library with the necessary files. For this step:
    </p>
    <ol class="list _decimal" id="-480090_45" type="1">
     <li class="list__item" id="-480090_52">
      <p id="-480090_54">
       Update your
       <code class="code" id="-480090_57">
        lib.h
       </code>
       file with the following function declarations that work with C strings:
      </p>
      <div class="code-block" data-lang="c" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       #ifndef LIB2_H_INCLUDED
#define LIB2_H_INCLUDED

void pass_string(char* str);
char* return_string();
int copy_string(char* str, int size);

#endif
      </div>
      <p id="-480090_56">
       This example shows common ways to pass or receive a string in the C language. Handle the return value of the
       <code class="code" id="-480090_58">
        return_string()
       </code>
       function carefully. Ensure you use the correct
       <code class="code" id="-480090_59">
        free()
       </code>
       function to release the returned
       <code class="code" id="-480090_60">
        char*
       </code>
       .
      </p>
     </li>
     <li class="list__item" id="-480090_53">
      <p id="-480090_61">
       Update the declarations in the
       <code class="code" id="-480090_63">
        interop.def
       </code>
       file after the
       <code class="code" id="-480090_64">
        ---
       </code>
       separator:
      </p>
      <div class="code-block" data-lang="c" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       ---

void pass_string(char* str) {
}

char* return_string() {
  return "C string";
}

int copy_string(char* str, int size) {
    *str++ = 'C';
    *str++ = ' ';
    *str++ = 'K';
    *str++ = '/';
    *str++ = 'N';
    *str++ = 0;
    return 0;
}
      </div>
     </li>
    </ol>
    <p id="-480090_46">
     The
     <code class="code" id="-480090_65">
      interop.def
     </code>
     file provides everything necessary to compile, run, or open the application in an IDE.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="-480090_66">
     Let's see how C string declarations are mapped into Kotlin/Native:
    </p>
    <ol class="list _decimal" id="-480090_67" type="1">
     <li class="list__item" id="-480090_70">
      <p id="-480090_72">
       In
       <code class="code" id="-480090_74">
        src/nativeMain/kotlin
       </code>
       , update your
       <code class="code" id="-480090_75">
        hello.kt
       </code>
       file from the
       <a data-tooltip="This is the third part of the Mapping Kotlin and C tutorial series. Before proceeding, make sure you've completed the previous steps." href="mapping-function-pointers-from-c.html" id="-480090_76" style="color: blue;">
        previous tutorial
       </a>
       with the following content:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       import interop.*
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    pass_string(/*fix me*/)
    val useMe = return_string()
    val useMe2 = copy_string(/*fix me*/)
}
      </div>
     </li>
     <li class="list__item" id="-480090_71">
      <p id="-480090_77">
       Use IntelliJ IDEA's
       <a data-external="true" href="https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_Declaration.html" id="-480090_79" rel="noopener noreferrer" style="color: red;" target="_blank">
        Go to declaration
       </a>
       command (
       <kbd class="keystroke" data-bypass="true" id="-480090_80">
        <span class="keystroke__value">
         Cmd + B
        </span>
       </kbd>
       /
       <kbd class="keystroke" data-bypass="true" id="-480090_81">
        <span class="keystroke__value">
         Ctrl + B
        </span>
       </kbd>
       ) to navigate to the following generated API for C functions:
      </p>
      <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
       fun pass_string(str: kotlinx.cinterop.CValuesRef&lt;kotlinx.cinterop.ByteVarOf&lt;kotlin.Byte&gt; /* from: kotlinx.cinterop.ByteVar */&gt;?)
fun return_string(): kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.ByteVarOf&lt;kotlin.Byte&gt; /* from: kotlinx.cinterop.ByteVar */&gt;?
fun copy_string(str: kotlinx.cinterop.CValuesRef&lt;kotlinx.cinterop.ByteVarOf&lt;kotlin.Byte&gt; /* from: kotlinx.cinterop.ByteVar */&gt;?, size: kotlin.Int): kotlin.Int
      </div>
     </li>
    </ol>
    <p id="-480090_68">
     These declarations are straightforward. In Kotlin, C
     <code class="code" id="-480090_82">
      char *
     </code>
     pointers are mapped into
     <code class="code" id="-480090_83">
      str: CValuesRef&lt;ByteVarOf&gt;?
     </code>
     for parameters and into
     <code class="code" id="-480090_84">
      CPointer&lt;ByteVarOf&gt;?
     </code>
     for return types. Kotlin represents the
     <code class="code" id="-480090_85">
      char
     </code>
     type as
     <code class="code" id="-480090_86">
      kotlin.Byte
     </code>
     , as it's usually an 8-bit signed value.
    </p>
    <p id="-480090_69">
     In the generated Kotlin declarations,
     <code class="code" id="-480090_87">
      str
     </code>
     is defined as
     <code class="code" id="-480090_88">
      CValuesRef&lt;ByteVarOf&lt;Byte&gt;&gt;?
     </code>
     . Since this type is nullable, you can pass
     <code class="code" id="-480090_89">
      null
     </code>
     as the argument value.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="pass-kotlin-strings-to-c" id="pass-kotlin-strings-to-c">
     Pass Kotlin strings to C
    </h2>
    <p id="-480090_90">
     Let's try to use the API from Kotlin. Call the
     <code class="code" id="-480090_93">
      pass_string()
     </code>
     function first:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.cstr

@OptIn(ExperimentalForeignApi::class)
fun passStringToC() {
    val str = "This is a Kotlin string"
    pass_string(str.cstr)
}
    </div>
    <p id="-480090_92">
     Passing a Kotlin string to C is straightforward, thanks to the
     <code class="code" id="-480090_94">
      String.cstr
     </code>
     <a data-tooltip="Kotlin supports extension properties much like it supports functions:" href="extensions.html#extension-properties" id="-480090_95" style="color: blue;">
      extension property
     </a>
     . There is also the
     <code class="code" id="-480090_96">
      String.wcstr
     </code>
     property for cases that involve UTF-16 characters.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="read-c-strings-in-kotlin" id="read-c-strings-in-kotlin">
     Read C strings in Kotlin
    </h2>
    <p id="-480090_97">
     Now take a returned
     <code class="code" id="-480090_102">
      char *
     </code>
     from the
     <code class="code" id="-480090_103">
      return_string()
     </code>
     function and turn it into a Kotlin string:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.toKString

@OptIn(ExperimentalForeignApi::class)
fun passStringToC() {
    val stringFromC = return_string()?.toKString()

    println("Returned from C: $stringFromC")
}
    </div>
    <p id="-480090_99">
     Here, the
     <code class="code" id="-480090_104">
      .toKString()
     </code>
     extension function converts a C string returned from the
     <code class="code" id="-480090_105">
      return_string()
     </code>
     function into a Kotlin string.
    </p>
    <p id="-480090_100">
     Kotlin provides several extension functions for converting C
     <code class="code" id="-480090_106">
      char *
     </code>
     strings into Kotlin strings, depending on the encoding:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     fun CPointer&lt;ByteVarOf&lt;Byte&gt;&gt;.toKString(): String // Standard function for UTF-8 strings
fun CPointer&lt;ByteVarOf&lt;Byte&gt;&gt;.toKStringFromUtf8(): String // Explicitly converts UTF-8 strings
fun CPointer&lt;ShortVarOf&lt;Short&gt;&gt;.toKStringFromUtf16(): String // Converts UTF-16 encoded strings
fun CPointer&lt;IntVarOf&lt;Int&gt;&gt;.toKStringFromUtf32(): String // Converts UTF-32 encoded strings
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="receive-c-string-bytes-from-kotlin" id="receive-c-string-bytes-from-kotlin">
     Receive C string bytes from Kotlin
    </h2>
    <p id="-480090_107">
     This time, use the
     <code class="code" id="-480090_111">
      copy_string()
     </code>
     C function to write a C string to a given buffer. It takes two arguments: a pointer to the memory location where the string should be written and the allowed buffer size.
    </p>
    <p id="-480090_108">
     The function should also return something to indicate if it has succeeded or failed. Let's assume
     <code class="code" id="-480090_112">
      0
     </code>
     means it succeeded, and the supplied buffer was big enough:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.addressOf
import kotlinx.cinterop.usePinned

@OptIn(ExperimentalForeignApi::class)
fun sendString() {
    val buf = ByteArray(255)
    buf.usePinned { pinned -&gt;
        if (copy_string(pinned.addressOf(0), buf.size - 1) != 0) {
            throw Error("Failed to read string from C")
        }
    }

    val copiedStringFromC = buf.decodeToString()
    println("Message from C: $copiedStringFromC")
}
    </div>
    <p id="-480090_110">
     Here, a native pointer is passed to the C function first. The
     <code class="code" id="-480090_113">
      .usePinned
     </code>
     extension function temporarily pins the native memory address of the byte array. The C function fills in the byte array with data. Another extension function,
     <code class="code" id="-480090_114">
      ByteArray.decodeToString()
     </code>
     , turns the byte array into a Kotlin string, assuming UTF-8 encoding.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="update-kotlin-code" id="update-kotlin-code">
     Update Kotlin code
    </h2>
    <p id="-480090_115">
     Now that you've learned how to use C declarations in Kotlin code, try to use them in your project. The code in the final
     <code class="code" id="-480090_119">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     import interop.*
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println("Hello Kotlin/Native!")

    val str = "This is a Kotlin string"
    pass_string(str.cstr)

    val useMe = return_string()?.toKString() ?: error("null pointer returned")
    println(useMe)

    val copyFromC = ByteArray(255).usePinned { pinned -&gt;
        val useMe2 = copy_string(pinned.addressOf(0), pinned.get().size - 1)
        if (useMe2 != 0) throw Error("Failed to read a string from C")
        pinned.get().decodeToString()
    }

    println(copyFromC)
}
    </div>
    <p id="-480090_117">
     To verify that everything works as expected, run the
     <code class="code" id="-480090_120">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="-480090_121" style="color: blue;">
      in your IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash" style="font-family: monospace; background: #f4f4f4; padding: 10px; overflow-x: auto; margin: 1em 0; display: block;">
     ./gradlew runDebugExecutableNative
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="what-s-next" id="what-s-next">
     What's next
    </h2>
    <p id="-480090_122">
     Learn more in the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="-480090_123" style="color: blue;">
      Interoperability with C
     </a>
     documentation that covers more advanced scenarios.
    </p>
   </section>
   <div class="last-modified">
    19 April 2025
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </article>
 </body>
</html>
