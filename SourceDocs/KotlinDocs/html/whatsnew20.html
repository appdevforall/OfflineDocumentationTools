<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-18T20:47:09.086768956"><title>What's new in Kotlin 2.0.0 | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"ide-support","level":0,"title":"IDE support","anchor":"#ide-support"},{"id":"kotlin-k2-compiler","level":0,"title":"Kotlin K2 compiler","anchor":"#kotlin-k2-compiler"},{"id":"current-k2-compiler-limitations","level":1,"title":"Current K2 compiler limitations","anchor":"#current-k2-compiler-limitations"},{"id":"smart-cast-improvements","level":1,"title":"Smart cast improvements","anchor":"#smart-cast-improvements"},{"id":"kotlin-multiplatform-improvements","level":1,"title":"Kotlin Multiplatform improvements","anchor":"#kotlin-multiplatform-improvements"},{"id":"compiler-plugins-support","level":1,"title":"Compiler plugins support","anchor":"#compiler-plugins-support"},{"id":"experimental-kotlin-power-assert-compiler-plugin","level":1,"title":"Experimental Kotlin Power-assert compiler plugin","anchor":"#experimental-kotlin-power-assert-compiler-plugin"},{"id":"how-to-enable-the-kotlin-k2-compiler","level":1,"title":"How to enable the Kotlin K2 compiler","anchor":"#how-to-enable-the-kotlin-k2-compiler"},{"id":"try-the-kotlin-k2-compiler-in-kotlin-playground","level":1,"title":"Try the Kotlin K2 compiler in Kotlin Playground","anchor":"#try-the-kotlin-k2-compiler-in-kotlin-playground"},{"id":"support-in-ides","level":1,"title":"Support in IDEs","anchor":"#support-in-ides"},{"id":"leave-your-feedback-on-the-new-k2-compiler","level":1,"title":"Leave your feedback on the new K2 compiler","anchor":"#leave-your-feedback-on-the-new-k2-compiler"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"generation-of-lambda-functions-using-invokedynamic","level":1,"title":"Generation of lambda functions using invokedynamic","anchor":"#generation-of-lambda-functions-using-invokedynamic"},{"id":"the-kotlinx-metadata-jvm-library-is-stable","level":1,"title":"The kotlinx-metadata-jvm library is Stable","anchor":"#the-kotlinx-metadata-jvm-library-is-stable"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"monitoring-gc-performance-with-signposts-on-apple-platforms","level":1,"title":"Monitoring GC performance with signposts on Apple platforms","anchor":"#monitoring-gc-performance-with-signposts-on-apple-platforms"},{"id":"resolving-conflicts-with-objective-c-methods","level":1,"title":"Resolving conflicts with Objective-C methods","anchor":"#resolving-conflicts-with-objective-c-methods"},{"id":"changed-log-level-for-compiler-arguments","level":1,"title":"Changed log level for compiler arguments","anchor":"#changed-log-level-for-compiler-arguments"},{"id":"explicitly-added-standard-library-and-platform-dependencies-to-kotlin-native","level":1,"title":"Explicitly added standard library and platform dependencies to Kotlin/Native","anchor":"#explicitly-added-standard-library-and-platform-dependencies-to-kotlin-native"},{"id":"tasks-error-in-gradle-configuration-cache","level":1,"title":"Tasks error in Gradle configuration cache","anchor":"#tasks-error-in-gradle-configuration-cache"},{"id":"kotlin-wasm","level":0,"title":"Kotlin/Wasm","anchor":"#kotlin-wasm"},{"id":"optimized-production-builds-by-default-using-binaryen","level":1,"title":"Optimized production builds by default using Binaryen","anchor":"#optimized-production-builds-by-default-using-binaryen"},{"id":"support-for-named-export","level":1,"title":"Support for named export","anchor":"#support-for-named-export"},{"id":"support-for-unsigned-primitive-types-in-functions-with-jsexport","level":1,"title":"Support for unsigned primitive types in functions with @JsExport","anchor":"#support-for-unsigned-primitive-types-in-functions-with-jsexport"},{"id":"generation-of-typescript-declaration-files-in-kotlin-wasm","level":1,"title":"Generation of TypeScript declaration files in Kotlin/Wasm","anchor":"#generation-of-typescript-declaration-files-in-kotlin-wasm"},{"id":"support-for-catching-javascript-exceptions","level":1,"title":"Support for catching JavaScript exceptions","anchor":"#support-for-catching-javascript-exceptions"},{"id":"new-exception-handling-proposal-is-now-supported-as-an-option","level":1,"title":"New exception handling proposal is now supported as an option","anchor":"#new-exception-handling-proposal-is-now-supported-as-an-option"},{"id":"the-withwasm-function-is-split-into-js-and-wasi-variants","level":1,"title":"The withWasm() function is split into JS and WASI variants","anchor":"#the-withwasm-function-is-split-into-js-and-wasi-variants"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"new-compilation-target","level":1,"title":"New compilation target","anchor":"#new-compilation-target"},{"id":"suspend-functions-as-es2015-generators","level":1,"title":"Suspend functions as ES2015 generators","anchor":"#suspend-functions-as-es2015-generators"},{"id":"passing-arguments-to-the-main-function","level":1,"title":"Passing arguments to the main function","anchor":"#passing-arguments-to-the-main-function"},{"id":"per-file-compilation-for-kotlin-js-projects","level":1,"title":"Per-file compilation for Kotlin/JS projects","anchor":"#per-file-compilation-for-kotlin-js-projects"},{"id":"improved-collection-interoperability","level":1,"title":"Improved collection interoperability","anchor":"#improved-collection-interoperability"},{"id":"support-for-createinstance","level":1,"title":"Support for createInstance()","anchor":"#support-for-createinstance"},{"id":"support-for-type-safe-plain-javascript-objects","level":1,"title":"Support for type-safe plain JavaScript objects","anchor":"#support-for-type-safe-plain-javascript-objects"},{"id":"support-for-npm-package-manager","level":1,"title":"Support for npm package manager","anchor":"#support-for-npm-package-manager"},{"id":"changes-to-compilation-tasks","level":1,"title":"Changes to compilation tasks","anchor":"#changes-to-compilation-tasks"},{"id":"discontinuing-legacy-kotlin-js-jar-artifacts","level":1,"title":"Discontinuing legacy Kotlin/JS JAR artifacts","anchor":"#discontinuing-legacy-kotlin-js-jar-artifacts"},{"id":"gradle-improvements","level":0,"title":"Gradle improvements","anchor":"#gradle-improvements"},{"id":"new-gradle-dsl-for-compiler-options-in-multiplatform-projects","level":1,"title":"New Gradle DSL for compiler options in multiplatform projects","anchor":"#new-gradle-dsl-for-compiler-options-in-multiplatform-projects"},{"id":"new-compose-compiler-gradle-plugin","level":1,"title":"New Compose compiler Gradle plugin","anchor":"#new-compose-compiler-gradle-plugin"},{"id":"new-attribute-to-distinguish-jvm-and-android-published-libraries","level":1,"title":"New attribute to distinguish JVM and Android-published libraries","anchor":"#new-attribute-to-distinguish-jvm-and-android-published-libraries"},{"id":"improved-gradle-dependency-handling-for-cinteropprocess-in-kotlin-native","level":1,"title":"Improved Gradle dependency handling for CInteropProcess in Kotlin/Native","anchor":"#improved-gradle-dependency-handling-for-cinteropprocess-in-kotlin-native"},{"id":"visibility-changes-in-gradle","level":1,"title":"Visibility changes in Gradle","anchor":"#visibility-changes-in-gradle"},{"id":"new-directory-for-kotlin-data-in-gradle-projects","level":1,"title":"New directory for Kotlin data in Gradle projects","anchor":"#new-directory-for-kotlin-data-in-gradle-projects"},{"id":"kotlin-native-compiler-downloaded-when-needed","level":1,"title":"Kotlin/Native compiler downloaded when needed","anchor":"#kotlin-native-compiler-downloaded-when-needed"},{"id":"deprecated-old-ways-of-defining-compiler-options","level":1,"title":"Deprecated old ways of defining compiler options","anchor":"#deprecated-old-ways-of-defining-compiler-options"},{"id":"bumped-minimum-supported-agp-version","level":1,"title":"Bumped minimum supported AGP version","anchor":"#bumped-minimum-supported-agp-version"},{"id":"new-gradle-property-for-trying-the-latest-language-version","level":1,"title":"New Gradle property for trying the latest language version","anchor":"#new-gradle-property-for-trying-the-latest-language-version"},{"id":"new-json-output-format-for-build-reports","level":1,"title":"New JSON output format for build reports","anchor":"#new-json-output-format-for-build-reports"},{"id":"kapt-configurations-inherit-annotation-processors-from-superconfigurations","level":1,"title":"kapt configurations inherit annotation processors from superconfigurations","anchor":"#kapt-configurations-inherit-annotation-processors-from-superconfigurations"},{"id":"kotlin-gradle-plugin-no-longer-uses-deprecated-gradle-conventions","level":1,"title":"Kotlin Gradle plugin no longer uses deprecated Gradle conventions","anchor":"#kotlin-gradle-plugin-no-longer-uses-deprecated-gradle-conventions"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"stable-replacement-of-the-enum-class-values-generic-function","level":1,"title":"Stable replacement of the enum class values generic function","anchor":"#stable-replacement-of-the-enum-class-values-generic-function"},{"id":"stable-autocloseable-interface","level":1,"title":"Stable AutoCloseable interface","anchor":"#stable-autocloseable-interface"},{"id":"common-protected-property-abstractmutablelist-modcount","level":1,"title":"Common protected property AbstractMutableList.modCount","anchor":"#common-protected-property-abstractmutablelist-modcount"},{"id":"common-protected-function-abstractmutablelist-removerange","level":1,"title":"Common protected function AbstractMutableList.removeRange","anchor":"#common-protected-function-abstractmutablelist-removerange"},{"id":"common-string-tochararray-destination-function","level":1,"title":"Common String.toCharArray(destination) function","anchor":"#common-string-tochararray-destination-function"},{"id":"install-kotlin-2-0-0","level":0,"title":"Install Kotlin 2.0.0","anchor":"#install-kotlin-2-0-0"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 2.0.0 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/whatsnew20.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="What's new in Kotlin 2.0.0 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/whatsnew20.html#webpage",
    "url": "writerside-documentation/whatsnew20.html",
    "name": "What's new in Kotlin 2.0.0 | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="whatsnew20" data-main-title="What's new in Kotlin 2.0.0" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew20" id="whatsnew20.md">What's new in Kotlin 2.0.0</h1><p id="z7an5p3_2"><span class="emphasis" id="z7an5p3_16"><a href="releases.html#release-details" id="z7an5p3_17" data-tooltip="The following table lists details of the latest Kotlin releases:">Released: May 21, 2024</a></span></p><p id="z7an5p3_3">The Kotlin 2.0.0 release is out and the <a href="#kotlin-k2-compiler" id="z7an5p3_18" data-tooltip="The road to the K2 compiler has been a long one, but now the JetBrains team is finally ready to announce its stabilization. In Kotlin 2.0.0, the new Kotlin K2 compiler is used by default and it is Stable for all target platforms: JVM, Native, Wasm, and JS. The new compiler brings…">new Kotlin K2 compiler</a> is Stable! Additionally, here are some other highlights:</p><ul class="list _bullet" id="z7an5p3_4"><li class="list__item" id="z7an5p3_19"><p id="z7an5p3_30"><a href="#new-compose-compiler-gradle-plugin" id="z7an5p3_31" data-tooltip="The Jetpack Compose compiler, which translates composables into Kotlin code, has now been merged into the Kotlin repository. This will help transition Compose projects to Kotlin 2.0.0, as the Compose compiler will always ship simultaneously with Kotlin. This also bumps the Compose…">New Compose compiler Gradle plugin</a></p></li><li class="list__item" id="z7an5p3_20"><p id="z7an5p3_32"><a href="#generation-of-lambda-functions-using-invokedynamic" id="z7an5p3_33" data-tooltip="Kotlin 2.0.0 introduces a new default method for generating lambda functions using invokedynamic. This change reduces the binary sizes of applications compared to the traditional anonymous class generation.">Generation of lambda functions using invokedynamic</a></p></li><li class="list__item" id="z7an5p3_21"><p id="z7an5p3_34"><a href="#the-kotlinx-metadata-jvm-library-is-stable" id="z7an5p3_35" data-tooltip="In Kotlin 2.0.0, the kotlinx-metadata-jvm library became Stable. Now that the library has changed to the kotlin package and coordinates, you can find it as kotlin-metadata-jvm (without the &quot;x&quot;).">The kotlinx-metadata-jvm library is now Stable</a></p></li><li class="list__item" id="z7an5p3_22"><p id="z7an5p3_36"><a href="#monitoring-gc-performance-with-signposts-on-apple-platforms" id="z7an5p3_37" data-tooltip="Previously, it was only possible to monitor the performance of Kotlin/Native's garbage collector (GC) by looking into logs. However, these logs were not integrated with Xcode Instruments, a popular toolkit for investigating issues with iOS apps' performance.">Monitoring GC performance in Kotlin/Native with signposts on Apple platforms</a></p></li><li class="list__item" id="z7an5p3_23"><p id="z7an5p3_38"><a href="#resolving-conflicts-with-objective-c-methods" id="z7an5p3_39" data-tooltip="Objective-C methods can have different names, but the same number and types of parameters. For example, locationManager:didEnterRegion: and locationManager:didExitRegion:. In Kotlin, these methods have the same signature, so an attempt to use them triggers a conflicting overloads…">Resolving conflicts in Kotlin/Native with Objective-C methods</a></p></li><li class="list__item" id="z7an5p3_24"><p id="z7an5p3_40"><a href="#support-for-named-export" id="z7an5p3_41" data-tooltip="Previously, all exported declarations from Kotlin/Wasm were imported into JavaScript using default export:">Support for named export in Kotlin/Wasm</a></p></li><li class="list__item" id="z7an5p3_25"><p id="z7an5p3_42"><a href="#support-for-unsigned-primitive-types-in-functions-with-jsexport" id="z7an5p3_43" data-tooltip="Starting from Kotlin 2.0.0, you can use unsigned primitive types inside external declarations and functions with the @JsExport annotation that makes Kotlin/Wasm functions available in JavaScript code.">Support for unsigned primitive types in functions with @JsExport in Kotlin/Wasm</a></p></li><li class="list__item" id="z7an5p3_26"><p id="z7an5p3_44"><a href="#optimized-production-builds-by-default-using-binaryen" id="z7an5p3_45" data-tooltip="The Kotlin/Wasm toolchain now applies the Binaryen tool during production compilation to all projects, as opposed to the previous manual setup approach. By our estimations, it should improve runtime performance and reduce the binary size for your project.">Optimize production builds by default using Binaryen</a></p></li><li class="list__item" id="z7an5p3_27"><p id="z7an5p3_46"><a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects" id="z7an5p3_47" data-tooltip="This feature is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">New Gradle DSL for compiler options in multiplatform projects</a></p></li><li class="list__item" id="z7an5p3_28"><p id="z7an5p3_48"><a href="#stable-replacement-of-the-enum-class-values-generic-function" id="z7an5p3_49" data-tooltip="In Kotlin 2.0.0, the enumEntries&lt;T&gt;() function becomes Stable. The enumEntries&lt;T&gt;() function is a replacement for the generic enumValues&lt;T&gt;() function. The new function returns a list of all enum entries for the given enum type T. The entries property for enum…">Stable replacement of the enum class values generic function</a></p></li><li class="list__item" id="z7an5p3_29"><p id="z7an5p3_50"><a href="#stable-autocloseable-interface" id="z7an5p3_51" data-tooltip="In Kotlin 2.0.0, the common AutoCloseable interface becomes Stable. It allows you to easily close resources and includes a couple of useful functions:">Stable AutoCloseable interface</a></p></li></ul><p id="z7an5p3_5">Kotlin 2.0 is a huge milestone for the JetBrains team. This release was the center of KotlinConf 2024. Check out the opening keynote, where we announced exciting updates and addressed the recent work on the Kotlin language:</p><div class="video-player" id="z7an5p3_6"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/Ar73Axsz2YA?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><section class="chapter"><h2 id="ide-support" data-toc="ide-support">IDE support</h2><p id="z7an5p3_52">The Kotlin plugins that support Kotlin 2.0.0 are bundled in the latest IntelliJ IDEA and Android Studio. You don't need to update the Kotlin plugin in your IDE. All you need to do is to <a href="releases.html#update-to-a-new-kotlin-version" id="z7an5p3_54" data-tooltip="To upgrade your project to a new release, you need to update your build script file. For example, to update to Kotlin 2.1.20, change the version of the Kotlin Gradle plugin in your build.gradle(.kts) file:">change the Kotlin version</a> to Kotlin 2.0.0 in your build scripts.</p><ul class="list _bullet" id="z7an5p3_53"><li class="list__item" id="z7an5p3_55"><p id="z7an5p3_57">For details about IntelliJ IDEA's support for the Kotlin K2 compiler, see <a href="#support-in-ides" id="z7an5p3_58" data-tooltip="By default, IntelliJ IDEA and Android Studio still use the previous compiler for code analysis, code completion, highlighting, and other IDE-related features. To get the full Kotlin 2.0 experience in your IDE, enable K2 mode.">Support in IDEs</a>.</p></li><li class="list__item" id="z7an5p3_56"><p id="z7an5p3_59">For more details about IntelliJ IDEA's support for Kotlin, see <a href="releases.html#ide-support" id="z7an5p3_60" data-tooltip="Even with the release of the K2 compiler, IntelliJ IDEA and Android Studio still use the previous compiler by default for code analysis, code completion, highlighting, and other IDE-related features.">Kotlin releases</a>.</p></li></ul></section><section class="chapter"><h2 id="kotlin-k2-compiler" data-toc="kotlin-k2-compiler">Kotlin K2 compiler</h2><p id="z7an5p3_61">The road to the K2 compiler has been a long one, but now the JetBrains team is finally ready to announce its stabilization. In Kotlin 2.0.0, the new Kotlin K2 compiler is used by default and it is <a href="components-stability.html" id="z7an5p3_76" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a> for all target platforms: JVM, Native, Wasm, and JS. The new compiler brings major performance improvements, speeds up new language feature development, unifies all platforms that Kotlin supports, and provides a better architecture for multiplatform projects.</p><p id="z7an5p3_62">The JetBrains team has ensured the quality of the new compiler by successfully compiling 10 million lines of code from selected user and internal projects. 18,000 developers were involved in the stabilization process, testing the new K2 compiler across a total of 80,000 projects and reporting any problems they found.</p><p id="z7an5p3_63">To help make the migration process to the new compiler as smooth as possible, we've created a <a href="k2-compiler-migration-guide.html" id="z7an5p3_77" data-tooltip="As the Kotlin language and ecosystem have continued to evolve, so has the Kotlin compiler. The first step was the introduction of the new JVM and JS IR (Intermediate Representation) backends that share logic, simplifying code generation for targets on different platforms. Now, the…">K2 compiler migration guide</a>. This guide explains the many benefits of the compiler, highlights any changes you might encounter, and describes how to roll back to the previous version if necessary.</p><p id="z7an5p3_64">In a <a href="https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks-and-how-to-measure-them-on-your-projects/" id="z7an5p3_78" data-external="true" rel="noopener noreferrer" target="_blank">blog post</a>, we explored the performance of the K2 compiler in different projects. Check it out if you'd like to see real data on how the K2 compiler performs and find instructions on how to collect performance benchmarks from your own projects.</p><p id="z7an5p3_65">You can also watch this talk from KotlinConf 2024, where Michail Zarečenskij, the lead language designer, discusses the feature evolution in Kotlin and the K2 compiler:</p><div class="video-player" id="z7an5p3_66"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/tAGJ5zJXJ7w?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><section class="chapter"><h3 id="current-k2-compiler-limitations" data-toc="current-k2-compiler-limitations">Current K2 compiler limitations</h3><p id="z7an5p3_79">Enabling K2 in your Gradle project comes with certain limitations that can affect projects using Gradle versions below 8.3 in the following cases:</p><ul class="list _bullet" id="z7an5p3_80"><li class="list__item" id="z7an5p3_83"><p id="z7an5p3_87">Compilation of source code from <code class="code" id="z7an5p3_88">buildSrc</code>.</p></li><li class="list__item" id="z7an5p3_84"><p id="z7an5p3_89">Compilation of Gradle plugins in included builds.</p></li><li class="list__item" id="z7an5p3_85"><p id="z7an5p3_90">Compilation of other Gradle plugins if they are used in projects with Gradle versions below 8.3.</p></li><li class="list__item" id="z7an5p3_86"><p id="z7an5p3_91">Building Gradle plugin dependencies.</p></li></ul><p id="z7an5p3_81">If you encounter any of the problems mentioned above, you can take the following steps to address them:</p><ul class="list _bullet" id="z7an5p3_82"><li class="list__item" id="z7an5p3_92"><p id="z7an5p3_94">Set the language version for <code class="code" id="z7an5p3_98">buildSrc</code>, any Gradle plugins, and their dependencies:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        languageVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9)
        apiVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9)
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="z7an5p3_96"><p id="z7an5p3_99">If you configure language and API versions for specific tasks, these values will override the values set by the <code class="code" id="z7an5p3_100">compilerOptions</code> extension. In this case, language and API versions should not be higher than 1.9.</p></aside><p id="z7an5p3_97"></p></li><li class="list__item" id="z7an5p3_93"><p id="z7an5p3_101">Update the Gradle version in your project to 8.3 or later.</p></li></ul></section><section class="chapter"><h3 id="smart-cast-improvements" data-toc="smart-cast-improvements">Smart cast improvements</h3><p id="z7an5p3_102">The Kotlin compiler can automatically cast an object to a type in specific cases, saving you the trouble of having to explicitly cast it yourself. This is called <a href="typecasts.html#smart-casts" id="z7an5p3_111" data-tooltip="In most cases, you don't need to use explicit cast operators because the compiler automatically casts objects for you. This is called smart-casting. The compiler tracks the type checks and explicit casts for immutable values and inserts implicit (safe) casts automatically when…">smart casting</a>. The Kotlin K2 compiler now performs smart casts in even more scenarios than before.</p><p id="z7an5p3_103">In Kotlin 2.0.0, we've made improvements related to smart casts in the following areas:</p><ul class="list _bullet" id="z7an5p3_104"><li class="list__item" id="z7an5p3_112"><p id="z7an5p3_118"><a href="#local-variables-and-further-scopes" id="z7an5p3_119" data-tooltip="Previously, if a variable was evaluated as not null within an if condition, the variable would be smart-cast. Information about this variable would then be shared further within the scope of the if block.">Local variables and further scopes</a></p></li><li class="list__item" id="z7an5p3_113"><p id="z7an5p3_120"><a href="#type-checks-with-logical-or-operator" id="z7an5p3_121" data-tooltip="In Kotlin 2.0.0, if you combine type checks for objects with an or operator (||), a smart cast is made to their closest common supertype. Before this change, a smart cast was always made to the Any type.">Type checks with logical <code class="code" id="z7an5p3_122">or</code> operator</a></p></li><li class="list__item" id="z7an5p3_114"><p id="z7an5p3_123"><a href="#inline-functions" id="z7an5p3_124" data-tooltip="In Kotlin 2.0.0, the K2 compiler treats inline functions differently, allowing it to determine in combination with other compiler analyses whether it's safe to smart-cast.">Inline functions</a></p></li><li class="list__item" id="z7an5p3_115"><p id="z7an5p3_125"><a href="#properties-with-function-types" id="z7an5p3_126" data-tooltip="In previous versions of Kotlin, there was a bug that meant that class properties with a function type weren't smart-cast. We fixed this behavior in Kotlin 2.0.0 and the K2 compiler. For example:">Properties with function types</a></p></li><li class="list__item" id="z7an5p3_116"><p id="z7an5p3_127"><a href="#exception-handling" id="z7an5p3_128" data-tooltip="In Kotlin 2.0.0, we've made improvements to exception handling so that smart cast information can be passed on to catch and finally blocks. This change makes your code safer as the compiler keeps track of whether your object has a nullable type. For example:">Exception handling</a></p></li><li class="list__item" id="z7an5p3_117"><p id="z7an5p3_129"><a href="#increment-and-decrement-operators" id="z7an5p3_130" data-tooltip="Prior to Kotlin 2.0.0, the compiler didn't understand that the type of an object can change after using an increment or decrement operator. As the compiler couldn't accurately track the object type, your code could lead to unresolved reference errors. In Kotlin 2.0.0, this has been…">Increment and decrement operators</a></p></li></ul><section class="chapter"><h4 id="local-variables-and-further-scopes" data-toc="local-variables-and-further-scopes">Local variables and further scopes</h4><p id="z7an5p3_131">Previously, if a variable was evaluated as not <code class="code" id="z7an5p3_136">null</code> within an <code class="code" id="z7an5p3_137">if</code> condition, the variable would be smart-cast. Information about this variable would then be shared further within the scope of the <code class="code" id="z7an5p3_138">if</code> block.</p><p id="z7an5p3_132">However, if you declared the variable <span class="control" id="z7an5p3_139">outside</span> the <code class="code" id="z7an5p3_140">if</code> condition, no information about the variable would be available within the <code class="code" id="z7an5p3_141">if</code> condition, so it couldn't be smart-cast. This behavior was also seen with <code class="code" id="z7an5p3_142">when</code> expressions and <code class="code" id="z7an5p3_143">while</code> loops.</p><p id="z7an5p3_133">From Kotlin 2.0.0, if you declare a variable before using it in your <code class="code" id="z7an5p3_144">if</code>, <code class="code" id="z7an5p3_145">when</code>, or <code class="code" id="z7an5p3_146">while</code> condition, then any information collected by the compiler about the variable will be accessible in the corresponding block for smart-casting.</p><p id="z7an5p3_134">This can be useful when you want to do things like extract boolean conditions into variables. Then, you can give the variable a meaningful name, which will improve your code readability and make it possible to reuse the variable later in your code. For example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-local-variables">
class Cat {
    fun purr() {
        println(&quot;Purr purr&quot;)
    }
}

fun petAnimal(animal: Any) {
    val isCat = animal is Cat
    if (isCat) {
        // In Kotlin 2.0.0, the compiler can access
        // information about isCat, so it knows that
        // animal was smart-cast to the type Cat.
        // Therefore, the purr() function can be called.
        // In Kotlin 1.9.20, the compiler doesn't know
        // about the smart cast, so calling the purr()
        // function triggers an error.
        animal.purr()
    }
}

fun main() {
    val kitty = Cat()
    petAnimal(kitty)
    // Purr purr
}
</div></section><section class="chapter"><h4 id="type-checks-with-logical-or-operator" data-toc="type-checks-with-logical-or-operator">Type checks with logical or operator</h4><p id="z7an5p3_147">In Kotlin 2.0.0, if you combine type checks for objects with an <code class="code" id="z7an5p3_151">or</code> operator (<code class="code" id="z7an5p3_152">||</code>), a smart cast is made to their closest common supertype. Before this change, a smart cast was always made to the <code class="code" id="z7an5p3_153">Any</code> type.</p><p id="z7an5p3_148">In this case, you still had to manually check the object type afterward before you could access any of its properties or call its functions. For example:</p><div class="code-block" data-lang="kotlin">
interface Status {
    fun signal() {}
}

interface Ok : Status
interface Postponed : Status
interface Declined : Status

fun signalCheck(signalStatus: Any) {
    if (signalStatus is Postponed || signalStatus is Declined) {
        // signalStatus is smart-cast to a common supertype Status
        signalStatus.signal()
        // Prior to Kotlin 2.0.0, signalStatus is smart cast 
        // to type Any, so calling the signal() function triggered an
        // Unresolved reference error. The signal() function can only 
        // be called successfully after another type check:

        // check(signalStatus is Status)
        // signalStatus.signal()
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="z7an5p3_150"><p id="z7an5p3_154">The common supertype is an <span class="control" id="z7an5p3_155">approximation</span> of a union type. <a href="https://en.wikipedia.org/wiki/Union_type" id="z7an5p3_156" data-external="true" rel="noopener noreferrer" target="_blank">Union types</a> are not supported in Kotlin.</p></aside></section><section class="chapter"><h4 id="inline-functions" data-toc="inline-functions">Inline functions</h4><p id="z7an5p3_157">In Kotlin 2.0.0, the K2 compiler treats inline functions differently, allowing it to determine in combination with other compiler analyses whether it's safe to smart-cast.</p><p id="z7an5p3_158">Specifically, inline functions are now treated as having an implicit <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.contracts/-contract-builder/calls-in-place.html" id="z7an5p3_161" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_162">callsInPlace</code></a> contract. This means that any lambda functions passed to an inline function are called in place. Since lambda functions are called in place, the compiler knows that a lambda function can't leak references to any variables contained within its function body.</p><p id="z7an5p3_159">The compiler uses this knowledge along with other compiler analyses to decide whether it's safe to smart-cast any of the captured variables. For example:</p><div class="code-block" data-lang="kotlin">
interface Processor {
    fun process()
}

inline fun inlineAction(f: () -&gt; Unit) = f()

fun nextProcessor(): Processor? = null

fun runProcessor(): Processor? {
    var processor: Processor? = null
    inlineAction {
        // In Kotlin 2.0.0, the compiler knows that processor 
        // is a local variable, and inlineAction() is an inline function, so 
        // references to processor can't be leaked. Therefore, it's safe 
        // to smart-cast processor.

        // If processor isn't null, processor is smart-cast
        if (processor != null) {
            // The compiler knows that processor isn't null, so no safe call 
            // is needed
            processor.process()

            // In Kotlin 1.9.20, you have to perform a safe call:
            // processor?.process()
        }

        processor = nextProcessor()
    }

    return processor
}
</div></section><section class="chapter"><h4 id="properties-with-function-types" data-toc="properties-with-function-types">Properties with function types</h4><p id="z7an5p3_163">In previous versions of Kotlin, there was a bug that meant that class properties with a function type weren't smart-cast. We fixed this behavior in Kotlin 2.0.0 and the K2 compiler. For example:</p><div class="code-block" data-lang="kotlin">
class Holder(val provider: (() -&gt; Unit)?) {
    fun process() {
        // In Kotlin 2.0.0, if provider isn't null, then
        // provider is smart-cast
        if (provider != null) {
            // The compiler knows that provider isn't null
            provider()

            // In 1.9.20, the compiler doesn't know that provider isn't 
            // null, so it triggers an error:
            // Reference has a nullable type '(() -&gt; Unit)?', use explicit '?.invoke()' to make a function-like call instead
        }
    }
}
</div><p id="z7an5p3_165">This change also applies if you overload your <code class="code" id="z7an5p3_167">invoke</code> operator. For example:</p><div class="code-block" data-lang="kotlin">
interface Provider {
    operator fun invoke()
}

interface Processor : () -&gt; String

class Holder(val provider: Provider?, val processor: Processor?) {
    fun process() {
        if (provider != null) {
            provider()
            // In 1.9.20, the compiler triggers an error: 
            // Reference has a nullable type 'Provider?' use explicit '?.invoke()' to make a function-like call instead
        }
    }
}
</div></section><section class="chapter"><h4 id="exception-handling" data-toc="exception-handling">Exception handling</h4><p id="z7an5p3_168">In Kotlin 2.0.0, we've made improvements to exception handling so that smart cast information can be passed on to <code class="code" id="z7an5p3_170">catch</code> and <code class="code" id="z7an5p3_171">finally</code> blocks. This change makes your code safer as the compiler keeps track of whether your object has a nullable type. For example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-exception-handling">
//sampleStart
fun testString() {
    var stringInput: String? = null
    // stringInput is smart-cast to String type
    stringInput = &quot;&quot;
    try {
        // The compiler knows that stringInput isn't null
        println(stringInput.length)
        // 0

        // The compiler rejects previous smart cast information for 
        // stringInput. Now stringInput has the String? type.
        stringInput = null

        // Trigger an exception
        if (2 &gt; 1) throw Exception()
        stringInput = &quot;&quot;
    } catch (exception: Exception) {
        // In Kotlin 2.0.0, the compiler knows stringInput 
        // can be null, so stringInput stays nullable.
        println(stringInput?.length)
        // null

        // In Kotlin 1.9.20, the compiler says that a safe call isn't
        // needed, but this is incorrect.
    }
}

//sampleEnd
fun main() {
    testString()
}
</div></section><section class="chapter"><h4 id="increment-and-decrement-operators" data-toc="increment-and-decrement-operators">Increment and decrement operators</h4><p id="z7an5p3_172">Prior to Kotlin 2.0.0, the compiler didn't understand that the type of an object can change after using an increment or decrement operator. As the compiler couldn't accurately track the object type, your code could lead to unresolved reference errors. In Kotlin 2.0.0, this has been fixed:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-increment-decrement-operators">
interface Rho {
    operator fun inc(): Sigma = TODO()
}

interface Sigma : Rho {
    fun sigma() = Unit
}

interface Tau {
    fun tau() = Unit
}

fun main(input: Rho) {
    var unknownObject: Rho = input

    // Check if unknownObject inherits from the Tau interface
    // Note, it's possible that unknownObject inherits from both
    // Rho and Tau interfaces.
    if (unknownObject is Tau) {

        // Use the overloaded inc() operator from interface Rho.
        // In Kotlin 2.0.0, the type of unknownObject is smart-cast to
        // Sigma.
        ++unknownObject

        // In Kotlin 2.0.0, the compiler knows unknownObject has type
        // Sigma, so the sigma() function can be called successfully.
        unknownObject.sigma()

        // In Kotlin 1.9.20, the compiler doesn't perform a smart cast
        // when inc() is called so the compiler still thinks that 
        // unknownObject has type Tau. Calling the sigma() function 
        // throws a compile-time error.
        
        // In Kotlin 2.0.0, the compiler knows unknownObject has type
        // Sigma, so calling the tau() function throws a compile-time 
        // error.
        unknownObject.tau()
        // Unresolved reference 'tau'

        // In Kotlin 1.9.20, since the compiler mistakenly thinks that 
        // unknownObject has type Tau, the tau() function can be called,
        // but it throws a ClassCastException.
    }
}
</div></section></section><section class="chapter"><h3 id="kotlin-multiplatform-improvements" data-toc="kotlin-multiplatform-improvements">Kotlin Multiplatform improvements</h3><p id="z7an5p3_174">In Kotlin 2.0.0, we've made improvements in the K2 compiler related to Kotlin Multiplatform in the following areas:</p><ul class="list _bullet" id="z7an5p3_175"><li class="list__item" id="z7an5p3_178"><p id="z7an5p3_180"><a href="#separation-of-common-and-platform-sources-during-compilation" id="z7an5p3_181" data-tooltip="Previously, the design of the Kotlin compiler prevented it from keeping common and platform source sets separate at compile time. As a consequence, common code could access platform code, which resulted in different behavior between platforms. In addition, some compiler settings and…">Separation of common and platform sources during compilation</a></p></li><li class="list__item" id="z7an5p3_179"><p id="z7an5p3_182"><a href="#different-visibility-levels-of-expected-and-actual-declarations" id="z7an5p3_183" data-tooltip="Before Kotlin 2.0.0, if you used expected and actual declarations in your Kotlin Multiplatform project, they had to have the same visibility level. Kotlin 2.0.0 now also supports different visibility levels but only if the actual declaration is more permissive than the expected…">Different visibility levels of expected and actual declarations</a></p></li></ul><section class="chapter"><h4 id="separation-of-common-and-platform-sources-during-compilation" data-toc="separation-of-common-and-platform-sources-during-compilation">Separation of common and platform sources during compilation</h4><p id="z7an5p3_184">Previously, the design of the Kotlin compiler prevented it from keeping common and platform source sets separate at compile time. As a consequence, common code could access platform code, which resulted in different behavior between platforms. In addition, some compiler settings and dependencies from common code used to leak into platform code.</p><p id="z7an5p3_185">In Kotlin 2.0.0, our implementation of the new Kotlin K2 compiler included a redesign of the compilation scheme to ensure strict separation between common and platform source sets. This change is most noticeable when you use <a href="multiplatform-expect-actual.html#expected-and-actual-functions" id="z7an5p3_195" data-tooltip="You can define an Identity type and a factory function buildIdentity(), which is declared in the common source set and implemented differently in platform source sets:">expected and actual functions</a>. Previously, it was possible for a function call in your common code to resolve to a function in platform code. For example:</p><div class="table-wrapper"><table class="wide" id="z7an5p3_186"><thead><tr class="ijRowHead" id="z7an5p3_196"><th id="z7an5p3_198"><p>Common code</p></th><th id="z7an5p3_199"><p>Platform code</p></th></tr></thead><tbody><tr id="z7an5p3_197"><td id="z7an5p3_200"><div class="code-block" data-lang="kotlin">
fun foo(x: Any) = println(&quot;common foo&quot;)

fun exampleFunction() {
    foo(42)
}
</div></td><td id="z7an5p3_201"><div class="code-block" data-lang="kotlin">
// JVM
fun foo(x: Int) = println(&quot;platform foo&quot;)

// JavaScript
// There is no foo() function overload
// on the JavaScript platform
</div></td></tr></tbody></table></div><p id="z7an5p3_187">In this example, the common code has different behavior depending on which platform it is run on:</p><ul class="list _bullet" id="z7an5p3_188"><li class="list__item" id="z7an5p3_204"><p id="z7an5p3_206">On the JVM platform, calling the <code class="code" id="z7an5p3_207">foo()</code> function in the common code results in the <code class="code" id="z7an5p3_208">foo()</code> function from the platform code being called as <code class="code" id="z7an5p3_209">platform foo</code>.</p></li><li class="list__item" id="z7an5p3_205"><p id="z7an5p3_210">On the JavaScript platform, calling the <code class="code" id="z7an5p3_211">foo()</code> function in the common code results in the <code class="code" id="z7an5p3_212">foo()</code> function from the common code being called as <code class="code" id="z7an5p3_213">common foo</code>, as there is no such function available in the platform code.</p></li></ul><p id="z7an5p3_189">In Kotlin 2.0.0, common code doesn't have access to platform code, so both platforms successfully resolve the <code class="code" id="z7an5p3_214">foo()</code> function to the <code class="code" id="z7an5p3_215">foo()</code> function in the common code: <code class="code" id="z7an5p3_216">common foo</code>.</p><p id="z7an5p3_190">In addition to the improved consistency of behavior across platforms, we also worked hard to fix cases where there was conflicting behavior between IntelliJ IDEA or Android Studio and the compiler. For instance, when you used <a href="multiplatform-expect-actual.html#expected-and-actual-classes" id="z7an5p3_217" data-tooltip="Expected and actual classes are in Beta. They are almost stable, but migration steps may be required in the future. We'll do our best to minimize any further changes for you to make.">expected and actual classes</a>, the following would happen:</p><div class="table-wrapper"><table class="wide" id="z7an5p3_191"><thead><tr class="ijRowHead" id="z7an5p3_218"><th id="z7an5p3_220"><p>Common code</p></th><th id="z7an5p3_221"><p>Platform code</p></th></tr></thead><tbody><tr id="z7an5p3_219"><td id="z7an5p3_222"><div class="code-block" data-lang="kotlin">
expect class Identity {
    fun confirmIdentity(): String
}

fun common() {
    // Before 2.0.0,
    // it triggers an IDE-only error
    Identity().confirmIdentity()
    // RESOLUTION_TO_CLASSIFIER : Expected class
    // Identity has no default constructor.
}
</div></td><td id="z7an5p3_223"><div class="code-block" data-lang="kotlin">
actual class Identity {
    actual fun confirmIdentity() = &quot;expect class fun: jvm&quot;
}
</div></td></tr></tbody></table></div><p id="z7an5p3_192">In this example, the expected class <code class="code" id="z7an5p3_226">Identity</code> has no default constructor, so it can't be called successfully in common code. Previously, an error was only reported by the IDE, but the code still compiled successfully on the JVM. However, now the compiler correctly reports an error:</p><div class="code-block" data-lang="none">
Expected class 'expect class Identity : Any' does not have default constructor
</div><section class="chapter"><h5 id="when-resolution-behavior-doesn-t-change" data-toc="when-resolution-behavior-doesn-t-change">When resolution behavior doesn't change</h5><p id="z7an5p3_227">We're still in the process of migrating to the new compilation scheme, so the resolution behavior is still the same when you call functions that aren't within the same source set. You'll notice this difference mainly when you use overloads from a multiplatform library in your common code.</p><p id="z7an5p3_228">Suppose you have a library, which has two <code class="code" id="z7an5p3_236">whichFun()</code> functions with different signatures:</p><div class="code-block" data-lang="kotlin">
// Example library

// MODULE: common
fun whichFun(x: Any) = println(&quot;common function&quot;)

// MODULE: JVM
fun whichFun(x: Int) = println(&quot;platform function&quot;)
</div><p id="z7an5p3_230">If you call the <code class="code" id="z7an5p3_237">whichFun()</code> function in your common code, the function that has the most relevant argument type in the library is resolved:</p><div class="code-block" data-lang="kotlin">
// A project that uses the example library for the JVM target

// MODULE: common
fun main() {
    whichFun(2)
    // platform function
}
</div><p id="z7an5p3_232">In comparison, if you declare the overloads for <code class="code" id="z7an5p3_238">whichFun()</code> within the same source set, the function from the common code will be resolved because your code doesn't have access to the platform-specific version:</p><div class="code-block" data-lang="kotlin">
// Example library isn't used

// MODULE: common
fun whichFun(x: Any) = println(&quot;common function&quot;)

fun main() {
    whichFun(2)
    // common function
}

// MODULE: JVM
fun whichFun(x: Int) = println(&quot;platform function&quot;)
</div><p id="z7an5p3_234">Similar to multiplatform libraries, since the <code class="code" id="z7an5p3_239">commonTest</code> module is in a separate source set, it also still has access to platform-specific code. Therefore, the resolution of calls to functions in the <code class="code" id="z7an5p3_240">commonTest</code> module exhibits the same behavior as in the old compilation scheme.</p><p id="z7an5p3_235">In the future, these remaining cases will be more consistent with the new compilation scheme.</p></section></section><section class="chapter"><h4 id="different-visibility-levels-of-expected-and-actual-declarations" data-toc="different-visibility-levels-of-expected-and-actual-declarations">Different visibility levels of expected and actual declarations</h4><p id="z7an5p3_241">Before Kotlin 2.0.0, if you used <a href="multiplatform-expect-actual.html" id="z7an5p3_245" data-tooltip="Expected and actual declarations allow you to access platform-specific APIs from Kotlin Multiplatform modules. You can provide platform-agnostic APIs in the common code.">expected and actual declarations</a> in your Kotlin Multiplatform project, they had to have the same <a href="visibility-modifiers.html" id="z7an5p3_246" data-tooltip="Classes, objects, interfaces, constructors, and functions, as well as properties and their setters, can have visibility modifiers. Getters always have the same visibility as their properties.">visibility level</a>. Kotlin 2.0.0 now also supports different visibility levels but <span class="control" id="z7an5p3_247">only</span> if the actual declaration is <span class="emphasis" id="z7an5p3_248">more</span> permissive than the expected declaration. For example:</p><div class="code-block" data-lang="kotlin">
expect internal class Attribute // Visibility is internal
actual class Attribute          // Visibility is public by default,
                                // which is more permissive
</div><p id="z7an5p3_243">Similarly, if you are using a <a href="type-aliases.html" id="z7an5p3_249" data-tooltip="Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.">type alias</a> in your actual declaration, the visibility of the <span class="control" id="z7an5p3_250">underlying type</span> should be the same or more permissive than the expected declaration. For example:</p><div class="code-block" data-lang="kotlin">
expect internal class Attribute                 // Visibility is internal
internal actual typealias Attribute = Expanded

class Expanded                                  // Visibility is public by default,
                                                // which is more permissive
</div></section></section><section class="chapter"><h3 id="compiler-plugins-support" data-toc="compiler-plugins-support">Compiler plugins support</h3><p id="z7an5p3_251">Currently, the Kotlin K2 compiler supports the following Kotlin compiler plugins:</p><ul class="list _bullet" id="z7an5p3_252"><li class="list__item" id="z7an5p3_256"><p id="z7an5p3_267"><a href="all-open-plugin.html" id="z7an5p3_268" data-tooltip="Kotlin has classes and their members final by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be open. The all-open compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with…"><code class="code" id="z7an5p3_269">all-open</code></a></p></li><li class="list__item" id="z7an5p3_257"><p id="z7an5p3_270"><a href="https://github.com/Kotlin/kotlinx-atomicfu" id="z7an5p3_271" data-external="true" rel="noopener noreferrer" target="_blank">AtomicFU</a></p></li><li class="list__item" id="z7an5p3_258"><p id="z7an5p3_272"><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/jvm-abi-gen" id="z7an5p3_273" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_274">jvm-abi-gen</code></a></p></li><li class="list__item" id="z7an5p3_259"><p id="z7an5p3_275"><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/js-plain-objects" id="z7an5p3_276" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_277">js-plain-objects</code></a></p></li><li class="list__item" id="z7an5p3_260"><p id="z7an5p3_278"><a href="whatsnew1920.html#preview-kapt-compiler-plugin-with-k2" id="z7an5p3_279" data-tooltip="Support for K2 in the kapt compiler plugin is Experimental. Opt-in is required (see details below), and you should use it only for evaluation purposes.">kapt</a></p></li><li class="list__item" id="z7an5p3_261"><p id="z7an5p3_280"><a href="lombok.html" id="z7an5p3_281" data-tooltip="The Lombok compiler plugin is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Lombok</a></p></li><li class="list__item" id="z7an5p3_262"><p id="z7an5p3_282"><a href="no-arg-plugin.html" id="z7an5p3_283" data-tooltip="The no-arg compiler plugin generates an additional zero-argument constructor for classes with a specific annotation."><code class="code" id="z7an5p3_284">no-arg</code></a></p></li><li class="list__item" id="z7an5p3_263"><p id="z7an5p3_285"><a href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.plugin.parcelize" id="z7an5p3_286" data-external="true" rel="noopener noreferrer" target="_blank">Parcelize</a></p></li><li class="list__item" id="z7an5p3_264"><p id="z7an5p3_287"><a href="sam-with-receiver-plugin.html" id="z7an5p3_288" data-tooltip="The sam-with-receiver compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM…">SAM with receiver</a></p></li><li class="list__item" id="z7an5p3_265"><p id="z7an5p3_289"><a href="serialization.html" id="z7an5p3_290" data-tooltip="Serialization is the process of converting data used by an application to a format that can be transferred over a network or stored in a database or a file. In turn, deserialization is the opposite process of reading data from an external source and converting it into a runtime…">serialization</a></p></li><li class="list__item" id="z7an5p3_266"><p id="z7an5p3_291"><a href="power-assert.html" id="z7an5p3_292" data-tooltip="The Power-assert compiler plugin is Experimental. It may be changed at any time. Use it only for evaluation purposes. We would appreciate your feedback in YouTrack.">Power-assert</a></p></li></ul><p id="z7an5p3_253">In addition, the Kotlin K2 compiler supports:</p><ul class="list _bullet" id="z7an5p3_254"><li class="list__item" id="z7an5p3_293"><p id="z7an5p3_295">The <a href="https://developer.android.com/jetpack/compose" id="z7an5p3_296" data-external="true" rel="noopener noreferrer" target="_blank">Jetpack Compose</a> compiler plugin 2.0.0, which was <a href="https://android-developers.googleblog.com/2024/04/jetpack-compose-compiler-moving-to-kotlin-repository.html" id="z7an5p3_297" data-external="true" rel="noopener noreferrer" target="_blank">moved into the Kotlin repository</a>.</p></li><li class="list__item" id="z7an5p3_294"><p id="z7an5p3_298">The <a href="ksp-overview.html" id="z7an5p3_299" data-tooltip="Kotlin Symbol Processing (KSP) is an API that you can use to develop lightweight compiler plugins. KSP provides a simplified compiler plugin API that leverages the power of Kotlin while keeping the learning curve at a minimum. Compared to kapt, annotation processors that use KSP can…">Kotlin Symbol Processing (KSP) plugin</a> since <a href="https://android-developers.googleblog.com/2023/12/ksp2-preview-kotlin-k2-standalone.html" id="z7an5p3_300" data-external="true" rel="noopener noreferrer" target="_blank">KSP2</a>.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="z7an5p3_255"><p id="z7an5p3_301">If you use any additional compiler plugins, check their documentation to see if they are compatible with K2.</p></aside></section><section class="chapter"><h3 id="experimental-kotlin-power-assert-compiler-plugin" data-toc="experimental-kotlin-power-assert-compiler-plugin">Experimental Kotlin Power-assert compiler plugin</h3><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_302"><p id="z7an5p3_309">The Kotlin Power-assert plugin is <a href="components-stability.html#stability-levels-explained" id="z7an5p3_310" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. It may be changed at any time.</p></aside><p id="z7an5p3_303">Kotlin 2.0.0 introduces an experimental Power-assert compiler plugin. This plugin improves the experience of writing tests by including contextual information in failure messages, making debugging easier and more efficient.</p><p id="z7an5p3_304">Developers often need to use complex assertion libraries to write effective tests. The Power-assert plugin simplifies this process by automatically generating failure messages that include intermediate values of the assertion expression. This helps developers quickly understand why a test failed.</p><p id="z7an5p3_305">When an assertion fails in a test, the improved error message shows the values of all variables and sub-expressions within the assertion, making it clear which part of the condition caused the failure. This is particularly useful for complex assertions where multiple conditions are checked.</p><p id="z7an5p3_306">To enable the plugin in your project, configure it in your <code class="code" id="z7an5p3_311">build.gradle(.kts)</code> file:</p><div class="tabs" id="z7an5p3_307" data-group="build-script" data-anchors="[z7an5p3_312,z7an5p3_313]"><div class="tabs__content" data-gtm="tab" id="z7an5p3_312" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
plugins {
    kotlin(&quot;multiplatform&quot;) version &quot;2.0.0&quot;
    kotlin(&quot;plugin.power-assert&quot;) version &quot;2.0.0&quot;
}

powerAssert {
    functions = listOf(&quot;kotlin.assert&quot;, &quot;kotlin.test.assertTrue&quot;)
}
</div></div><div class="tabs__content" data-gtm="tab" id="z7an5p3_313" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.0.0'
    id 'org.jetbrains.kotlin.plugin.power-assert' version '2.0.0'
}

powerAssert {
    functions = [&quot;kotlin.assert&quot;, &quot;kotlin.test.assertTrue&quot;]
}
</div></div></div><p id="z7an5p3_308">Learn more about the <a href="power-assert.html" id="z7an5p3_316" data-tooltip="The Power-assert compiler plugin is Experimental. It may be changed at any time. Use it only for evaluation purposes. We would appreciate your feedback in YouTrack.">Kotlin Power-assert plugin in the documentation</a>.</p></section><section class="chapter"><h3 id="how-to-enable-the-kotlin-k2-compiler" data-toc="how-to-enable-the-kotlin-k2-compiler">How to enable the Kotlin K2 compiler</h3><p id="z7an5p3_317">Starting with Kotlin 2.0.0, the Kotlin K2 compiler is enabled by default. No additional actions are required.</p></section><section class="chapter"><h3 id="try-the-kotlin-k2-compiler-in-kotlin-playground" data-toc="try-the-kotlin-k2-compiler-in-kotlin-playground">Try the Kotlin K2 compiler in Kotlin Playground</h3><p id="z7an5p3_318">Kotlin Playground supports the 2.0.0 release. <a href="https://pl.kotl.in/czuoQprce" id="z7an5p3_319" data-external="true" rel="noopener noreferrer" target="_blank">Check it out!</a></p></section><section class="chapter"><h3 id="support-in-ides" data-toc="support-in-ides">Support in IDEs</h3><p id="z7an5p3_320">By default, IntelliJ IDEA and Android Studio still use the previous compiler for code analysis, code completion, highlighting, and other IDE-related features. To get the full Kotlin 2.0 experience in your IDE, enable K2 mode.</p><p id="z7an5p3_321">In your IDE, go to <span class="control" id="z7an5p3_325">Settings</span> | <span class="control" id="z7an5p3_326">Languages &amp; Frameworks</span> | <span class="control" id="z7an5p3_327">Kotlin</span> and select the <span class="control" id="z7an5p3_328">Enable K2 mode</span> option. The IDE will analyze your code using its K2 mode.</p><figure id="z7an5p3_322"><img alt="Enable K2 mode" src="images/k2-mode.png" title="Enable K2 mode" width="200" height="57"></figure><p id="z7an5p3_323">After enabling K2 mode, you may notice differences in IDE analysis due to changes in compiler behavior. Learn how the new K2 compiler differs from the previous one in our <a href="k2-compiler-migration-guide.html" id="z7an5p3_329" data-tooltip="As the Kotlin language and ecosystem have continued to evolve, so has the Kotlin compiler. The first step was the introduction of the new JVM and JS IR (Intermediate Representation) backends that share logic, simplifying code generation for targets on different platforms. Now, the…">migration guide</a>.</p><ul class="list _bullet" id="z7an5p3_324"><li class="list__item" id="z7an5p3_330"><p id="z7an5p3_332">Learn more about K2 mode in <a href="https://blog.jetbrains.com/idea/2024/11/k2-mode-becomes-stable/" id="z7an5p3_333" data-external="true" rel="noopener noreferrer" target="_blank">our blog</a>.</p></li><li class="list__item" id="z7an5p3_331"><p id="z7an5p3_334">We are actively collecting feedback about K2 mode, so please share your thoughts in our <a href="https://kotlinlang.slack.com/archives/C0B8H786P" id="z7an5p3_335" data-external="true" rel="noopener noreferrer" target="_blank">public Slack channel</a>.</p></li></ul></section><section class="chapter"><h3 id="leave-your-feedback-on-the-new-k2-compiler" data-toc="leave-your-feedback-on-the-new-k2-compiler">Leave your feedback on the new K2 compiler</h3><p id="z7an5p3_336">We would appreciate any feedback you may have!</p><ul class="list _bullet" id="z7an5p3_337"><li class="list__item" id="z7an5p3_338"><p id="z7an5p3_340">Report any problems you face with the new K2 compiler in <a href="https://kotl.in/issue" id="z7an5p3_341" data-external="true" rel="noopener noreferrer" target="_blank">our issue tracker</a>.</p></li><li class="list__item" id="z7an5p3_339"><p id="z7an5p3_342"><a href="https://www.jetbrains.com/help/idea/settings-usage-statistics.html" id="z7an5p3_343" data-external="true" rel="noopener noreferrer" target="_blank">Enable the &quot;Send usage statistics&quot; option</a> to allow JetBrains to collect anonymous data about K2 usage.</p></li></ul></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="z7an5p3_344">Starting with version 2.0.0, the compiler can generate classes containing Java 22 bytecode. This version also brings the following changes:</p><ul class="list _bullet" id="z7an5p3_345"><li class="list__item" id="z7an5p3_348"><p id="z7an5p3_350"><a href="#generation-of-lambda-functions-using-invokedynamic" id="z7an5p3_351" data-tooltip="Kotlin 2.0.0 introduces a new default method for generating lambda functions using invokedynamic. This change reduces the binary sizes of applications compared to the traditional anonymous class generation.">Generation of lambda functions using invokedynamic</a></p></li><li class="list__item" id="z7an5p3_349"><p id="z7an5p3_352"><a href="#the-kotlinx-metadata-jvm-library-is-stable" id="z7an5p3_353" data-tooltip="In Kotlin 2.0.0, the kotlinx-metadata-jvm library became Stable. Now that the library has changed to the kotlin package and coordinates, you can find it as kotlin-metadata-jvm (without the &quot;x&quot;).">The kotlinx-metadata-jvm library is now Stable</a></p></li></ul><section class="chapter"><h3 id="generation-of-lambda-functions-using-invokedynamic" data-toc="generation-of-lambda-functions-using-invokedynamic">Generation of lambda functions using invokedynamic</h3><p id="z7an5p3_354">Kotlin 2.0.0 introduces a new default method for generating lambda functions using <code class="code" id="z7an5p3_361">invokedynamic</code>. This change reduces the binary sizes of applications compared to the traditional anonymous class generation.</p><p id="z7an5p3_355">Since the first version, Kotlin has generated lambdas as anonymous classes. However, starting from <a href="whatsnew15.html#lambdas-via-invokedynamic" id="z7an5p3_362" data-tooltip="Compiling plain Kotlin lambdas into invokedynamic is Experimental. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate hearing your feedback on it in YouTrack.">Kotlin 1.5.0</a>, the option for <code class="code" id="z7an5p3_363">invokedynamic</code> generation has been available by using the <code class="code" id="z7an5p3_364">-Xlambdas=indy</code> compiler option. In Kotlin 2.0.0, <code class="code" id="z7an5p3_365">invokedynamic</code> has become the default method for lambda generation. This method produces lighter binaries and aligns Kotlin with JVM optimizations, ensuring applications benefit from ongoing and future improvements in JVM performance.</p><p id="z7an5p3_356">Currently, it has three limitations compared to ordinary lambda compilation:</p><ul class="list _bullet" id="z7an5p3_357"><li class="list__item" id="z7an5p3_366"><p id="z7an5p3_369">A lambda compiled into <code class="code" id="z7an5p3_370">invokedynamic</code> is not serializable.</p></li><li class="list__item" id="z7an5p3_367"><p id="z7an5p3_371">Experimental <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.jvm/reflect.html" id="z7an5p3_372" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_374">reflect()</code></a> API does not support lambdas generated by <code class="code" id="z7an5p3_373">invokedynamic</code>.</p></li><li class="list__item" id="z7an5p3_368"><p id="z7an5p3_375">Calling <code class="code" id="z7an5p3_376">.toString()</code> on such a lambda produces a less readable string representation:</p></li></ul><div class="code-block" data-lang="kotlin">
fun main() {
    println({})

    // With Kotlin 1.9.24 and reflection, returns
    // () -&gt; kotlin.Unit
    
    // With Kotlin 2.0.0, returns
    // FileKt$$Lambda$13/0x00007f88a0004608@506e1b77
}
</div><p id="z7an5p3_359">To retain the legacy behavior of generating lambda functions, you can either:</p><ul class="list _bullet" id="z7an5p3_360"><li class="list__item" id="z7an5p3_377"><p id="z7an5p3_379">Annotate specific lambdas with <code class="code" id="z7an5p3_380">@JvmSerializableLambda</code>.</p></li><li class="list__item" id="z7an5p3_378"><p id="z7an5p3_381">Use the compiler option <code class="code" id="z7an5p3_382">-Xlambdas=class</code> to generate all lambdas in a module using the legacy method.</p></li></ul></section><section class="chapter"><h3 id="the-kotlinx-metadata-jvm-library-is-stable" data-toc="the-kotlinx-metadata-jvm-library-is-stable">The kotlinx-metadata-jvm library is Stable</h3><p id="z7an5p3_383">In Kotlin 2.0.0, the <code class="code" id="z7an5p3_386">kotlinx-metadata-jvm</code> library became <a href="components-stability.html#stability-levels-explained" id="z7an5p3_387" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Stable</a>. Now that the library has changed to the <code class="code" id="z7an5p3_388">kotlin</code> package and coordinates, you can find it as <code class="code" id="z7an5p3_389">kotlin-metadata-jvm</code> (without the &quot;x&quot;).</p><p id="z7an5p3_384">Previously, the <code class="code" id="z7an5p3_390">kotlinx-metadata-jvm</code> library had its own publishing scheme and version. Now, we will build and publish the <code class="code" id="z7an5p3_391">kotlin-metadata-jvm</code> updates as part of the Kotlin release cycle, with the same backward compatibility guarantees as the Kotlin standard library.</p><p id="z7an5p3_385">The <code class="code" id="z7an5p3_392">kotlin-metadata-jvm</code> library provides an API to read and modify metadata of binary files generated by the Kotlin/JVM compiler.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="z7an5p3_393">This version brings the following changes:</p><ul class="list _bullet" id="z7an5p3_394"><li class="list__item" id="z7an5p3_400"><p id="z7an5p3_405"><a href="#monitoring-gc-performance-with-signposts-on-apple-platforms" id="z7an5p3_406" data-tooltip="Previously, it was only possible to monitor the performance of Kotlin/Native's garbage collector (GC) by looking into logs. However, these logs were not integrated with Xcode Instruments, a popular toolkit for investigating issues with iOS apps' performance.">Monitoring GC performance with signposts</a></p></li><li class="list__item" id="z7an5p3_401"><p id="z7an5p3_407"><a href="#resolving-conflicts-with-objective-c-methods" id="z7an5p3_408" data-tooltip="Objective-C methods can have different names, but the same number and types of parameters. For example, locationManager:didEnterRegion: and locationManager:didExitRegion:. In Kotlin, these methods have the same signature, so an attempt to use them triggers a conflicting overloads…">Resolving conflicts with Objective-C methods</a></p></li><li class="list__item" id="z7an5p3_402"><p id="z7an5p3_409"><a href="#changed-log-level-for-compiler-arguments" id="z7an5p3_410" data-tooltip="In this release, the log level for compiler arguments in Kotlin/Native Gradle tasks, such as compile, link, and cinterop, has changed from info to debug.">Changed log level for compiler arguments in Kotlin/Native</a></p></li><li class="list__item" id="z7an5p3_403"><p id="z7an5p3_411"><a href="#explicitly-added-standard-library-and-platform-dependencies-to-kotlin-native" id="z7an5p3_412" data-tooltip="Previously, the Kotlin/Native compiler resolved standard library and platform dependencies implicitly, which caused inconsistencies in the way the Kotlin Gradle plugin worked across Kotlin targets.">Explicitly added standard library and platform dependencies to Kotlin/Native</a></p></li><li class="list__item" id="z7an5p3_404"><p id="z7an5p3_413"><a href="#tasks-error-in-gradle-configuration-cache" id="z7an5p3_414" data-tooltip="Since Kotlin 2.0.0, you may encounter a configuration cache error with messages indicating: invocation of Task.project at execution time is unsupported.">Tasks error in Gradle configuration cache</a></p></li></ul><section class="chapter"><h3 id="monitoring-gc-performance-with-signposts-on-apple-platforms" data-toc="monitoring-gc-performance-with-signposts-on-apple-platforms">Monitoring GC performance with signposts on Apple platforms</h3><p id="z7an5p3_415">Previously, it was only possible to monitor the performance of Kotlin/Native's garbage collector (GC) by looking into logs. However, these logs were not integrated with Xcode Instruments, a popular toolkit for investigating issues with iOS apps' performance.</p><p id="z7an5p3_416">Since Kotlin 2.0.0, GC reports pauses with signposts that are available in Instruments. Signposts allow for custom logging within your app, so now, when debugging iOS app performance, you can check if a GC pause corresponds to the application freeze.</p><p id="z7an5p3_417">Learn more about GC performance analysis in the <a href="native-memory-manager.html#monitor-gc-performance" id="z7an5p3_418" data-tooltip="To monitor the GC performance, you can look through its logs and diagnose issues. To enable logging, set the following compiler option in your Gradle build script:">documentation</a>.</p></section><section class="chapter"><h3 id="resolving-conflicts-with-objective-c-methods" data-toc="resolving-conflicts-with-objective-c-methods">Resolving conflicts with Objective-C methods</h3><p id="z7an5p3_419">Objective-C methods can have different names, but the same number and types of parameters. For example, <a href="https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423560-locationmanager?language=objc" id="z7an5p3_423" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_425">locationManager:didEnterRegion:</code></a> and <a href="https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423630-locationmanager?language=objc" id="z7an5p3_424" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_426">locationManager:didExitRegion:</code></a>. In Kotlin, these methods have the same signature, so an attempt to use them triggers a conflicting overloads error.</p><p id="z7an5p3_420">Previously, you had to manually suppress conflicting overloads to avoid this compilation error. To improve Kotlin interoperability with Objective-C, the Kotlin 2.0.0 introduces the new <code class="code" id="z7an5p3_427">@ObjCSignatureOverride</code> annotation.</p><p id="z7an5p3_421">The annotation instructs the Kotlin compiler to ignore conflicting overloads, in case several functions with the same argument types but different argument names are inherited from the Objective-C class.</p><p id="z7an5p3_422">Applying this annotation is also safer than general error suppression. This annotation can only be used in the case of overriding Objective-C methods, which are supported and tested, while general suppression may hide important errors and lead to silently broken code.</p></section><section class="chapter"><h3 id="changed-log-level-for-compiler-arguments" data-toc="changed-log-level-for-compiler-arguments">Changed log level for compiler arguments</h3><p id="z7an5p3_428">In this release, the log level for compiler arguments in Kotlin/Native Gradle tasks, such as <code class="code" id="z7an5p3_430">compile</code>, <code class="code" id="z7an5p3_431">link</code>, and <code class="code" id="z7an5p3_432">cinterop</code>, has changed from <code class="code" id="z7an5p3_433">info</code> to <code class="code" id="z7an5p3_434">debug</code>.</p><p id="z7an5p3_429">With <code class="code" id="z7an5p3_435">debug</code> as its default value, the log level is consistent with other Gradle compilation tasks and provides detailed debugging information, including all compiler arguments.</p></section><section class="chapter"><h3 id="explicitly-added-standard-library-and-platform-dependencies-to-kotlin-native" data-toc="explicitly-added-standard-library-and-platform-dependencies-to-kotlin-native">Explicitly added standard library and platform dependencies to Kotlin/Native</h3><p id="z7an5p3_436">Previously, the Kotlin/Native compiler resolved standard library and platform dependencies implicitly, which caused inconsistencies in the way the Kotlin Gradle plugin worked across Kotlin targets.</p><p id="z7an5p3_437">Now, each Kotlin/Native Gradle compilation explicitly includes standard library and platform dependencies in its compile-time library path via the <code class="code" id="z7an5p3_438">compileDependencyFiles</code> <a href="multiplatform-dsl-reference.html#compilation-parameters" id="z7an5p3_439" data-tooltip="A compilation has the following parameters:">compilation parameter</a>.</p></section><section class="chapter"><h3 id="tasks-error-in-gradle-configuration-cache" data-toc="tasks-error-in-gradle-configuration-cache">Tasks error in Gradle configuration cache</h3><p id="z7an5p3_440">Since Kotlin 2.0.0, you may encounter a configuration cache error with messages indicating: <code class="code" id="z7an5p3_445">invocation of Task.project at execution time is unsupported</code>.</p><p id="z7an5p3_441">This error appears in tasks such as <code class="code" id="z7an5p3_446">NativeDistributionCommonizerTask</code> and <code class="code" id="z7an5p3_447">KotlinNativeCompile</code>.</p><p id="z7an5p3_442">However, this is a false-positive error. The underlying issue is the presence of tasks that are not compatible with the Gradle configuration cache, like the <code class="code" id="z7an5p3_448">publish*</code> task.</p><p id="z7an5p3_443">This discrepancy may not be immediately apparent, as the error message suggests a different root cause.</p><p id="z7an5p3_444">As the precise cause isn't explicitly stated in the error report, <a href="https://github.com/gradle/gradle/issues/21290" id="z7an5p3_449" data-external="true" rel="noopener noreferrer" target="_blank">the Gradle team is already addressing the issue to fix reports</a>.</p></section></section><section class="chapter"><h2 id="kotlin-wasm" data-toc="kotlin-wasm">Kotlin/Wasm</h2><p id="z7an5p3_450">Kotlin 2.0.0 improves performance and interoperability with JavaScript:</p><ul class="list _bullet" id="z7an5p3_451"><li class="list__item" id="z7an5p3_459"><p id="z7an5p3_466"><a href="#optimized-production-builds-by-default-using-binaryen" id="z7an5p3_467" data-tooltip="The Kotlin/Wasm toolchain now applies the Binaryen tool during production compilation to all projects, as opposed to the previous manual setup approach. By our estimations, it should improve runtime performance and reduce the binary size for your project.">Optimized production builds by default using Binaryen</a></p></li><li class="list__item" id="z7an5p3_460"><p id="z7an5p3_468"><a href="#support-for-named-export" id="z7an5p3_469" data-tooltip="Previously, all exported declarations from Kotlin/Wasm were imported into JavaScript using default export:">Support for named export</a></p></li><li class="list__item" id="z7an5p3_461"><p id="z7an5p3_470"><a href="#support-for-unsigned-primitive-types-in-functions-with-jsexport" id="z7an5p3_471" data-tooltip="Starting from Kotlin 2.0.0, you can use unsigned primitive types inside external declarations and functions with the @JsExport annotation that makes Kotlin/Wasm functions available in JavaScript code.">Support for unsigned primitive types in functions with <code class="code" id="z7an5p3_472">@JsExport</code></a></p></li><li class="list__item" id="z7an5p3_462"><p id="z7an5p3_473"><a href="#generation-of-typescript-declaration-files-in-kotlin-wasm" id="z7an5p3_474" data-tooltip="Generating TypeScript declaration files in Kotlin/Wasm is Experimental. It may be dropped or changed at any time.">Generation of TypeScript declaration files in Kotlin/Wasm</a></p></li><li class="list__item" id="z7an5p3_463"><p id="z7an5p3_475"><a href="#support-for-catching-javascript-exceptions" id="z7an5p3_476" data-tooltip="Previously, Kotlin/Wasm code could not catch JavaScript exceptions, making it difficult to handle errors originating from the JavaScript side of the program.">Support for catching JavaScript exceptions</a></p></li><li class="list__item" id="z7an5p3_464"><p id="z7an5p3_477"><a href="#new-exception-handling-proposal-is-now-supported-as-an-option" id="z7an5p3_478" data-tooltip="In this release, we introduce support for the new version of WebAssembly's exception handling proposal within Kotlin/Wasm.">New exception handling proposal is now supported as an option</a></p></li><li class="list__item" id="z7an5p3_465"><p id="z7an5p3_479"><a href="#the-withwasm-function-is-split-into-js-and-wasi-variants" id="z7an5p3_480" data-tooltip="The withWasm() function, which used to provide Wasm targets for hierarchy templates, is deprecated in favor of specialized withWasmJs() and withWasmWasi() functions.">The <code class="code" id="z7an5p3_481">withWasm()</code> function is split into JS and WASI variants</a></p></li></ul><section class="chapter"><h3 id="optimized-production-builds-by-default-using-binaryen" data-toc="optimized-production-builds-by-default-using-binaryen">Optimized production builds by default using Binaryen</h3><p id="z7an5p3_482">The Kotlin/Wasm toolchain now applies the <a href="https://github.com/WebAssembly/binaryen" id="z7an5p3_484" data-external="true" rel="noopener noreferrer" target="_blank">Binaryen</a> tool during production compilation to all projects, as opposed to the previous manual setup approach. By our estimations, it should improve runtime performance and reduce the binary size for your project.</p><aside class="prompt" data-type="note" data-title="" id="z7an5p3_483"><p id="z7an5p3_485">This change only affects production compilation. The development compilation process stays the same.</p></aside></section><section class="chapter"><h3 id="support-for-named-export" data-toc="support-for-named-export">Support for named export</h3><p id="z7an5p3_486">Previously, all exported declarations from Kotlin/Wasm were imported into JavaScript using default export:</p><div class="code-block" data-lang="javascript">
//JavaScript:
import Module from &quot;./index.mjs&quot;

Module.add()
</div><p id="z7an5p3_488">Now, you can import each Kotlin declaration marked with <code class="code" id="z7an5p3_492">@JsExport</code> by name:</p><div class="code-block" data-lang="kotlin">
// Kotlin:
@JsExport
fun add(a: Int, b: Int) = a + b
</div><div class="code-block" data-lang="javascript">
//JavaScript:
import { add } from &quot;./index.mjs&quot;
</div><p id="z7an5p3_491">Named exports make it easier to share code between Kotlin and JavaScript modules. They improve readability and help you manage dependencies between modules.</p></section><section class="chapter"><h3 id="support-for-unsigned-primitive-types-in-functions-with-jsexport" data-toc="support-for-unsigned-primitive-types-in-functions-with-jsexport">Support for unsigned primitive types in functions with @JsExport</h3><p id="z7an5p3_493">Starting from Kotlin 2.0.0, you can use <a href="unsigned-integer-types.html" id="z7an5p3_496" data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:">unsigned primitive types</a> inside external declarations and functions with the <code class="code" id="z7an5p3_497">@JsExport</code> annotation that makes Kotlin/Wasm functions available in JavaScript code.</p><p id="z7an5p3_494">This helps to mitigate the previous limitation that prevented <a href="unsigned-integer-types.html" id="z7an5p3_498" data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:">the unsigned primitives</a> from being used directly inside exported and external declarations. Now you can export functions with unsigned primitives as a return or parameter type and consume external declarations that return or consume unsigned primitives.</p><p id="z7an5p3_495">For more information on Kotlin/Wasm interoperability with JavaScript, see the <a href="wasm-js-interop.html#use-javascript-code-in-kotlin" id="z7an5p3_499" data-tooltip="Learn how to use JavaScript code in Kotlin by using external declarations, functions with JavaScript code snippets, and the @JsModule annotation.">documentation</a>.</p></section><section class="chapter"><h3 id="generation-of-typescript-declaration-files-in-kotlin-wasm" data-toc="generation-of-typescript-declaration-files-in-kotlin-wasm">Generation of TypeScript declaration files in Kotlin/Wasm</h3><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_500"><p id="z7an5p3_505">Generating TypeScript declaration files in Kotlin/Wasm is <a href="components-stability.html#stability-levels-explained" id="z7an5p3_506" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. It may be dropped or changed at any time.</p></aside><p id="z7an5p3_501">In Kotlin 2.0.0, the Kotlin/Wasm compiler is now capable of generating TypeScript definitions from any <code class="code" id="z7an5p3_507">@JsExport</code> declarations in your Kotlin code. These definitions can be used by IDEs and JavaScript tools to provide code autocompletion, help with type checks, and make it easier to include Kotlin code in JavaScript.</p><p id="z7an5p3_502">The Kotlin/Wasm compiler collects any <a href="wasm-js-interop.html#functions-with-the-jsexport-annotation" id="z7an5p3_508" data-tooltip="To make a Kotlin/Wasm function available to JavaScript code, use the @JsExport annotation:">top-level functions</a> marked with <code class="code" id="z7an5p3_509">@JsExport</code> and automatically generates TypeScript definitions in a <code class="code" id="z7an5p3_510">.d.ts</code> file.</p><p id="z7an5p3_503">To generate TypeScript definitions, in your <code class="code" id="z7an5p3_511">build.gradle(.kts)</code> file in the <code class="code" id="z7an5p3_512">wasmJs {}</code> block, add the <code class="code" id="z7an5p3_513">generateTypeScriptDefinitions()</code> function:</p><div class="code-block" data-lang="kotlin">
kotlin {
    wasmJs {
        binaries.executable()
        browser {
        }
        generateTypeScriptDefinitions()
    }
}
</div></section><section class="chapter"><h3 id="support-for-catching-javascript-exceptions" data-toc="support-for-catching-javascript-exceptions">Support for catching JavaScript exceptions</h3><p id="z7an5p3_514">Previously, Kotlin/Wasm code could not catch JavaScript exceptions, making it difficult to handle errors originating from the JavaScript side of the program.</p><p id="z7an5p3_515">In Kotlin 2.0.0, we have implemented support for catching JavaScript exceptions within Kotlin/Wasm. This implementation allows you to use <code class="code" id="z7an5p3_517">try-catch</code> blocks, with specific types like <code class="code" id="z7an5p3_518">Throwable</code> or <code class="code" id="z7an5p3_519">JsException</code>, to handle these errors properly.</p><p id="z7an5p3_516">Additionally, <code class="code" id="z7an5p3_520">finally</code> blocks, which help execute code regardless of exceptions, also work correctly. While we're introducing support for catching JavaScript exceptions, no additional information is provided when a JavaScript exception, like a call stack, occurs. However, <a href="https://youtrack.jetbrains.com/issue/KT-68185/WasmJs-Attach-js-exception-object-to-JsException" id="z7an5p3_521" data-external="true" rel="noopener noreferrer" target="_blank">we are working on these implementations</a>.</p></section><section class="chapter"><h3 id="new-exception-handling-proposal-is-now-supported-as-an-option" data-toc="new-exception-handling-proposal-is-now-supported-as-an-option">New exception handling proposal is now supported as an option</h3><p id="z7an5p3_522">In this release, we introduce support for the new version of WebAssembly's <a href="https://github.com/WebAssembly/exception-handling/blob/main/proposals/exception-handling/Exceptions.md" id="z7an5p3_525" data-external="true" rel="noopener noreferrer" target="_blank">exception handling proposal</a> within Kotlin/Wasm.</p><p id="z7an5p3_523">This update ensures the new proposal aligns with Kotlin requirements, enabling the use of Kotlin/Wasm on virtual machines that only support the latest version of the proposal.</p><p id="z7an5p3_524">Activate the new exception handling proposal by using the <code class="code" id="z7an5p3_526">-Xwasm-use-new-exception-proposal</code> compiler option, which is turned off by default.</p></section><section class="chapter"><h3 id="the-withwasm-function-is-split-into-js-and-wasi-variants" data-toc="the-withwasm-function-is-split-into-js-and-wasi-variants">The withWasm() function is split into JS and WASI variants</h3><p id="z7an5p3_527">The <code class="code" id="z7an5p3_529">withWasm()</code> function, which used to provide Wasm targets for hierarchy templates, is deprecated in favor of specialized <code class="code" id="z7an5p3_530">withWasmJs()</code> and <code class="code" id="z7an5p3_531">withWasmWasi()</code> functions.</p><p id="z7an5p3_528">Now you can separate the WASI and JS targets between different groups in the tree definition.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="z7an5p3_532">Among other changes, this version brings modern JS compilation to Kotlin, supporting more features from the ES2015 standard:</p><ul class="list _bullet" id="z7an5p3_533"><li class="list__item" id="z7an5p3_544"><p id="z7an5p3_554"><a href="#new-compilation-target" id="z7an5p3_555" data-tooltip="In Kotlin 2.0.0, we're adding a new compilation target to Kotlin/JS, es2015. This is a new way for you to enable all the ES2015 features supported in Kotlin at once.">New compilation target</a></p></li><li class="list__item" id="z7an5p3_545"><p id="z7an5p3_556"><a href="#suspend-functions-as-es2015-generators" id="z7an5p3_557" data-tooltip="This release introduces Experimental support for ES2015 generators for compiling suspend functions.">Suspend functions as ES2015 generators</a></p></li><li class="list__item" id="z7an5p3_546"><p id="z7an5p3_558"><a href="#passing-arguments-to-the-main-function" id="z7an5p3_559" data-tooltip="Starting with Kotlin 2.0.0, you can specify a source of your args for the main() function. This feature makes it easier to work with the command line and pass the arguments.">Passing arguments to the main function</a></p></li><li class="list__item" id="z7an5p3_547"><p id="z7an5p3_560"><a href="#per-file-compilation-for-kotlin-js-projects" id="z7an5p3_561" data-tooltip="Kotlin 2.0.0 introduces a new granularity option for the Kotlin/JS project output. You can now set up a per-file compilation that generates one JavaScript file for each Kotlin file. It helps to significantly optimize the size of the final bundle and improve the loading time of the…">Per-file compilation for Kotlin/JS projects</a></p></li><li class="list__item" id="z7an5p3_548"><p id="z7an5p3_562"><a href="#improved-collection-interoperability" id="z7an5p3_563" data-tooltip="Starting with Kotlin 2.0.0, it's possible to export declarations with a Kotlin collection type inside the signature to JavaScript (and TypeScript). This applies to Set, Map, and List collection types and their mutable counterparts.">Improved collection interoperability</a></p></li><li class="list__item" id="z7an5p3_549"><p id="z7an5p3_564"><a href="#support-for-createinstance" id="z7an5p3_565" data-tooltip="Starting with Kotlin 2.0.0, you can use the createInstance() function from the Kotlin/JS target. Previously, it was only available on the JVM.">Support for createInstance()</a></p></li><li class="list__item" id="z7an5p3_550"><p id="z7an5p3_566"><a href="#support-for-type-safe-plain-javascript-objects" id="z7an5p3_567" data-tooltip="The js-plain-objects plugin is Experimental. It may be dropped or changed at any time. The js-plain-objects plugin only supports the K2 compiler.">Support for type-safe plain JavaScript objects</a></p></li><li class="list__item" id="z7an5p3_551"><p id="z7an5p3_568"><a href="#support-for-npm-package-manager" id="z7an5p3_569" data-tooltip="Previously, it was only possible for the Kotlin Multiplatform Gradle plugin to use Yarn as a package manager to download and install npm dependencies. From Kotlin 2.0.0, you can use npm as your package manager instead. Using npm as a package manager means that you have one less tool…">Support for npm package manager</a></p></li><li class="list__item" id="z7an5p3_552"><p id="z7an5p3_570"><a href="#changes-to-compilation-tasks" id="z7an5p3_571" data-tooltip="Previously, the webpack and distributeResources compilation tasks both targeted the same directories. Moreover, the distribution task declared the dist as its output directory as well. This resulted in overlapping outputs and produced a compilation warning.">Changes to compilation tasks</a></p></li><li class="list__item" id="z7an5p3_553"><p id="z7an5p3_572"><a href="#discontinuing-legacy-kotlin-js-jar-artifacts" id="z7an5p3_573" data-tooltip="Starting with Kotlin 2.0.0, the Kotlin distribution no longer contains legacy Kotlin/JS artifacts with the .jar extension. Legacy artifacts were used in the unsupported old Kotlin/JS compiler and unnecessary for the IR compiler, which uses the klib format.">Discontinuing legacy Kotlin/JS JAR artifacts</a></p></li></ul><section class="chapter"><h3 id="new-compilation-target" data-toc="new-compilation-target">New compilation target</h3><p id="z7an5p3_574">In Kotlin 2.0.0, we're adding a new compilation target to Kotlin/JS, <code class="code" id="z7an5p3_578">es2015</code>. This is a new way for you to enable all the ES2015 features supported in Kotlin at once.</p><p id="z7an5p3_575">You can set it up in your <code class="code" id="z7an5p3_579">build.gradle(.kts)</code> file like this:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js {
        compilerOptions {
            target.set(&quot;es2015&quot;)
        }
    }
}
</div><p id="z7an5p3_577">The new target automatically turns on <a href="whatsnew19.html#experimental-support-for-es2015-classes-and-modules" id="z7an5p3_580" data-tooltip="This release introduces Experimental support for ES2015 modules and generation of ES2015 classes:">ES classes and modules</a> and the newly supported <a href="#suspend-functions-as-es2015-generators" id="z7an5p3_581" data-tooltip="This release introduces Experimental support for ES2015 generators for compiling suspend functions.">ES generators</a>.</p></section><section class="chapter"><h3 id="suspend-functions-as-es2015-generators" data-toc="suspend-functions-as-es2015-generators">Suspend functions as ES2015 generators</h3><p id="z7an5p3_582">This release introduces <a href="components-stability.html#stability-levels-explained" id="z7an5p3_585" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a> support for ES2015 generators for compiling <span id="z7an5p3_586">suspend functions</span>.</p><p id="z7an5p3_583">Using generators instead of state machines should improve the final bundle size of your project. For example, the JetBrains team managed to decrease the bundle size of its Space project by 20% by using the ES2015 generators.</p><p id="z7an5p3_584"><a href="https://262.ecma-international.org/6.0/" id="z7an5p3_587" data-external="true" rel="noopener noreferrer" target="_blank">Learn more about ES2015 (ECMAScript 2015, ES6) in the official documentation</a>.</p></section><section class="chapter"><h3 id="passing-arguments-to-the-main-function" data-toc="passing-arguments-to-the-main-function">Passing arguments to the main function</h3><p id="z7an5p3_588">Starting with Kotlin 2.0.0, you can specify a source of your <code class="code" id="z7an5p3_594">args</code> for the <code class="code" id="z7an5p3_595">main()</code> function. This feature makes it easier to work with the command line and pass the arguments.</p><p id="z7an5p3_589">To do this, define the <code class="code" id="z7an5p3_596">js {}</code> block with the new <code class="code" id="z7an5p3_597">passAsArgumentToMainFunction()</code> function, which returns an array of strings:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js {
        binary.executable()
        passAsArgumentToMainFunction(&quot;Deno.args&quot;)
    }
}
</div><p id="z7an5p3_591">The function is executed at runtime. It takes the JavaScript expression and uses it as the <code class="code" id="z7an5p3_598">args: Array&lt;String&gt;</code> argument instead of the <code class="code" id="z7an5p3_599">main()</code> function call.</p><p id="z7an5p3_592">Also, if you use the Node.js runtime, you can take advantage of a special alias. It allows you to pass <code class="code" id="z7an5p3_600">process.argv</code> to the <code class="code" id="z7an5p3_601">args</code> parameter once instead of adding it manually every time:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js {
        binary.executable()
        nodejs {
            passProcessArgvToMainFunction()
        }
    }
}
</div></section><section class="chapter"><h3 id="per-file-compilation-for-kotlin-js-projects" data-toc="per-file-compilation-for-kotlin-js-projects">Per-file compilation for Kotlin/JS projects</h3><p id="z7an5p3_602">Kotlin 2.0.0 introduces a new granularity option for the Kotlin/JS project output. You can now set up a per-file compilation that generates one JavaScript file for each Kotlin file. It helps to significantly optimize the size of the final bundle and improve the loading time of the program.</p><p id="z7an5p3_603">Previously, there were only two output options. The Kotlin/JS compiler could generate a single <code class="code" id="z7an5p3_606">.js</code> file for the whole project. However, this file might be too large and inconvenient to use. Whenever you wanted to use a function from your project, you had to include the entire JavaScript file as a dependency. Alternatively, you could configure a compilation of a separate <code class="code" id="z7an5p3_607">.js</code> file for each project module. This is still the default option.</p><p id="z7an5p3_604">Since module files could also be too large, with Kotlin 2.0.0, we add a more granular output that generates one (or two, if the file contains exported declarations) JavaScript file per each Kotlin file. To enable the per-file compilation mode:</p><ol class="list _decimal" id="z7an5p3_605" type="1"><li class="list__item" id="z7an5p3_608"><p id="z7an5p3_610">Add the <a href="whatsnew19.html#experimental-support-for-es2015-classes-and-modules" id="z7an5p3_613" data-tooltip="This release introduces Experimental support for ES2015 modules and generation of ES2015 classes:"><code class="code" id="z7an5p3_614">useEsModules()</code></a> function to your build file to support ECMAScript modules:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    js(IR) {
        useEsModules() // Enables ES2015 modules
        browser()
    }
}
</div><p id="z7an5p3_612">You can also use the new <code class="code" id="z7an5p3_615">es2015</code> <a href="#new-compilation-target" id="z7an5p3_616" data-tooltip="In Kotlin 2.0.0, we're adding a new compilation target to Kotlin/JS, es2015. This is a new way for you to enable all the ES2015 features supported in Kotlin at once.">compilation target</a> for that.</p></li><li class="list__item" id="z7an5p3_609"><p id="z7an5p3_617">Apply the <code class="code" id="z7an5p3_619">-Xir-per-file</code> compiler option or update your <code class="code" id="z7an5p3_620">gradle.properties</code> file with:</p><div class="code-block" data-lang="none">
# gradle.properties
kotlin.js.ir.output.granularity=per-file // `per-module` is the default
</div></li></ol></section><section class="chapter"><h3 id="improved-collection-interoperability" data-toc="improved-collection-interoperability">Improved collection interoperability</h3><p id="z7an5p3_621">Starting with Kotlin 2.0.0, it's possible to export declarations with a Kotlin collection type inside the signature to JavaScript (and TypeScript). This applies to <code class="code" id="z7an5p3_627">Set</code>, <code class="code" id="z7an5p3_628">Map</code>, and <code class="code" id="z7an5p3_629">List</code> collection types and their mutable counterparts.</p><p id="z7an5p3_622">To use Kotlin collections in JavaScript, first mark the necessary declarations with <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.js/-js-export/" id="z7an5p3_630" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_631">@JsExport</code></a> annotation:</p><div class="code-block" data-lang="kotlin">
// Kotlin
@JsExport
data class User(
    val name: String,
    val friends: List&lt;User&gt; = emptyList()
)

@JsExport
val me = User(
    name = &quot;Me&quot;,
    friends = listOf(User(name = &quot;Kodee&quot;))
)
</div><p id="z7an5p3_624">You can then consume them from JavaScript as regular JavaScript arrays:</p><div class="code-block" data-lang="javascript">
// JavaScript
import { User, me, KtList } from &quot;my-module&quot;

const allMyFriendNames = me.friends
    .asJsReadonlyArrayView()
    .map(x =&gt; x.name) // [‘Kodee']
</div><aside class="prompt" data-type="note" data-title="" id="z7an5p3_626"><p id="z7an5p3_632">Unfortunately, creating Kotlin collections from JavaScript is still unavailable. We're planning to add this functionality in Kotlin 2.0.20.</p></aside></section><section class="chapter"><h3 id="support-for-createinstance" data-toc="support-for-createinstance">Support for createInstance()</h3><p id="z7an5p3_633">Starting with Kotlin 2.0.0, you can use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/create-instance.html" id="z7an5p3_635" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_636">createInstance()</code></a> function from the Kotlin/JS target. Previously, it was only available on the JVM.</p><p id="z7an5p3_634">This function from the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/" id="z7an5p3_637" data-external="true" rel="noopener noreferrer" target="_blank">KClass</a> interface creates a new instance of the specified class, which is useful for getting the runtime reference to a Kotlin class.</p></section><section class="chapter"><h3 id="support-for-type-safe-plain-javascript-objects" data-toc="support-for-type-safe-plain-javascript-objects">Support for type-safe plain JavaScript objects</h3><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_638"><p id="z7an5p3_650">The <code class="code" id="z7an5p3_651">js-plain-objects</code> plugin is <a href="components-stability.html#stability-levels-explained" id="z7an5p3_652" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. It may be dropped or changed at any time. The <code class="code" id="z7an5p3_653">js-plain-objects</code> plugin <span class="control" id="z7an5p3_654">only</span> supports the K2 compiler.</p></aside><p id="z7an5p3_639">To make it easier to work with JavaScript APIs, in Kotlin 2.0.0, we provide a new plugin: <a href="https://github.com/JetBrains/kotlin/tree/master/plugins/js-plain-objects" id="z7an5p3_655" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_658">js-plain-objects</code></a>, which you can use to create type-safe plain JavaScript objects. The plugin checks your code for any <a href="wasm-js-interop.html#external-interfaces" id="z7an5p3_656" data-tooltip="You can describe the shape of a JavaScript object in Kotlin. Consider this JavaScript function and what it returns:">external interfaces</a> that have a <code class="code" id="z7an5p3_657">@JsPlainObject</code> annotation and adds:</p><ul class="list _bullet" id="z7an5p3_640"><li class="list__item" id="z7an5p3_659"><p id="z7an5p3_661">An inline <code class="code" id="z7an5p3_662">invoke</code> operator function inside the companion object that you can use as a constructor.</p></li><li class="list__item" id="z7an5p3_660"><p id="z7an5p3_663">A <code class="code" id="z7an5p3_664">.copy()</code> function that you can use to create a copy of your object while adjusting some of its properties.</p></li></ul><p id="z7an5p3_641">For example:</p><div class="code-block" data-lang="kotlin">
import kotlinx.js.JsPlainObject

@JsPlainObject
external interface User {
    var name: String
    val age: Int
    val email: String?
}

fun main() {
    // Creates a JavaScript object
    val user = User(name = &quot;Name&quot;, age = 10)
    // Copies the object and adds an email
    val copy = user.copy(age = 11, email = &quot;some@user.com&quot;)

    println(JSON.stringify(user))
    // { &quot;name&quot;: &quot;Name&quot;, &quot;age&quot;: 10 }
    println(JSON.stringify(copy))
    // { &quot;name&quot;: &quot;Name&quot;, &quot;age&quot;: 11, &quot;email&quot;: &quot;some@user.com&quot; }
}
</div><p id="z7an5p3_643">Any JavaScript objects created with this approach are safer because instead of only seeing errors at runtime, you can see them at compile time or even highlighted by your IDE.</p><p id="z7an5p3_644">Consider this example, which uses a <code class="code" id="z7an5p3_665">fetch()</code> function to interact with a JavaScript API using external interfaces to describe the shape of the JavaScript objects:</p><div class="code-block" data-lang="kotlin">
import kotlinx.js.JsPlainObject

@JsPlainObject
external interface FetchOptions {
    val body: String?
    val method: String
}

// A wrapper for Window.fetch
suspend fun fetch(url: String, options: FetchOptions? = null) = TODO(&quot;Add your custom behavior here&quot;)

// A compile-time error is triggered as &quot;metod&quot; is not recognized
// as method
fetch(&quot;https://google.com&quot;, options = FetchOptions(metod = &quot;POST&quot;))
// A compile-time error is triggered as method is required
fetch(&quot;https://google.com&quot;, options = FetchOptions(body = &quot;SOME STRING&quot;)) 
</div><p id="z7an5p3_646">In comparison, if you use the <code class="code" id="z7an5p3_666">js()</code> function instead to create your JavaScript objects, errors are only found at runtime or aren't triggered at all:</p><div class="code-block" data-lang="kotlin">
suspend fun fetch(url: String, options: FetchOptions? = null) = TODO(&quot;Add your custom behavior here&quot;)

// No error is triggered. As &quot;metod&quot; is not recognized, the wrong method 
// (GET) is used.
fetch(&quot;https://google.com&quot;, options = js(&quot;{ metod: 'POST' }&quot;))

// By default, the GET method is used. A runtime error is triggered as 
// body shouldn't be present.
fetch(&quot;https://google.com&quot;, options = js(&quot;{ body: 'SOME STRING' }&quot;))
// TypeError: Window.fetch: HEAD or GET Request cannot have a body
</div><p id="z7an5p3_648">To use the <code class="code" id="z7an5p3_667">js-plain-objects</code> plugin, add the following to your <code class="code" id="z7an5p3_668">build.gradle(.kts)</code> file:</p><div class="tabs" id="z7an5p3_649" data-group="build-script" data-anchors="[z7an5p3_669,z7an5p3_670]"><div class="tabs__content" data-gtm="tab" id="z7an5p3_669" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
plugins {
    kotlin(&quot;plugin.js-plain-objects&quot;) version &quot;2.0.0&quot;
}
</div></div><div class="tabs__content" data-gtm="tab" id="z7an5p3_670" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
plugins {
    id &quot;org.jetbrains.kotlin.plugin.js-plain-objects&quot; version &quot;2.0.0&quot;
}
</div></div></div></section><section class="chapter"><h3 id="support-for-npm-package-manager" data-toc="support-for-npm-package-manager">Support for npm package manager</h3><p id="z7an5p3_673">Previously, it was only possible for the Kotlin Multiplatform Gradle plugin to use <a href="https://yarnpkg.com/lang/en/" id="z7an5p3_676" data-external="true" rel="noopener noreferrer" target="_blank">Yarn</a> as a package manager to download and install npm dependencies. From Kotlin 2.0.0, you can use <a href="https://www.npmjs.com/" id="z7an5p3_677" data-external="true" rel="noopener noreferrer" target="_blank">npm</a> as your package manager instead. Using npm as a package manager means that you have one less tool to manage during your setup.</p><p id="z7an5p3_674">For backward compatibility, Yarn is still the default package manager. To use npm as your package manager, set the following property in your <code class="code" id="z7an5p3_678">gradle.properties</code> file:</p><div class="code-block" data-lang="kotlin">
kotlin.js.yarn = false
</div></section><section class="chapter"><h3 id="changes-to-compilation-tasks" data-toc="changes-to-compilation-tasks">Changes to compilation tasks</h3><p id="z7an5p3_679">Previously, the <code class="code" id="z7an5p3_682">webpack</code> and <code class="code" id="z7an5p3_683">distributeResources</code> compilation tasks both targeted the same directories. Moreover, the <code class="code" id="z7an5p3_684">distribution</code> task declared the <code class="code" id="z7an5p3_685">dist</code> as its output directory as well. This resulted in overlapping outputs and produced a compilation warning.</p><p id="z7an5p3_680">So, starting with Kotlin 2.0.0, we've implemented the following changes:</p><ul class="list _bullet" id="z7an5p3_681"><li class="list__item" id="z7an5p3_686"><p id="z7an5p3_689">The <code class="code" id="z7an5p3_690">webpack</code> task now targets a separate folder.</p></li><li class="list__item" id="z7an5p3_687"><p id="z7an5p3_691">The <code class="code" id="z7an5p3_692">distributeResources</code> task has been completely removed.</p></li><li class="list__item" id="z7an5p3_688"><p id="z7an5p3_693">The <code class="code" id="z7an5p3_694">distribution</code> task now has the <code class="code" id="z7an5p3_695">Copy</code> type and targets the <code class="code" id="z7an5p3_696">dist</code> folder.</p></li></ul></section><section class="chapter"><h3 id="discontinuing-legacy-kotlin-js-jar-artifacts" data-toc="discontinuing-legacy-kotlin-js-jar-artifacts">Discontinuing legacy Kotlin/JS JAR artifacts</h3><p id="z7an5p3_697">Starting with Kotlin 2.0.0, the Kotlin distribution no longer contains legacy Kotlin/JS artifacts with the <code class="code" id="z7an5p3_698">.jar</code> extension. Legacy artifacts were used in the unsupported old Kotlin/JS compiler and unnecessary for the IR compiler, which uses the <code class="code" id="z7an5p3_699">klib</code> format.</p></section></section><section class="chapter"><h2 id="gradle-improvements" data-toc="gradle-improvements">Gradle improvements</h2><p id="z7an5p3_700">Kotlin 2.0.0 is fully compatible with Gradle 6.8.3 through 8.5. You can also use Gradle versions up to the latest Gradle release, but if you do, keep in mind that you might encounter deprecation warnings or some new Gradle features might not work.</p><p id="z7an5p3_701">This version brings the following changes:</p><ul class="list _bullet" id="z7an5p3_702"><li class="list__item" id="z7an5p3_716"><p id="z7an5p3_730"><a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects" id="z7an5p3_731" data-tooltip="This feature is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">New Gradle DSL for compiler options in multiplatform projects</a></p></li><li class="list__item" id="z7an5p3_717"><p id="z7an5p3_732"><a href="#new-compose-compiler-gradle-plugin" id="z7an5p3_733" data-tooltip="The Jetpack Compose compiler, which translates composables into Kotlin code, has now been merged into the Kotlin repository. This will help transition Compose projects to Kotlin 2.0.0, as the Compose compiler will always ship simultaneously with Kotlin. This also bumps the Compose…">New Compose compiler Gradle plugin</a></p></li><li class="list__item" id="z7an5p3_718"><p id="z7an5p3_734"><a href="#bumped-minimum-supported-agp-version" id="z7an5p3_735" data-tooltip="Starting with Kotlin 2.0.0, the minimum supported Android Gradle plugin version is 7.1.3.">Bumping minimum supported versions</a></p></li><li class="list__item" id="z7an5p3_719"><p id="z7an5p3_736"><a href="#new-attribute-to-distinguish-jvm-and-android-published-libraries" id="z7an5p3_737" data-tooltip="Starting with Kotlin 2.0.0, the org.gradle.jvm.environment Gradle attribute is published by default with all Kotlin variants.">New attribute to distinguish JVM and Android published libraries</a></p></li><li class="list__item" id="z7an5p3_720"><p id="z7an5p3_738"><a href="#improved-gradle-dependency-handling-for-cinteropprocess-in-kotlin-native" id="z7an5p3_739" data-tooltip="In this release, we enhanced the handling of the defFile property to ensure better Gradle task dependency management in Kotlin/Native projects.">Improved Gradle dependency handling for CInteropProcess in Kotlin/Native</a></p></li><li class="list__item" id="z7an5p3_721"><p id="z7an5p3_740"><a href="#visibility-changes-in-gradle" id="z7an5p3_741" data-tooltip="This change impacts only Kotlin DSL users.">Visibility changes in Gradle</a></p></li><li class="list__item" id="z7an5p3_722"><p id="z7an5p3_742"><a href="#new-directory-for-kotlin-data-in-gradle-projects" id="z7an5p3_743" data-tooltip="Do not commit the .kotlin directory to version control. For example, if you are using Git, add .kotlin to your project's .gitignore file.">New directory for Kotlin data in Gradle projects</a></p></li><li class="list__item" id="z7an5p3_723"><p id="z7an5p3_744"><a href="#kotlin-native-compiler-downloaded-when-needed" id="z7an5p3_745" data-tooltip="Before Kotlin 2.0.0, if you had a Kotlin/Native target configured in the Gradle build script of your multiplatform project, Gradle would always download the Kotlin/Native compiler in the configuration phase.">Kotlin/Native compiler downloaded when needed</a></p></li><li class="list__item" id="z7an5p3_724"><p id="z7an5p3_746"><a href="#deprecated-old-ways-of-defining-compiler-options" id="z7an5p3_747" data-tooltip="In this release, we continue to refine how you can set up compiler options. It should resolve ambiguity between different ways and make the project configuration more straightforward.">Deprecating old ways of defining compiler options</a></p></li><li class="list__item" id="z7an5p3_725"><p id="z7an5p3_748"><a href="#bumped-minimum-supported-agp-version" id="z7an5p3_749" data-tooltip="Starting with Kotlin 2.0.0, the minimum supported Android Gradle plugin version is 7.1.3.">Bumped minimum AGP supported version</a></p></li><li class="list__item" id="z7an5p3_726"><p id="z7an5p3_750"><a href="#new-gradle-property-for-trying-the-latest-language-version" id="z7an5p3_751" data-tooltip="Prior to Kotlin 2.0.0, we had the following Gradle property to try out the new K2 compiler: kotlin.experimental.tryK2. Now that the K2 compiler is enabled by default in Kotlin 2.0.0, we decided to evolve this property into a new form that you can use to try the latest language…">New Gradle property for trying the latest language version</a></p></li><li class="list__item" id="z7an5p3_727"><p id="z7an5p3_752"><a href="#new-json-output-format-for-build-reports" id="z7an5p3_753" data-tooltip="In Kotlin 1.7.0, we introduced build reports to help track compiler performance. Over time, we've added more metrics to make these reports even more detailed and helpful when investigating performance issues. Previously, the only output format for a local file was the *.txt format.…">New JSON output format for build reports</a></p></li><li class="list__item" id="z7an5p3_728"><p id="z7an5p3_754"><a href="#kapt-configurations-inherit-annotation-processors-from-superconfigurations" id="z7an5p3_755" data-tooltip="Prior to Kotlin 2.0.0, if you wanted to define a common set of annotation processors in a separate Gradle configuration and extend this configuration in kapt-specific configurations for your subprojects, kapt would skip annotation processing because it couldn't find any annotation…">kapt configurations inherit annotation processors from superconfigurations</a></p></li><li class="list__item" id="z7an5p3_729"><p id="z7an5p3_756"><a href="#kotlin-gradle-plugin-no-longer-uses-deprecated-gradle-conventions" id="z7an5p3_757" data-tooltip="Prior to Kotlin 2.0.0, if you used Gradle 8.2 or higher, the Kotlin Gradle plugin incorrectly used Gradle conventions that had been deprecated in Gradle 8.2. This led to Gradle reporting build deprecations. In Kotlin 2.0.0, the Kotlin Gradle plugin has been updated to no longer…">Kotlin Gradle plugin no longer uses deprecated Gradle conventions</a></p></li></ul><section class="chapter"><h3 id="new-gradle-dsl-for-compiler-options-in-multiplatform-projects" data-toc="new-gradle-dsl-for-compiler-options-in-multiplatform-projects">New Gradle DSL for compiler options in multiplatform projects</h3><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_758"><p id="z7an5p3_770">This feature is <a href="components-stability.html#stability-levels-explained" id="z7an5p3_771" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://kotl.in/issue" id="z7an5p3_772" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="z7an5p3_759">Prior to Kotlin 2.0.0, configuring compiler options in a multiplatform project with Gradle was only possible at a low level, such as per task, compilation, or source set. To make it easier to configure compiler options more generally in your projects, Kotlin 2.0.0 comes with a new Gradle DSL.</p><p id="z7an5p3_760">With this new DSL, you can configure compiler options at the extension level for all the targets and shared source sets like <code class="code" id="z7an5p3_773">commonMain</code> and at a target level for a specific target:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        // Extension-level common compiler options that are used as defaults
        // for all targets and shared source sets
        allWarningsAsErrors.set(true)
    }
    jvm {
        compilerOptions {
            // Target-level JVM compiler options that are used as defaults
            // for all compilations in this target
            noJdk.set(true)
        }
    }
}
</div><p id="z7an5p3_762">The overall project configuration now has three layers. The highest is the extension level, then the target level and the lowest is the compilation unit (which is usually a compilation task):</p><figure id="z7an5p3_763"><img alt="Kotlin compiler options levels" src="images/compiler-options-levels.svg" title="Kotlin compiler options levels" width="700" height="440"></figure><p id="z7an5p3_764">The settings at a higher level are used as a convention (default) for a lower level:</p><ul class="list _bullet" id="z7an5p3_765"><li class="list__item" id="z7an5p3_774"><p id="z7an5p3_776">The values of extension compiler options are the default for target compiler options, including shared source sets, like <code class="code" id="z7an5p3_777">commonMain</code>, <code class="code" id="z7an5p3_778">nativeMain</code>, and <code class="code" id="z7an5p3_779">commonTest</code>.</p></li><li class="list__item" id="z7an5p3_775"><p id="z7an5p3_780">The values of target compiler options are used as the default for compilation unit (task) compiler options, for example, <code class="code" id="z7an5p3_781">compileKotlinJvm</code> and <code class="code" id="z7an5p3_782">compileTestKotlinJvm</code> tasks.</p></li></ul><p id="z7an5p3_766">In turn, configurations made at a lower level override related settings at a higher level:</p><ul class="list _bullet" id="z7an5p3_767"><li class="list__item" id="z7an5p3_783"><p id="z7an5p3_785">Task-level compiler options override related configurations at the target or the extension level.</p></li><li class="list__item" id="z7an5p3_784"><p id="z7an5p3_786">Target-level compiler options override related configurations at the extension level.</p></li></ul><p id="z7an5p3_768">When configuring your project, keep in mind that some old ways of setting up compiler options have been <a href="#deprecated-old-ways-of-defining-compiler-options" id="z7an5p3_787" data-tooltip="In this release, we continue to refine how you can set up compiler options. It should resolve ambiguity between different ways and make the project configuration more straightforward.">deprecated</a>.</p><p id="z7an5p3_769">We encourage you to try the new DSL out in your multiplatform projects and leave feedback in <a href="https://kotl.in/issue" id="z7an5p3_788" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>, as we plan to make this DSL the recommended approach for configuring compiler options.</p></section><section class="chapter"><h3 id="new-compose-compiler-gradle-plugin" data-toc="new-compose-compiler-gradle-plugin">New Compose compiler Gradle plugin</h3><p id="z7an5p3_789">The Jetpack Compose compiler, which translates composables into Kotlin code, has now been merged into the Kotlin repository. This will help transition Compose projects to Kotlin 2.0.0, as the Compose compiler will always ship simultaneously with Kotlin. This also bumps the Compose compiler version to 2.0.0.</p><p id="z7an5p3_790">To use the new Compose compiler in your projects, apply the <code class="code" id="z7an5p3_792">org.jetbrains.kotlin.plugin.compose</code> Gradle plugin in your <code class="code" id="z7an5p3_793">build.gradle(.kts)</code> file and set its version equal to Kotlin 2.0.0.</p><p id="z7an5p3_791">To learn more about this change and see the migration instructions, see the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-compiler.html" id="z7an5p3_794" data-external="true" rel="noopener noreferrer" target="_blank">Compose compiler</a> documentation.</p></section><section class="chapter"><h3 id="new-attribute-to-distinguish-jvm-and-android-published-libraries" data-toc="new-attribute-to-distinguish-jvm-and-android-published-libraries">New attribute to distinguish JVM and Android-published libraries</h3><p id="z7an5p3_795">Starting with Kotlin 2.0.0, the <a href="https://docs.gradle.org/current/userguide/variant_attributes.html#sub:jvm_default_attributes" id="z7an5p3_800" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_801">org.gradle.jvm.environment</code></a> Gradle attribute is published by default with all Kotlin variants.</p><p id="z7an5p3_796">The attribute helps distinguish JVM and Android variants of Kotlin Multiplatform libraries. It indicates that a certain library variant is better suited for a certain JVM environment. The target environment could be &quot;android&quot;, &quot;standard-jvm&quot;, or &quot;no-jvm&quot;.</p><p id="z7an5p3_797">Publishing this attribute should make consuming Kotlin Multiplatform libraries with JVM and Android targets more robust from non-multiplatform clients as well, such as Java-only projects.</p><p id="z7an5p3_798">If necessary, you can disable attribute publication. To do that, add the following Gradle option to your <code class="code" id="z7an5p3_802">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.publishJvmEnvironmentAttribute=false
</div></section><section class="chapter"><h3 id="improved-gradle-dependency-handling-for-cinteropprocess-in-kotlin-native" data-toc="improved-gradle-dependency-handling-for-cinteropprocess-in-kotlin-native">Improved Gradle dependency handling for CInteropProcess in Kotlin/Native</h3><p id="z7an5p3_803">In this release, we enhanced the handling of the <code class="code" id="z7an5p3_810">defFile</code> property to ensure better Gradle task dependency management in Kotlin/Native projects.</p><p id="z7an5p3_804">Before this update, Gradle builds could fail if the <code class="code" id="z7an5p3_811">defFile</code> property was designated as an output of another task that hadn't been executed yet. The workaround for this issue was to add a dependency on this task:</p><div class="code-block" data-lang="kotlin">
kotlin {
    macosArm64(&quot;native&quot;) {
        compilations.getByName(&quot;main&quot;) {
            cinterops {
                val cinterop by creating {
                    defFileProperty.set(createDefFileTask.flatMap { it.defFile.asFile })
                    project.tasks.named(interopProcessingTaskName).configure {
                        dependsOn(createDefFileTask)
                    }
                }
            }
        }
    }
}
</div><p id="z7an5p3_806">To fix this, there is a new <code class="code" id="z7an5p3_812">RegularFileProperty</code> property called <code class="code" id="z7an5p3_813">definitionFile</code>. Now, Gradle lazily verifies the presence of the <code class="code" id="z7an5p3_814">definitionFile</code> property after the connected task has run later in the build process. This new approach eliminates the need for additional dependencies.</p><p id="z7an5p3_807">The <code class="code" id="z7an5p3_815">CInteropProcess</code> task and the <code class="code" id="z7an5p3_816">CInteropSettings</code> class use the <code class="code" id="z7an5p3_817">definitionFile</code> property instead of <code class="code" id="z7an5p3_818">defFile</code> and <code class="code" id="z7an5p3_819">defFileProperty</code>:</p><div class="tabs" id="z7an5p3_808" data-group="build-script" data-anchors="[groovy,kotlin]"><div class="tabs__content" data-gtm="tab" id="kotlin" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    macosArm64(&quot;native&quot;) {
        compilations.getByName(&quot;main&quot;) {
            cinterops {
                val cinterop by creating {
                    definitionFile.set(project.file(&quot;def-file.def&quot;))
                }
            }
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="groovy" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    macosArm64(&quot;native&quot;) {
        compilations.main {
            cinterops {
                cinterop {
                    definitionFile.set(project.file(&quot;def-file.def&quot;))
                }
            }
        }
    }
}
</div></div></div><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_809"><p id="z7an5p3_824"><code class="code" id="z7an5p3_825">defFile</code> and <code class="code" id="z7an5p3_826">defFileProperty</code> parameters are deprecated.</p></aside></section><section class="chapter"><h3 id="visibility-changes-in-gradle" data-toc="visibility-changes-in-gradle">Visibility changes in Gradle</h3><aside class="prompt" data-type="note" data-title="" id="z7an5p3_827"><p id="z7an5p3_837">This change impacts only Kotlin DSL users.</p></aside><p id="z7an5p3_828">In Kotlin 2.0.0, we've modified the Kotlin Gradle Plugin for better control and safety in your build scripts. Previously, certain Kotlin DSL functions and properties intended for a specific DSL context would inadvertently leak into other DSL contexts. This leakage could lead to the use of incorrect compiler options, settings being applied multiple times, and other misconfigurations:</p><div class="code-block" data-lang="kotlin">
kotlin {
    // Target DSL couldn't access methods and properties defined in the
    // kotlin{} extension DSL
    jvm {
        // Compilation DSL couldn't access methods and properties defined
        // in the kotlin{} extension DSL and Kotlin jvm{} target DSL
        compilations.configureEach {
            // Compilation task DSLs couldn't access methods and
            // properties defined in the kotlin{} extension, Kotlin jvm{}
            // target or Kotlin compilation DSL
            compileTaskProvider.configure {
                // For example:
                explicitApi()
                // ERROR as it is defined in the kotlin{} extension DSL
                mavenPublication {}
                // ERROR as it is defined in the Kotlin jvm{} target DSL
                defaultSourceSet {}
                // ERROR as it is defined in the Kotlin compilation DSL
            }
        }
    }
}
</div><p id="z7an5p3_830">To fix this issue, we've added the <code class="code" id="z7an5p3_838">@KotlinGradlePluginDsl</code> annotation, preventing the exposure of the Kotlin Gradle plugin DSL functions and properties to levels where they are not intended to be available. The following levels are separated from each other:</p><ul class="list _bullet" id="z7an5p3_831"><li class="list__item" id="z7an5p3_839"><p id="z7an5p3_843">Kotlin extension</p></li><li class="list__item" id="z7an5p3_840"><p id="z7an5p3_844">Kotlin target</p></li><li class="list__item" id="z7an5p3_841"><p id="z7an5p3_845">Kotlin compilation</p></li><li class="list__item" id="z7an5p3_842"><p id="z7an5p3_846">Kotlin compilation task</p></li></ul><p id="z7an5p3_832">For the most popular cases, we've added compiler warnings with suggestions on how to fix them if your build script is configured incorrectly. For example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm {
        sourceSets.getByName(&quot;jvmMain&quot;).dependencies {
            implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.7.3&quot;)
        }
    }
}
</div><p id="z7an5p3_834">In this case, the warning message for <code class="code" id="z7an5p3_847">sourceSets</code> is:</p><div class="code-block" data-lang="none">
[DEPRECATION] 'sourceSets: NamedDomainObjectContainer&lt;KotlinSourceSet&gt;' is deprecated.Accessing 'sourceSets' container on the Kotlin target level DSL is deprecated. Consider configuring 'sourceSets' on the Kotlin extension level.
</div><p id="z7an5p3_836">We would appreciate your feedback on this change! Share your comments directly to Kotlin developers in our <a href="https://kotlinlang.slack.com/archives/C19FD9681" id="z7an5p3_848" data-external="true" rel="noopener noreferrer" target="_blank">#gradle Slack channel</a>. <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" id="z7an5p3_849" data-external="true" rel="noopener noreferrer" target="_blank">Get a Slack invite</a>.</p></section><section class="chapter"><h3 id="new-directory-for-kotlin-data-in-gradle-projects" data-toc="new-directory-for-kotlin-data-in-gradle-projects">New directory for Kotlin data in Gradle projects</h3><aside class="prompt" data-type="warning" data-title="" id="z7an5p3_850"><p id="z7an5p3_856">Do not commit the <code class="code" id="z7an5p3_857">.kotlin</code> directory to version control. For example, if you are using Git, add <code class="code" id="z7an5p3_858">.kotlin</code> to your project's <code class="code" id="z7an5p3_859">.gitignore</code> file.</p></aside><p id="z7an5p3_851">In Kotlin 1.8.20, the Kotlin Gradle plugin switched to storing its data in the Gradle project cache directory: <code class="code" id="z7an5p3_860">&lt;project-root-directory&gt;/.gradle/kotlin</code>. However, the <code class="code" id="z7an5p3_861">.gradle</code> directory is reserved for Gradle only, and as a result it's not future-proof.</p><p id="z7an5p3_852">To solve this, as of Kotlin 2.0.0, we will store Kotlin data in your <code class="code" id="z7an5p3_862">&lt;project-root-directory&gt;/.kotlin</code> by default. We will continue to store some data in the <code class="code" id="z7an5p3_863">.gradle/kotlin</code> directory for backward compatibility.</p><p id="z7an5p3_853">The new Gradle properties you can configure are:</p><div class="table-wrapper"><table class="wide" id="z7an5p3_854"><thead><tr class="ijRowHead" id="z7an5p3_864"><th id="z7an5p3_867"><p>Gradle property</p></th><th id="z7an5p3_868"><p>Description</p></th></tr></thead><tbody><tr id="z7an5p3_865"><td id="z7an5p3_869"><p><code class="code" id="z7an5p3_871">kotlin.project.persistent.dir</code></p></td><td id="z7an5p3_870"><p>Configures the location where your project-level data is stored. Default: <code class="code" id="z7an5p3_872">&lt;project-root-directory&gt;/.kotlin</code></p></td></tr><tr id="z7an5p3_866"><td id="z7an5p3_873"><p><code class="code" id="z7an5p3_875">kotlin.project.persistent.dir.gradle.disableWrite</code></p></td><td id="z7an5p3_874"><p>A boolean value that controls whether writing Kotlin data to the <code class="code" id="z7an5p3_876">.gradle</code> directory is disabled. Default: <code class="code" id="z7an5p3_877">false</code></p></td></tr></tbody></table></div><p id="z7an5p3_855">Add these properties to the <code class="code" id="z7an5p3_878">gradle.properties</code> file in your projects for them to take effect.</p></section><section class="chapter"><h3 id="kotlin-native-compiler-downloaded-when-needed" data-toc="kotlin-native-compiler-downloaded-when-needed">Kotlin/Native compiler downloaded when needed</h3><p id="z7an5p3_879">Before Kotlin 2.0.0, if you had a <a href="native-target-support.html" id="z7an5p3_890" data-tooltip="The Kotlin/Native compiler supports a great number of different targets, though it is hard to provide the same level of support for all of them. This document describes which targets Kotlin/Native supports and breaks them into several tiers depending on how well the compiler…">Kotlin/Native target</a> configured in the Gradle build script of your multiplatform project, Gradle would always download the Kotlin/Native compiler in the <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:configuration" id="z7an5p3_891" data-external="true" rel="noopener noreferrer" target="_blank">configuration phase</a>.</p><p id="z7an5p3_880">This happened even if there was no task to compile code for a Kotlin/Native target that was due to run in the <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:execution" id="z7an5p3_892" data-external="true" rel="noopener noreferrer" target="_blank">execution phase</a>. Downloading the Kotlin/Native compiler in this way was particularly inefficient for users who only wanted to check the JVM or JavaScript code in their projects. For example, to perform tests or checks with their Kotlin project as part of a CI process.</p><p id="z7an5p3_881">In Kotlin 2.0.0, we changed this behavior in the Kotlin Gradle plugin so that the Kotlin/Native compiler is downloaded in the <a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:execution" id="z7an5p3_893" data-external="true" rel="noopener noreferrer" target="_blank">execution phase</a> and <span class="control" id="z7an5p3_894">only</span> when a compilation is requested for a Kotlin/Native target.</p><p id="z7an5p3_882">In turn, the Kotlin/Native compiler's dependencies are now downloaded not as a part of the compiler, but in the execution phase as well.</p><p id="z7an5p3_883">If you encounter any issues with the new behavior, you can temporarily switch back to the previous behavior by adding the following Gradle property to your <code class="code" id="z7an5p3_895">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.toolchain.enabled=false
</div><p id="z7an5p3_885">Starting with Kotlin 1.9.20-Beta, the Kotlin/Native distribution is published to <a href="https://repo.maven.apache.org/maven2/org/jetbrains/kotlin/kotlin-native-prebuilt/" id="z7an5p3_896" data-external="true" rel="noopener noreferrer" target="_blank">Maven Central</a> along with the CDN.</p><p id="z7an5p3_886">This allowed us to change how Kotlin looks for and downloads the necessary artifacts. Instead of the CDN, by default, it now uses the Maven repositories that you specified in the <code class="code" id="z7an5p3_897">repositories {}</code> block of your project.</p><p id="z7an5p3_887">You can temporarily switch this behavior back by setting the following Gradle property in your <code class="code" id="z7an5p3_898">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.distribution.downloadFromMaven=false
</div><p id="z7an5p3_889">Please report any problems to our issue tracker <a href="https://kotl.in/issue" id="z7an5p3_899" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>. Both of these Gradle properties that change the default behavior are temporary and will be removed in future releases.</p></section><section class="chapter"><h3 id="deprecated-old-ways-of-defining-compiler-options" data-toc="deprecated-old-ways-of-defining-compiler-options">Deprecated old ways of defining compiler options</h3><p id="z7an5p3_900">In this release, we continue to refine how you can set up compiler options. It should resolve ambiguity between different ways and make the project configuration more straightforward.</p><p id="z7an5p3_901">Since Kotlin 2.0.0, the following DSLs for specifying compiler options are deprecated:</p><ul class="list _bullet" id="z7an5p3_902"><li class="list__item" id="z7an5p3_904"><p id="z7an5p3_909">The <code class="code" id="z7an5p3_910">kotlinOptions</code> DSL from the <code class="code" id="z7an5p3_911">KotlinCompile</code> interface that implements all Kotlin compilation tasks. Use <code class="code" id="z7an5p3_912">KotlinCompilationTask&lt;CompilerOptions&gt;</code> instead.</p></li><li class="list__item" id="z7an5p3_905"><p id="z7an5p3_913">The <code class="code" id="z7an5p3_918">compilerOptions</code> property with the <code class="code" id="z7an5p3_919">HasCompilerOptions</code> type from the <code class="code" id="z7an5p3_920">KotlinCompilation</code> interface. This DSL was inconsistent with other DSLs and configured the same <code class="code" id="z7an5p3_921">KotlinCommonCompilerOptions</code> object as <code class="code" id="z7an5p3_922">compilerOptions</code> inside the <code class="code" id="z7an5p3_923">KotlinCompilation.compileTaskProvider</code> compilation task, which was confusing.</p><p id="z7an5p3_914">Instead, we recommend using the <code class="code" id="z7an5p3_924">compilerOptions</code> property from the Kotlin compilation task:</p><div class="code-block" data-lang="kotlin">
kotlinCompilation.compileTaskProvider.configure {
    compilerOptions { ... }
}
</div><p id="z7an5p3_916">For example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js(IR) {
        compilations.all {
            compileTaskProvider.configure {
                compilerOptions.freeCompilerArgs.add(&quot;-Xir-minimized-member-names=false&quot;)
            }
        }
    }
}
</div></li><li class="list__item" id="z7an5p3_906"><p id="z7an5p3_925">The <code class="code" id="z7an5p3_926">kotlinOptions</code> DSL from the <code class="code" id="z7an5p3_927">KotlinCompilation</code> interface.</p></li><li class="list__item" id="z7an5p3_907"><p id="z7an5p3_928">The <code class="code" id="z7an5p3_929">kotlinOptions</code> DSL from the <code class="code" id="z7an5p3_930">KotlinNativeArtifactConfig</code> interface, the <code class="code" id="z7an5p3_931">KotlinNativeLink</code> class, and the <code class="code" id="z7an5p3_932">KotlinNativeLinkArtifactTask</code> class. Use the <code class="code" id="z7an5p3_933">toolOptions</code> DSL instead.</p></li><li class="list__item" id="z7an5p3_908"><p id="z7an5p3_934">The <code class="code" id="z7an5p3_935">dceOptions</code> DSL from the <code class="code" id="z7an5p3_936">KotlinJsDce</code> interface. Use the <code class="code" id="z7an5p3_937">toolOptions</code> DSL instead.</p></li></ul><p id="z7an5p3_903">For more information on how to specify compiler options in the Kotlin Gradle plugin, see <a href="gradle-compiler-options.html#how-to-define-options" id="z7an5p3_938" data-tooltip="Kotlin compilers have a number of options for tailoring the compiling process.">How to define options</a>.</p></section><section class="chapter"><h3 id="bumped-minimum-supported-agp-version" data-toc="bumped-minimum-supported-agp-version">Bumped minimum supported AGP version</h3><p id="z7an5p3_939">Starting with Kotlin 2.0.0, the minimum supported Android Gradle plugin version is 7.1.3.</p></section><section class="chapter"><h3 id="new-gradle-property-for-trying-the-latest-language-version" data-toc="new-gradle-property-for-trying-the-latest-language-version">New Gradle property for trying the latest language version</h3><p id="z7an5p3_940">Prior to Kotlin 2.0.0, we had the following Gradle property to try out the new K2 compiler: <code class="code" id="z7an5p3_944">kotlin.experimental.tryK2</code>. Now that the K2 compiler is enabled by default in Kotlin 2.0.0, we decided to evolve this property into a new form that you can use to try the latest language version in your projects: <code class="code" id="z7an5p3_945">kotlin.experimental.tryNext</code>. When you use this property in your <code class="code" id="z7an5p3_946">gradle.properties</code> file, the Kotlin Gradle plugin increments the language version to one above the default value for your Kotlin version. For example, in Kotlin 2.0.0, the default language version is 2.0, so the property configures language version 2.1.</p><p id="z7an5p3_941">This new Gradle property produces similar metrics in <a href="gradle-compilation-and-caches.html#build-reports" id="z7an5p3_947" data-tooltip="Build reports contain the durations of different compilation phases and any reasons why compilation couldn't be incremental. Use build reports to investigate performance issues when the compilation time is too long or when it differs for the same project.">build reports</a> as before with <code class="code" id="z7an5p3_948">kotlin.experimental.tryK2</code>. The language version configured is included in the output. For example:</p><div class="code-block" data-lang="none">
##### 'kotlin.experimental.tryNext' results #####
:app:compileKotlin: 2.1 language version
:lib:compileKotlin: 2.1 language version
##### 100% (2/2) tasks have been compiled with Kotlin 2.1 #####
</div><p id="z7an5p3_943">To learn more about how to enable build reports and their content, see <a href="gradle-compilation-and-caches.html#build-reports" id="z7an5p3_949" data-tooltip="Build reports contain the durations of different compilation phases and any reasons why compilation couldn't be incremental. Use build reports to investigate performance issues when the compilation time is too long or when it differs for the same project.">Build reports</a>.</p></section><section class="chapter"><h3 id="new-json-output-format-for-build-reports" data-toc="new-json-output-format-for-build-reports">New JSON output format for build reports</h3><p id="z7an5p3_950">In Kotlin 1.7.0, we introduced build reports to help track compiler performance. Over time, we've added more metrics to make these reports even more detailed and helpful when investigating performance issues. Previously, the only output format for a local file was the <code class="code" id="z7an5p3_958">*.txt</code> format. In Kotlin 2.0.0, we support the JSON output format to make it even easier to analyze using other tools.</p><p id="z7an5p3_951">To configure JSON output format for your build reports, declare the following properties in your <code class="code" id="z7an5p3_959">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.build.report.output=json

// The directory to store your build reports
kotlin.build.report.json.directory=my/directory/path
</div><p id="z7an5p3_953">Alternatively, you can run the following command:</p><div class="code-block" data-lang="bash">
./gradlew assemble -Pkotlin.build.report.output=json -Pkotlin.build.report.json.directory=&quot;my/directory/path&quot;
</div><p id="z7an5p3_955">Once configured, Gradle generates your build reports in the directory that you specify with the name: <code class="code" id="z7an5p3_960">${project_name}-date-time-&lt;sequence_number&gt;.json</code>.</p><p id="z7an5p3_956">Here's an example snippet from a build report with JSON output format that contains build metrics and aggregated metrics:</p><div class="code-block" data-lang="json">
&quot;buildOperationRecord&quot;: [
    {
     &quot;path&quot;: &quot;:lib:compileKotlin&quot;,
      &quot;classFqName&quot;: &quot;org.jetbrains.kotlin.gradle.tasks.KotlinCompile_Decorated&quot;,
      &quot;startTimeMs&quot;: 1714730820601,
      &quot;totalTimeMs&quot;: 2724,
      &quot;buildMetrics&quot;: {
        &quot;buildTimes&quot;: {
          &quot;buildTimesNs&quot;: {
            &quot;CLEAR_OUTPUT&quot;: 713417,
            &quot;SHRINK_AND_SAVE_CURRENT_CLASSPATH_SNAPSHOT_AFTER_COMPILATION&quot;: 19699333,
            &quot;IR_TRANSLATION&quot;: 281000000,
            &quot;NON_INCREMENTAL_LOAD_CURRENT_CLASSPATH_SNAPSHOT&quot;: 14088042,
            &quot;CALCULATE_OUTPUT_SIZE&quot;: 1301500,
            &quot;GRADLE_TASK&quot;: 2724000000,
            &quot;COMPILER_INITIALIZATION&quot;: 263000000,
            &quot;IR_GENERATION&quot;: 74000000,
…
          }
        }
…
 &quot;aggregatedMetrics&quot;: {
    &quot;buildTimes&quot;: {
      &quot;buildTimesNs&quot;: {
        &quot;CLEAR_OUTPUT&quot;: 782667,
        &quot;SHRINK_AND_SAVE_CURRENT_CLASSPATH_SNAPSHOT_AFTER_COMPILATION&quot;: 22031833,
        &quot;IR_TRANSLATION&quot;: 333000000,
        &quot;NON_INCREMENTAL_LOAD_CURRENT_CLASSPATH_SNAPSHOT&quot;: 14890292,
        &quot;CALCULATE_OUTPUT_SIZE&quot;: 2370750,
        &quot;GRADLE_TASK&quot;: 3234000000,
        &quot;COMPILER_INITIALIZATION&quot;: 292000000,
        &quot;IR_GENERATION&quot;: 89000000,
…
      }
    }
</div></section><section class="chapter"><h3 id="kapt-configurations-inherit-annotation-processors-from-superconfigurations" data-toc="kapt-configurations-inherit-annotation-processors-from-superconfigurations">kapt configurations inherit annotation processors from superconfigurations</h3><p id="z7an5p3_961">Prior to Kotlin 2.0.0, if you wanted to define a common set of annotation processors in a separate Gradle configuration and extend this configuration in kapt-specific configurations for your subprojects, kapt would skip annotation processing because it couldn't find any annotation processors. In Kotlin 2.0.0, kapt can successfully detect that there are indirect dependencies on your annotation processors.</p><p id="z7an5p3_962">As an example, for a subproject using <a href="https://dagger.dev/" id="z7an5p3_966" data-external="true" rel="noopener noreferrer" target="_blank">Dagger</a>, in your <code class="code" id="z7an5p3_967">build.gradle(.kts)</code> file, use the following configuration:</p><div class="code-block" data-lang="kotlin">
val commonAnnotationProcessors by configurations.creating
configurations.named(&quot;kapt&quot;) { extendsFrom(commonAnnotationProcessors) }

dependencies {
    implementation(&quot;com.google.dagger:dagger:2.48.1&quot;)
    commonAnnotationProcessors(&quot;com.google.dagger:dagger-compiler:2.48.1&quot;)
}
</div><p id="z7an5p3_964">In this example, the <code class="code" id="z7an5p3_968">commonAnnotationProcessors</code> Gradle configuration is your common configuration for annotation processing that you want to be used for all your projects. You use the <a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:extendsFrom" id="z7an5p3_969" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_971">extendsFrom()</code></a> method to add &quot;commonAnnotationProcessors&quot; as a superconfiguration. kapt sees that the <code class="code" id="z7an5p3_970">commonAnnotationProcessors</code> Gradle configuration has a dependency on the Dagger annotation processor. Therefore, kapt includes the Dagger annotation processor in its configuration for annotation processing.</p><p id="z7an5p3_965">Thanks to Christoph Loy for the <a href="https://github.com/JetBrains/kotlin/pull/5198" id="z7an5p3_972" data-external="true" rel="noopener noreferrer" target="_blank">implementation</a>!</p></section><section class="chapter"><h3 id="kotlin-gradle-plugin-no-longer-uses-deprecated-gradle-conventions" data-toc="kotlin-gradle-plugin-no-longer-uses-deprecated-gradle-conventions">Kotlin Gradle plugin no longer uses deprecated Gradle conventions</h3><p id="z7an5p3_973">Prior to Kotlin 2.0.0, if you used Gradle 8.2 or higher, the Kotlin Gradle plugin incorrectly used Gradle conventions that had been deprecated in Gradle 8.2. This led to Gradle reporting build deprecations. In Kotlin 2.0.0, the Kotlin Gradle plugin has been updated to no longer trigger these deprecation warnings when you use Gradle 8.2 or higher.</p></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><p id="z7an5p3_974">This release brings further stability to the Kotlin standard library and makes even more existing functions common for all platforms:</p><ul class="list _bullet" id="z7an5p3_975"><li class="list__item" id="z7an5p3_981"><p id="z7an5p3_986"><a href="#stable-replacement-of-the-enum-class-values-generic-function" id="z7an5p3_987" data-tooltip="In Kotlin 2.0.0, the enumEntries&lt;T&gt;() function becomes Stable. The enumEntries&lt;T&gt;() function is a replacement for the generic enumValues&lt;T&gt;() function. The new function returns a list of all enum entries for the given enum type T. The entries property for enum…">Stable replacement of the enum class values generic function</a></p></li><li class="list__item" id="z7an5p3_982"><p id="z7an5p3_988"><a href="#stable-autocloseable-interface" id="z7an5p3_989" data-tooltip="In Kotlin 2.0.0, the common AutoCloseable interface becomes Stable. It allows you to easily close resources and includes a couple of useful functions:">Stable AutoCloseable interface</a></p></li><li class="list__item" id="z7an5p3_983"><p id="z7an5p3_990"><a href="#common-protected-property-abstractmutablelist-modcount" id="z7an5p3_991" data-tooltip="In this release, the modCount protectedproperty of the AbstractMutableList interface becomes common. Previously, the modCount property was available on each platform but not for the common target. Now, you can create custom implementations of AbstractMutableList and access the…">Common protected property AbstractMutableList.modCount</a></p></li><li class="list__item" id="z7an5p3_984"><p id="z7an5p3_992"><a href="#common-protected-function-abstractmutablelist-removerange" id="z7an5p3_993" data-tooltip="In this release, the removeRange() protectedfunction of the AbstractMutableList interface becomes common. Previously, it was available on each platform but not for the common target. Now, you can create custom implementations of AbstractMutableList and override the function in…">Common protected function AbstractMutableList.removeRange</a></p></li><li class="list__item" id="z7an5p3_985"><p id="z7an5p3_994"><a href="#common-string-tochararray-destination-function" id="z7an5p3_995" data-tooltip="This release introduces a common String.toCharArray(destination) function. Previously, it was only available on the JVM.">Common String.toCharArray(destination)</a></p></li></ul><section class="chapter"><h3 id="stable-replacement-of-the-enum-class-values-generic-function" data-toc="stable-replacement-of-the-enum-class-values-generic-function">Stable replacement of the enum class values generic function</h3><p id="z7an5p3_996">In Kotlin 2.0.0, the <code class="code" id="z7an5p3_1000">enumEntries&lt;T&gt;()</code> function becomes <a href="components-stability.html#stability-levels-explained" id="z7an5p3_1001" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Stable</a>. The <code class="code" id="z7an5p3_1002">enumEntries&lt;T&gt;()</code> function is a replacement for the generic <code class="code" id="z7an5p3_1003">enumValues&lt;T&gt;()</code> function. The new function returns a list of all enum entries for the given enum type <code class="code" id="z7an5p3_1004">T</code>. The <code class="code" id="z7an5p3_1005">entries</code> property for enum classes was previously introduced and also stabilized to replace the synthetic <code class="code" id="z7an5p3_1006">values()</code> function. For more information about the entries property, see <a href="whatsnew1820.html#a-modern-and-performant-replacement-of-the-enum-class-values-function" id="z7an5p3_1007" data-tooltip="This feature is Experimental. It may be dropped or changed at any time. Opt-in is required (see details below). Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">What's new in Kotlin 1.8.20</a>.</p><aside class="prompt" data-type="tip" data-title="" id="z7an5p3_997"><p id="z7an5p3_1008">The <code class="code" id="z7an5p3_1009">enumValues&lt;T&gt;()</code> function is still supported, but we recommend that you use the <code class="code" id="z7an5p3_1010">enumEntries&lt;T&gt;()</code> function instead because it has less of a performance impact. Every time you call <code class="code" id="z7an5p3_1011">enumValues&lt;T&gt;()</code>, a new array is created, whereas whenever you call <code class="code" id="z7an5p3_1012">enumEntries&lt;T&gt;()</code>, the same list is returned each time, which is far more efficient.</p></aside><p id="z7an5p3_998">For example:</p><div class="code-block" data-lang="kotlin">
enum class RGB { RED, GREEN, BLUE }

inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() {
    print(enumEntries&lt;T&gt;().joinToString { it.name })
}

printAllValues&lt;RGB&gt;()
// RED, GREEN, BLUE
</div></section><section class="chapter"><h3 id="stable-autocloseable-interface" data-toc="stable-autocloseable-interface">Stable AutoCloseable interface</h3><p id="z7an5p3_1013">In Kotlin 2.0.0, the common <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-auto-closeable/" id="z7an5p3_1017" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_1019">AutoCloseable</code></a> interface becomes <a href="components-stability.html#stability-levels-explained" id="z7an5p3_1018" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Stable</a>. It allows you to easily close resources and includes a couple of useful functions:</p><ul class="list _bullet" id="z7an5p3_1014"><li class="list__item" id="z7an5p3_1020"><p id="z7an5p3_1022">The <code class="code" id="z7an5p3_1023">use()</code> extension function, which executes a given block function on the selected resource and then closes it down correctly, whether an exception is thrown or not.</p></li><li class="list__item" id="z7an5p3_1021"><p id="z7an5p3_1024">The <code class="code" id="z7an5p3_1025">AutoCloseable()</code> constructor function, which creates instances of the <code class="code" id="z7an5p3_1026">AutoCloseable</code> interface.</p></li></ul><p id="z7an5p3_1015">In the example below, we define the <code class="code" id="z7an5p3_1027">XMLWriter</code> interface and assume that there is a resource that implements it. For example, this resource could be a class that opens a file, writes XML content, and then closes it:</p><div class="code-block" data-lang="kotlin">
interface XMLWriter {
    fun document(encoding: String, version: String, content: XMLWriter.() -&gt; Unit)
    fun element(name: String, content: XMLWriter.() -&gt; Unit)
    fun attribute(name: String, value: String)
    fun text(value: String)

    fun flushAndClose()
}

fun writeBooksTo(writer: XMLWriter) {
    val autoCloseable = AutoCloseable { writer.flushAndClose() }
    autoCloseable.use {
        writer.document(encoding = &quot;UTF-8&quot;, version = &quot;1.0&quot;) {
            element(&quot;bookstore&quot;) {
                element(&quot;book&quot;) {
                    attribute(&quot;category&quot;, &quot;fiction&quot;)
                    element(&quot;title&quot;) { text(&quot;Harry Potter and the Prisoner of Azkaban&quot;) }
                    element(&quot;author&quot;) { text(&quot;J. K. Rowling&quot;) }
                    element(&quot;year&quot;) { text(&quot;1999&quot;) }
                    element(&quot;price&quot;) { text(&quot;29.99&quot;) }
                }
                element(&quot;book&quot;) {
                    attribute(&quot;category&quot;, &quot;programming&quot;)
                    element(&quot;title&quot;) { text(&quot;Kotlin in Action&quot;) }
                    element(&quot;author&quot;) { text(&quot;Dmitry Jemerov&quot;) }
                    element(&quot;author&quot;) { text(&quot;Svetlana Isakova&quot;) }
                    element(&quot;year&quot;) { text(&quot;2017&quot;) }
                    element(&quot;price&quot;) { text(&quot;25.19&quot;) }
                }
            }
        }
    }
}
</div></section><section class="chapter"><h3 id="common-protected-property-abstractmutablelist-modcount" data-toc="common-protected-property-abstractmutablelist-modcount">Common protected property AbstractMutableList.modCount</h3><p id="z7an5p3_1028">In this release, the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-abstract-mutable-list/mod-count.html" id="z7an5p3_1031" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_1036">modCount</code></a> <code class="code" id="z7an5p3_1032">protected</code>property of the <code class="code" id="z7an5p3_1033">AbstractMutableList</code> interface becomes common. Previously, the <code class="code" id="z7an5p3_1034">modCount</code> property was available on each platform but not for the common target. Now, you can create custom implementations of <code class="code" id="z7an5p3_1035">AbstractMutableList</code> and access the property in common code.</p><p id="z7an5p3_1029">The property keeps track of the number of structural modifications made to the collection. This includes operations that change the collection size or alter the list in a way that may cause iterations in progress to return incorrect results.</p><p id="z7an5p3_1030">You can use the <code class="code" id="z7an5p3_1037">modCount</code> property to register and detect concurrent modifications when implementing a custom list.</p></section><section class="chapter"><h3 id="common-protected-function-abstractmutablelist-removerange" data-toc="common-protected-function-abstractmutablelist-removerange">Common protected function AbstractMutableList.removeRange</h3><p id="z7an5p3_1038">In this release, the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-abstract-mutable-list/remove-range.html" id="z7an5p3_1040" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_1044">removeRange()</code></a> <code class="code" id="z7an5p3_1041">protected</code>function of the <code class="code" id="z7an5p3_1042">AbstractMutableList</code> interface becomes common. Previously, it was available on each platform but not for the common target. Now, you can create custom implementations of <code class="code" id="z7an5p3_1043">AbstractMutableList</code> and override the function in common code.</p><p id="z7an5p3_1039">The function removes elements from this list following the specified range. By overriding this function, you can take advantage of the custom implementations and improve the performance of the list operation.</p></section><section class="chapter"><h3 id="common-string-tochararray-destination-function" data-toc="common-string-tochararray-destination-function">Common String.toCharArray(destination) function</h3><p id="z7an5p3_1045">This release introduces a common <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-char-array.html" id="z7an5p3_1048" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_1049">String.toCharArray(destination)</code></a> function. Previously, it was only available on the JVM.</p><p id="z7an5p3_1046">Let's compare it with the existing <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-char-array.html" id="z7an5p3_1050" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7an5p3_1055">String.toCharArray()</code></a> function. It creates a new <code class="code" id="z7an5p3_1051">CharArray</code> that contains characters from the specified string. The new common <code class="code" id="z7an5p3_1052">String.toCharArray(destination)</code> function, however, moves <code class="code" id="z7an5p3_1053">String</code> characters into an existing destination <code class="code" id="z7an5p3_1054">CharArray</code>. This is useful if you already have a buffer that you want to fill:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
    val myString = &quot;Kotlin is awesome!&quot;
    val destinationArray = CharArray(myString.length)

    // Convert the string and store it in the destinationArray:
    myString.toCharArray(destinationArray)

    for (char in destinationArray) {
        print(&quot;$char &quot;)
        // K o t l i n   i s   a w e s o m e ! 
    }
}
</div></section></section><section class="chapter"><h2 id="install-kotlin-2-0-0" data-toc="install-kotlin-2-0-0">Install Kotlin 2.0.0</h2><p id="z7an5p3_1056">Starting from IntelliJ IDEA 2023.3 and Android Studio Iguana (2023.2.1) Canary 15, the Kotlin plugin is distributed as a bundled plugin included in your IDE. This means that you can't install the plugin from JetBrains Marketplace anymore.</p><p id="z7an5p3_1057">To update to the new Kotlin version, <a href="releases.html#update-to-a-new-kotlin-version" id="z7an5p3_1058" data-tooltip="To upgrade your project to a new release, you need to update your build script file. For example, to update to Kotlin 2.1.20, change the version of the Kotlin Gradle plugin in your build.gradle(.kts) file:">change the Kotlin version</a> to 2.0.0 in your build scripts.</p></section><div class="last-modified">19 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew2020.html" class="navigation-links__prev">What's new in Kotlin 2.0.20</a><a href="whatsnew1920.html" class="navigation-links__next">What's new in Kotlin 1.9.20</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>