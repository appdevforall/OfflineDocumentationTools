<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-18T20:47:08.656131992"><title>Numbers | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"integer-types","level":0,"title":"Integer types","anchor":"#integer-types"},{"id":"floating-point-types","level":0,"title":"Floating-point types","anchor":"#floating-point-types"},{"id":"literal-constants-for-numbers","level":0,"title":"Literal constants for numbers","anchor":"#literal-constants-for-numbers"},{"id":"boxing-and-caching-numbers-on-the-java-virtual-machine","level":0,"title":"Boxing and caching numbers on the Java Virtual Machine","anchor":"#boxing-and-caching-numbers-on-the-java-virtual-machine"},{"id":"explicit-number-conversions","level":0,"title":"Explicit number conversions","anchor":"#explicit-number-conversions"},{"id":"reasoning-against-implicit-conversions","level":1,"title":"Reasoning against implicit conversions","anchor":"#reasoning-against-implicit-conversions"},{"id":"operations-on-numbers","level":0,"title":"Operations on numbers","anchor":"#operations-on-numbers"},{"id":"division-of-integers","level":1,"title":"Division of integers","anchor":"#division-of-integers"},{"id":"bitwise-operations","level":1,"title":"Bitwise operations","anchor":"#bitwise-operations"},{"id":"floating-point-numbers-comparison","level":1,"title":"Floating-point numbers comparison","anchor":"#floating-point-numbers-comparison"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Numbers | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/numbers.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Numbers | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/numbers.html#webpage",
    "url": "writerside-documentation/numbers.html",
    "name": "Numbers | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="numbers" data-main-title="Numbers" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts///Types///Basic types"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="numbers" id="numbers.md">Numbers</h1><section class="chapter"><h2 id="integer-types" data-toc="integer-types">Integer types</h2><p id="z9gr2je_8">Kotlin provides a set of built-in types that represent numbers. <br> For integer numbers, there are four types with different sizes and value ranges:</p><div class="table-wrapper"><table class="wide" id="z9gr2je_9"><thead><tr class="ijRowHead" id="z9gr2je_14"><th id="z9gr2je_19"><p>Type</p></th><th id="z9gr2je_20"><p>Size (bits)</p></th><th id="z9gr2je_21"><p>Min value</p></th><th id="z9gr2je_22"><p>Max value</p></th></tr></thead><tbody><tr id="z9gr2je_15"><td id="z9gr2je_23"><p><code class="code" id="z9gr2je_27">Byte</code></p></td><td id="z9gr2je_24"><p>8</p></td><td id="z9gr2je_25"><p>-128</p></td><td id="z9gr2je_26"><p>127</p></td></tr><tr id="z9gr2je_16"><td id="z9gr2je_28"><p><code class="code" id="z9gr2je_32">Short</code></p></td><td id="z9gr2je_29"><p>16</p></td><td id="z9gr2je_30"><p>-32768</p></td><td id="z9gr2je_31"><p>32767</p></td></tr><tr id="z9gr2je_17"><td id="z9gr2je_33"><p><code class="code" id="z9gr2je_37">Int</code></p></td><td id="z9gr2je_34"><p>32</p></td><td id="z9gr2je_35"><p>-2,147,483,648 (-2<sup class="superscript" id="z9gr2je_38">31</sup>)</p></td><td id="z9gr2je_36"><p>2,147,483,647 (2<sup class="superscript" id="z9gr2je_39">31</sup> - 1)</p></td></tr><tr id="z9gr2je_18"><td id="z9gr2je_40"><p><code class="code" id="z9gr2je_44">Long</code></p></td><td id="z9gr2je_41"><p>64</p></td><td id="z9gr2je_42"><p>-9,223,372,036,854,775,808 (-2<sup class="superscript" id="z9gr2je_45">63</sup>)</p></td><td id="z9gr2je_43"><p>9,223,372,036,854,775,807 (2<sup class="superscript" id="z9gr2je_46">63</sup> - 1)</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="z9gr2je_10"><p id="z9gr2je_47">In addition to signed integer types, Kotlin also provides unsigned integer types. As unsigned integers are aimed at a different set of use cases, they are covered separately. See <a href="unsigned-integer-types.html" id="z9gr2je_48" data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:">Unsigned integer types</a>.</p></aside><p id="z9gr2je_11">When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value starting from <code class="code" id="z9gr2je_49">Int</code>. If it doesn't exceed the range of <code class="code" id="z9gr2je_50">Int</code>, the type is <code class="code" id="z9gr2je_51">Int</code>. If it does exceed that range, the type is <code class="code" id="z9gr2je_52">Long</code>. To specify the <code class="code" id="z9gr2je_53">Long</code> value explicitly, append the suffix <code class="code" id="z9gr2je_54">L</code> to the value. To use the <code class="code" id="z9gr2je_55">Byte</code> or <code class="code" id="z9gr2je_56">Short</code> type, specify it explicitly in the declaration. Explicit type specification triggers the compiler to check that the value doesn't exceed the range of the specified type.</p><div class="code-block" data-lang="kotlin">
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
</div></section><section class="chapter"><h2 id="floating-point-types" data-toc="floating-point-types">Floating-point types</h2><p id="z9gr2je_57">For real numbers, Kotlin provides floating-point types <code class="code" id="z9gr2je_68">Float</code> and <code class="code" id="z9gr2je_69">Double</code> that adhere to the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="z9gr2je_70" data-external="true" rel="noopener noreferrer" target="_blank">IEEE 754 standard</a>. <code class="code" id="z9gr2je_71">Float</code> reflects the IEEE 754 <span class="emphasis" id="z9gr2je_72">single precision</span>, while <code class="code" id="z9gr2je_73">Double</code> reflects <span class="emphasis" id="z9gr2je_74">double precision</span>.</p><p id="z9gr2je_58">These types differ in their size and provide storage for floating-point numbers with different precision:</p><div class="table-wrapper"><table class="wide" id="z9gr2je_59"><thead><tr class="ijRowHead" id="z9gr2je_75"><th id="z9gr2je_78"><p>Type</p></th><th id="z9gr2je_79"><p>Size (bits)</p></th><th id="z9gr2je_80"><p>Significant bits</p></th><th id="z9gr2je_81"><p>Exponent bits</p></th><th id="z9gr2je_82"><p>Decimal digits</p></th></tr></thead><tbody><tr id="z9gr2je_76"><td id="z9gr2je_83"><p><code class="code" id="z9gr2je_88">Float</code></p></td><td id="z9gr2je_84"><p>32</p></td><td id="z9gr2je_85"><p>24</p></td><td id="z9gr2je_86"><p>8</p></td><td id="z9gr2je_87"><p>6-7</p></td></tr><tr id="z9gr2je_77"><td id="z9gr2je_89"><p><code class="code" id="z9gr2je_94">Double</code></p></td><td id="z9gr2je_90"><p>64</p></td><td id="z9gr2je_91"><p>53</p></td><td id="z9gr2je_92"><p>11</p></td><td id="z9gr2je_93"><p>15-16</p></td></tr></tbody></table></div><p id="z9gr2je_60">You can initialize <code class="code" id="z9gr2je_95">Double</code> and <code class="code" id="z9gr2je_96">Float</code> variables only with numbers that have a fractional part. Separate the fractional part from the integer part by a period (<code class="code" id="z9gr2je_97">.</code>)</p><p id="z9gr2je_61">For variables initialized with fractional numbers, the compiler infers the <code class="code" id="z9gr2je_98">Double</code> type:</p><div class="code-block" data-lang="kotlin">
val pi = 3.14          // Double

val one: Double = 1    // Int is inferred
// Initializer type mismatch

val oneDouble = 1.0    // Double
</div><p id="z9gr2je_63">To explicitly specify the <code class="code" id="z9gr2je_99">Float</code> type for a value, add the suffix <code class="code" id="z9gr2je_100">f</code> or <code class="code" id="z9gr2je_101">F</code>. If a value provided in this way contains more than 7 decimal digits, it is rounded:</p><div class="code-block" data-lang="kotlin">
val e = 2.7182818284          // Double
val eFloat = 2.7182818284f    // Float, actual value is 2.7182817
</div><p id="z9gr2je_65">Unlike in some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a <code class="code" id="z9gr2je_102">Double</code> parameter can be called only on <code class="code" id="z9gr2je_103">Double</code> values, but not <code class="code" id="z9gr2je_104">Float</code>, <code class="code" id="z9gr2je_105">Int</code>, or other numeric values:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
//sampleStart
    fun printDouble(x: Double) { print(x) }

    val x = 1.0
    val xInt = 1    
    val xFloat = 1.0f 

    printDouble(x)
    
    printDouble(xInt)   
    // Argument type mismatch
    
    printDouble(xFloat)
    // Argument type mismatch
//sampleEnd
}
</div><p id="z9gr2je_67">To convert numeric values to different types, use <a href="#explicit-number-conversions" id="z9gr2je_106" data-tooltip="Due to different representations, number types are not subtypes of each other. As a consequence, smaller types are not implicitly converted to bigger types and vice versa. For example, assigning a value of type Byte to an Int variable requires an explicit conversion:">explicit conversions</a>.</p></section><section class="chapter"><h2 id="literal-constants-for-numbers" data-toc="literal-constants-for-numbers">Literal constants for numbers</h2><p id="z9gr2je_107">There are several kinds of literal constants for integral values:</p><ul class="list _bullet" id="z9gr2je_108"><li class="list__item" id="z9gr2je_115"><p id="z9gr2je_119">Decimals: <code class="code" id="z9gr2je_120">123</code></p></li><li class="list__item" id="z9gr2je_116"><p id="z9gr2je_121">Longs, ending with the capital <code class="code" id="z9gr2je_122">L</code>: <code class="code" id="z9gr2je_123">123L</code></p></li><li class="list__item" id="z9gr2je_117"><p id="z9gr2je_124">Hexadecimals: <code class="code" id="z9gr2je_125">0x0F</code></p></li><li class="list__item" id="z9gr2je_118"><p id="z9gr2je_126">Binaries: <code class="code" id="z9gr2je_127">0b00001011</code></p></li></ul><aside class="prompt" data-type="note" data-title="" id="z9gr2je_109"><p id="z9gr2je_128">Octal literals are not supported in Kotlin.</p></aside><p id="z9gr2je_110">Kotlin also supports conventional notation for floating-point numbers:</p><ul class="list _bullet" id="z9gr2je_111"><li class="list__item" id="z9gr2je_129"><p id="z9gr2je_131">Doubles (default when the fractional part does not end with a letter): <code class="code" id="z9gr2je_132">123.5</code>, <code class="code" id="z9gr2je_133">123.5e10</code></p></li><li class="list__item" id="z9gr2je_130"><p id="z9gr2je_134">Floats, ending with the letter <code class="code" id="z9gr2je_135">f</code> or <code class="code" id="z9gr2je_136">F</code>: <code class="code" id="z9gr2je_137">123.5f</code></p></li></ul><p id="z9gr2je_112">You can use underscores to make number constants more readable:</p><div class="code-block" data-lang="kotlin">
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
val bigFractional = 1_234_567.7182818284
</div><aside class="prompt" data-type="tip" data-title="" id="z9gr2je_114"><p id="z9gr2je_138">There are also special suffixes for unsigned integer literals. <br> Read more about <a href="unsigned-integer-types.html" id="z9gr2je_140" data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:">literals for unsigned integer types</a>.</p></aside></section><section class="chapter"><h2 id="boxing-and-caching-numbers-on-the-java-virtual-machine" data-toc="boxing-and-caching-numbers-on-the-java-virtual-machine">Boxing and caching numbers on the Java Virtual Machine</h2><p id="z9gr2je_141">The way the JVM stores numbers can make your code behave counterintuitively because of the cache used by default for small (byte-sized) numbers.</p><p id="z9gr2je_142">The JVM stores numbers as primitive types: <code class="code" id="z9gr2je_148">int</code>, <code class="code" id="z9gr2je_149">double</code>, and so on. When you use <a href="generics.html" id="z9gr2je_150" data-tooltip="Classes in Kotlin can have type parameters, just like in Java:">generic types</a> or create a nullable number reference such as <code class="code" id="z9gr2je_151">Int?</code>, numbers are boxed in Java classes such as <code class="code" id="z9gr2je_152">Integer</code> or <code class="code" id="z9gr2je_153">Double</code>.</p><p id="z9gr2je_143">The JVM applies a <a href="https://docs.oracle.com/javase/specs/jls/se22/html/jls-5.html#jls-5.1.7" id="z9gr2je_154" data-external="true" rel="noopener noreferrer" target="_blank">memory optimization technique</a> to <code class="code" id="z9gr2je_155">Integer</code> and other objects that represent numbers between <code class="code" id="z9gr2je_156">&minus;128</code> and <code class="code" id="z9gr2je_157">127</code>. All nullable references to such objects refer to the same cached object. For example, nullable objects in the following code are <a href="equality.html#referential-equality" id="z9gr2je_158" data-tooltip="Referential equality verifies the memory addresses of two objects to determine if they are the same instance.">referentially equal</a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a
    
    println(boxedA === anotherBoxedA) // true
//sampleEnd
}
</div><p id="z9gr2je_145">For numbers outside this range, the nullable objects are different but <a href="equality.html#structural-equality" id="z9gr2je_159" data-tooltip="Structural equality verifies if two objects have the same content or structure. Structural equality is checked by the == operation and its negated counterpart !=. By convention, an expression like a == b is translated to:">structurally equal</a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val b: Int = 10000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    
    println(boxedB === anotherBoxedB) // false
    println(boxedB == anotherBoxedB) // true
//sampleEnd
}
</div><p id="z9gr2je_147">For this reason, Kotlin warns about using referential equality with boxable numbers and literals with the following message: <code class="code" id="z9gr2je_160">&quot;Identity equality for arguments of types ... and ... is prohibited.&quot;</code> When comparing <code class="code" id="z9gr2je_161">Int</code>, <code class="code" id="z9gr2je_162">Short</code>, <code class="code" id="z9gr2je_163">Long</code>, and <code class="code" id="z9gr2je_164">Byte</code> types (as well as <code class="code" id="z9gr2je_165">Char</code> and <code class="code" id="z9gr2je_166">Boolean</code>), use structural equality checks to get consistent results.</p></section><section class="chapter"><h2 id="explicit-number-conversions" data-toc="explicit-number-conversions">Explicit number conversions</h2><p id="z9gr2je_167">Due to different representations, number types <span class="emphasis" id="z9gr2je_174">are not subtypes</span> of each other. As a consequence, smaller types are <span class="emphasis" id="z9gr2je_175">not</span> implicitly converted to bigger types and vice versa. For example, assigning a value of type <code class="code" id="z9gr2je_176">Byte</code> to an <code class="code" id="z9gr2je_177">Int</code> variable requires an explicit conversion:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val byte: Byte = 1
    // OK, literals are checked statically
    
    val intAssignedByte: Int = byte 
    // Initializer type mismatch
    
    val intConvertedByte: Int = byte.toInt()
    
    println(intConvertedByte)
//sampleEnd
}
</div><p id="z9gr2je_169">All number types support conversions to other types:</p><ul class="list _bullet" id="z9gr2je_170"><li class="list__item" id="z9gr2je_178"><p id="z9gr2je_184"><code class="code" id="z9gr2je_185">toByte(): Byte</code> (deprecated for <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-float/to-byte.html" id="z9gr2je_186" data-external="true" rel="noopener noreferrer" target="_blank">Float</a> and <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-double/to-byte.html" id="z9gr2je_187" data-external="true" rel="noopener noreferrer" target="_blank">Double</a>)</p></li><li class="list__item" id="z9gr2je_179"><p id="z9gr2je_188"><code class="code" id="z9gr2je_189">toShort(): Short</code></p></li><li class="list__item" id="z9gr2je_180"><p id="z9gr2je_190"><code class="code" id="z9gr2je_191">toInt(): Int</code></p></li><li class="list__item" id="z9gr2je_181"><p id="z9gr2je_192"><code class="code" id="z9gr2je_193">toLong(): Long</code></p></li><li class="list__item" id="z9gr2je_182"><p id="z9gr2je_194"><code class="code" id="z9gr2je_195">toFloat(): Float</code></p></li><li class="list__item" id="z9gr2je_183"><p id="z9gr2je_196"><code class="code" id="z9gr2je_197">toDouble(): Double</code></p></li></ul><p id="z9gr2je_171">In many cases, there is no need for explicit conversion because the type is inferred from the context, and arithmetical operators are overloaded to handle conversions automatically. For example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
fun main() {
//sampleStart
    val l = 1L + 3       // Long + Int =&gt; Long
    println(l is Long)   // true
//sampleEnd
}
</div><section class="chapter"><h3 id="reasoning-against-implicit-conversions" data-toc="reasoning-against-implicit-conversions">Reasoning against implicit conversions</h3><p id="z9gr2je_198">Kotlin doesn't support implicit conversions because they can lead to unexpected behavior.</p><p id="z9gr2je_199">If numbers of different types were converted implicitly, we could sometimes lose equality and identity silently. For example, imagine if <code class="code" id="z9gr2je_201">Int</code> was a subtype of <code class="code" id="z9gr2je_202">Long</code>:</p><div class="code-block" data-lang="kotlin">
// Hypothetical code, does not actually compile:
val a: Int? = 1    // A boxed Int (java.lang.Integer)
val b: Long? = a   // Implicit conversion yields a boxed Long (java.lang.Long)
print(b == a)      // Prints &quot;false&quot; as Long.equals() checks not only the value but whether the other number is Long as well
</div></section></section><section class="chapter"><h2 id="operations-on-numbers" data-toc="operations-on-numbers">Operations on numbers</h2><p id="z9gr2je_203">Kotlin supports the standard set of arithmetical operations over numbers: <code class="code" id="z9gr2je_209">+</code>, <code class="code" id="z9gr2je_210">-</code>, <code class="code" id="z9gr2je_211">*</code>, <code class="code" id="z9gr2je_212">/</code>, <code class="code" id="z9gr2je_213">%</code>. They are declared as members of appropriate classes:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    println(1 + 2)
    println(2_500_000_000L - 1L)
    println(3.14 * 2.71)
    println(10.0 / 3)
//sampleEnd
}
</div><p id="z9gr2je_205">You can override these operators in custom number classes. See <a href="operator-overloading.html" id="z9gr2je_214" data-tooltip="Kotlin allows you to provide custom implementations for the predefined set of operators on types. These operators have predefined symbolic representation (like + or *) and precedence. To implement an operator, provide a member function or an extension function with a specific name…">Operator overloading</a> for details.</p><section class="chapter"><h3 id="division-of-integers" data-toc="division-of-integers">Division of integers</h3><p id="z9gr2je_215">Division between integer numbers always returns an integer number. Any fractional part is discarded.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val x = 5 / 2
    println(x == 2.5) 
    // Operator '==' cannot be applied to 'Int' and 'Double'
    
    println(x == 2)   
    // true
//sampleEnd
}
</div><p id="z9gr2je_217">This is true for a division between any two integer types:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val x = 5L / 2
    println (x == 2)
    // Error, as Long (x) cannot be compared to Int (2)
    
    println(x == 2L)
    // true
//sampleEnd
}
</div><p id="z9gr2je_219">To return a division result with the fractional part, explicitly convert one of the arguments to a floating-point type:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main() {
//sampleStart
    val x = 5 / 2.toDouble()
    println(x == 2.5)
//sampleEnd
}
</div></section><section class="chapter"><h3 id="bitwise-operations" data-toc="bitwise-operations">Bitwise operations</h3><p id="z9gr2je_221">Kotlin provides a set of <span class="emphasis" id="z9gr2je_225">bitwise operations</span> on integer numbers. They operate on the binary level directly with bits of the numbers' representation. Bitwise operations are represented by functions that can be called in infix form. They can be applied only to <code class="code" id="z9gr2je_226">Int</code> and <code class="code" id="z9gr2je_227">Long</code>:</p><div class="code-block" data-lang="kotlin">
fun main() {
//sampleStart
    val x = 1
    val xShiftedLeft = (x shl 2)
    println(xShiftedLeft)  
    // 4
    
    val xAnd = x and 0x000FF000
    println(xAnd)          
    // 0
//sampleEnd
}
</div><p id="z9gr2je_223">The complete list of bitwise operations:</p><ul class="list _bullet" id="z9gr2je_224"><li class="list__item" id="z9gr2je_228"><p id="z9gr2je_235"><code class="code" id="z9gr2je_236">shl(bits)</code> &ndash; signed shift left</p></li><li class="list__item" id="z9gr2je_229"><p id="z9gr2je_237"><code class="code" id="z9gr2je_238">shr(bits)</code> &ndash; signed shift right</p></li><li class="list__item" id="z9gr2je_230"><p id="z9gr2je_239"><code class="code" id="z9gr2je_240">ushr(bits)</code> &ndash; unsigned shift right</p></li><li class="list__item" id="z9gr2je_231"><p id="z9gr2je_241"><code class="code" id="z9gr2je_242">and(bits)</code> &ndash; bitwise <span class="control" id="z9gr2je_243">AND</span></p></li><li class="list__item" id="z9gr2je_232"><p id="z9gr2je_244"><code class="code" id="z9gr2je_245">or(bits)</code> &ndash; bitwise <span class="control" id="z9gr2je_246">OR</span></p></li><li class="list__item" id="z9gr2je_233"><p id="z9gr2je_247"><code class="code" id="z9gr2je_248">xor(bits)</code> &ndash; bitwise <span class="control" id="z9gr2je_249">XOR</span></p></li><li class="list__item" id="z9gr2je_234"><p id="z9gr2je_250"><code class="code" id="z9gr2je_251">inv()</code> &ndash; bitwise inversion</p></li></ul></section><section class="chapter"><h3 id="floating-point-numbers-comparison" data-toc="floating-point-numbers-comparison">Floating-point numbers comparison</h3><p id="z9gr2je_252">The operations on floating-point numbers discussed in this section are:</p><ul class="list _bullet" id="z9gr2je_253"><li class="list__item" id="z9gr2je_259"><p id="z9gr2je_262">Equality checks: <code class="code" id="z9gr2je_263">a == b</code> and <code class="code" id="z9gr2je_264">a != b</code></p></li><li class="list__item" id="z9gr2je_260"><p id="z9gr2je_265">Comparison operators: <code class="code" id="z9gr2je_266">a &lt; b</code>, <code class="code" id="z9gr2je_267">a &gt; b</code>, <code class="code" id="z9gr2je_268">a &lt;= b</code>, <code class="code" id="z9gr2je_269">a &gt;= b</code></p></li><li class="list__item" id="z9gr2je_261"><p id="z9gr2je_270">Range instantiation and range checks: <code class="code" id="z9gr2je_271">a..b</code>, <code class="code" id="z9gr2je_272">x in a..b</code>, <code class="code" id="z9gr2je_273">x !in a..b</code></p></li></ul><p id="z9gr2je_254">When the operands <code class="code" id="z9gr2je_274">a</code> and <code class="code" id="z9gr2je_275">b</code> are statically known to be <code class="code" id="z9gr2je_276">Float</code> or <code class="code" id="z9gr2je_277">Double</code> or their nullable counterparts (the type is declared or inferred or is a result of a <a href="typecasts.html#smart-casts" id="z9gr2je_278" data-tooltip="In most cases, you don't need to use explicit cast operators because the compiler automatically casts objects for you. This is called smart-casting. The compiler tracks the type checks and explicit casts for immutable values and inserts implicit (safe) casts automatically when…">smart cast</a>), the operations on the numbers and the range that they form follow the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="z9gr2je_279" data-external="true" rel="noopener noreferrer" target="_blank">IEEE 754 Standard for Floating-Point Arithmetic</a>.</p><p id="z9gr2je_255">However, to support generic use cases and provide total ordering, the behavior is different for operands that are <span class="control" id="z9gr2je_280">not</span> statically typed as floating-point numbers. For example, <code class="code" id="z9gr2je_281">Any</code>, <code class="code" id="z9gr2je_282">Comparable&lt;...&gt;</code>, or <code class="code" id="z9gr2je_283">Collection&lt;T&gt;</code> types. In this case, the operations use the <code class="code" id="z9gr2je_284">equals</code> and <code class="code" id="z9gr2je_285">compareTo</code> implementations for <code class="code" id="z9gr2je_286">Float</code> and <code class="code" id="z9gr2je_287">Double</code>. As a result:</p><ul class="list _bullet" id="z9gr2je_256"><li class="list__item" id="z9gr2je_288"><p id="z9gr2je_291"><code class="code" id="z9gr2je_292">NaN</code> is considered equal to itself</p></li><li class="list__item" id="z9gr2je_289"><p id="z9gr2je_293"><code class="code" id="z9gr2je_294">NaN</code> is considered greater than any other element including <code class="code" id="z9gr2je_295">POSITIVE_INFINITY</code></p></li><li class="list__item" id="z9gr2je_290"><p id="z9gr2je_296"><code class="code" id="z9gr2je_297">-0.0</code> is considered less than <code class="code" id="z9gr2je_298">0.0</code></p></li></ul><p id="z9gr2je_257">Here is an example that shows the difference in behavior between operands statically typed as floating-point numbers (<code class="code" id="z9gr2je_299">Double.NaN</code>) and operands <span class="control" id="z9gr2je_300">not</span> statically typed as floating-point numbers (<code class="code" id="z9gr2je_301">listOf(T)</code>).</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" id="kotlin-numbers-floating-comp">
fun main() {
    //sampleStart
    // Operand statically typed as floating-point number
    println(Double.NaN == Double.NaN)                 // false
    
    // Operand NOT statically typed as floating-point number
    // So NaN is equal to itself
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true

    // Operand statically typed as floating-point number
    println(0.0 == -0.0)                              // true
    
    // Operand NOT statically typed as floating-point number
    // So -0.0 is less than 0.0
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
</div></section></section><div class="last-modified">19 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="basic-types.html" class="navigation-links__prev">Basic types</a><a href="unsigned-integer-types.html" class="navigation-links__next">Unsigned integer types</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>