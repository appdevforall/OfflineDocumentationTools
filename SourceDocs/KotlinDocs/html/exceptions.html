<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-18T20:47:08.130948435"><title>Exceptions | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"throw-exceptions","level":0,"title":"Throw exceptions","anchor":"#throw-exceptions"},{"id":"throw-exceptions-with-precondition-functions","level":1,"title":"Throw exceptions with precondition functions","anchor":"#throw-exceptions-with-precondition-functions"},{"id":"handle-exceptions-using-try-catch-blocks","level":0,"title":"Handle exceptions using try-catch blocks","anchor":"#handle-exceptions-using-try-catch-blocks"},{"id":"the-finally-block","level":1,"title":"The finally block","anchor":"#the-finally-block"},{"id":"create-custom-exceptions","level":0,"title":"Create custom exceptions","anchor":"#create-custom-exceptions"},{"id":"the-nothing-type","level":0,"title":"The Nothing type","anchor":"#the-nothing-type"},{"id":"exception-classes","level":0,"title":"Exception classes","anchor":"#exception-classes"},{"id":"exception-hierarchy","level":1,"title":"Exception hierarchy","anchor":"#exception-hierarchy"},{"id":"stack-trace","level":0,"title":"Stack trace","anchor":"#stack-trace"},{"id":"exception-interoperability-with-java-swift-and-objective-c","level":0,"title":"Exception interoperability with Java, Swift, and Objective-C","anchor":"#exception-interoperability-with-java-swift-and-objective-c"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Exceptions | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/exceptions.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Exceptions | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/exceptions.html#webpage",
    "url": "writerside-documentation/exceptions.html",
    "name": "Exceptions | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="exceptions" data-main-title="Exceptions" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts///Control flow"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="exceptions" id="exceptions.md">Exceptions</h1><p id="aeooea_2">Exceptions help your code run more predictably, even when runtime errors occur that could disrupt program execution. Kotlin treats all exceptions as <span class="emphasis" id="aeooea_14">unchecked</span> by default. Unchecked exceptions simplify the exception handling process: you can catch exceptions, but you don't need to explicitly handle or <a href="java-to-kotlin-interop.html#checked-exceptions" id="aeooea_15" data-tooltip="Kotlin does not have checked exceptions. So, normally the Java signatures of Kotlin functions do not declare exceptions thrown. Thus, if you have a function in Kotlin like this:">declare</a> them.</p><aside class="prompt" data-type="tip" data-title="" id="aeooea_3"><p id="aeooea_16">Learn more about how Kotlin handles exceptions when interacting with Java, Swift, and Objective-C in the <a href="#exception-interoperability-with-java-swift-and-objective-c" id="aeooea_17" data-tooltip="Since Kotlin treats all exceptions as unchecked, it can lead to complications when such exceptions are called from languages that distinguish between checked and unchecked exceptions. To address this disparity in exception handling between Kotlin and languages like Java, Swift, and…">Exception interoperability with Java, Swift, and Objective-C</a> section.</p></aside><p id="aeooea_4">Working with exceptions consists of two primary actions:</p><ul class="list _bullet" id="aeooea_5"><li class="list__item" id="aeooea_18"><p id="aeooea_20"><span class="control" id="aeooea_21">Throwing exceptions:</span> indicate when a problem occurs.</p></li><li class="list__item" id="aeooea_19"><p id="aeooea_22"><span class="control" id="aeooea_23">Catching exceptions:</span> handle the unexpected exception manually by resolving the issue or notifying the developer or application user.</p></li></ul><p id="aeooea_6">Exceptions are represented by subclasses of the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-exception/" id="aeooea_24" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_30">Exception</code></a> class, which is a subclass of the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/" id="aeooea_25" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_31">Throwable</code></a> class. For more information about the hierarchy, see the <a href="#exception-hierarchy" id="aeooea_26" data-tooltip="The root of the Kotlin exception hierarchy is the Throwable class. It has two direct subclasses, Error and Exception:">Exception hierarchy</a> section. Since <code class="code" id="aeooea_27">Exception</code> is an <a href="inheritance.html" id="aeooea_28" data-tooltip="All classes in Kotlin have a common superclass, Any, which is the default superclass for a class with no supertypes declared:"><code class="code" id="aeooea_32">open class</code></a>, you can create <a href="#create-custom-exceptions" id="aeooea_29" data-tooltip="In Kotlin, you can define custom exceptions by creating classes that extend the built-in Exception class. This allows you to create more specific error types tailored to your application's needs.">custom exceptions</a> to suit your application's specific needs.</p><section class="chapter"><h2 id="throw-exceptions" data-toc="throw-exceptions">Throw exceptions</h2><p id="aeooea_33">You can manually throw exceptions with the <code class="code" id="aeooea_40">throw</code> keyword. Throwing an exception indicates that an unexpected runtime error has occurred in the code. Exceptions are <a href="classes.html#creating-instances-of-classes" id="aeooea_41" data-tooltip="To create an instance of a class, call the constructor as if it were a regular function. You can assign the created instance to a variable:">objects</a>, and throwing one creates an instance of an exception class.</p><p id="aeooea_34">You can throw an exception without any parameters:</p><div class="code-block" data-lang="kotlin">
throw IllegalArgumentException()
</div><p id="aeooea_36">To better understand the source of the problem, include additional information, such as a custom message and the original cause:</p><div class="code-block" data-lang="kotlin">
val cause = IllegalStateException(&quot;Original cause: illegal state&quot;)

// Throws an IllegalArgumentException if userInput is negative 
// Additionally, it shows the original cause, represented by the cause IllegalStateException
if (userInput &lt; 0) {
    throw IllegalArgumentException(&quot;Input must be non-negative&quot;, cause)
}
</div><p id="aeooea_38">In this example, an <code class="code" id="aeooea_42">IllegalArgumentException</code> is thrown when the user inputs a negative value. You can create custom error messages and keep the original cause (<code class="code" id="aeooea_43">cause</code>) of the exception, which will be included in the <a href="#stack-trace" id="aeooea_44" data-tooltip="The stack trace is a report generated by the runtime environment, used for debugging. It shows the sequence of function calls leading to a specific point in the program, especially where an error or exception occurred.">stack trace</a>.</p><section class="chapter"><h3 id="throw-exceptions-with-precondition-functions" data-toc="throw-exceptions-with-precondition-functions">Throw exceptions with precondition functions</h3><p id="aeooea_45">Kotlin offers additional ways to automatically throw exceptions using precondition functions. Precondition functions include:</p><div class="table-wrapper"><table class="wide" id="aeooea_46"><thead><tr class="ijRowHead" id="aeooea_51"><th id="aeooea_55"><p>Precondition function</p></th><th id="aeooea_56"><p>Use case</p></th><th id="aeooea_57"><p>Exception thrown</p></th></tr></thead><tbody><tr id="aeooea_52"><td id="aeooea_58"><p><a href="#require-function" id="aeooea_61" data-tooltip="Use the require() function to validate input arguments when they are crucial for the function's operation, and the function can't proceed if these arguments are invalid."><code class="code" id="aeooea_62">require()</code></a></p></td><td id="aeooea_59"><p>Checks user input validity</p></td><td id="aeooea_60"><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/" id="aeooea_63" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_64">IllegalArgumentException</code></a></p></td></tr><tr id="aeooea_53"><td id="aeooea_65"><p><a href="#check-function" id="aeooea_68" data-tooltip="Use the check() function to validate the state of an object or variable. If the check fails, it indicates a logic error that needs to be addressed."><code class="code" id="aeooea_69">check()</code></a></p></td><td id="aeooea_66"><p>Checks object or variable state validity</p></td><td id="aeooea_67"><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/" id="aeooea_70" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_71">IllegalStateException</code></a></p></td></tr><tr id="aeooea_54"><td id="aeooea_72"><p><a href="#error-function" id="aeooea_75" data-tooltip="The error() function is used to signal an illegal state or a condition in the code that logically should not occur. It's suitable for scenarios when you want to throw an exception intentionally in your code, such as when the code encounters an unexpected state. This function is…"><code class="code" id="aeooea_76">error()</code></a></p></td><td id="aeooea_73"><p>Indicates an illegal state or condition</p></td><td id="aeooea_74"><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/" id="aeooea_77" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_78">IllegalStateException</code></a></p></td></tr></tbody></table></div><p id="aeooea_47">These functions are suitable for situations where the program's flow cannot continue if specific conditions aren't met. This streamlines your code and makes handling these checks efficient.</p><section class="chapter"><h4 id="require-function" data-toc="require-function">require() function</h4><p id="aeooea_79">Use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" id="aeooea_83" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_84">require()</code></a> function to validate input arguments when they are crucial for the function's operation, and the function can't proceed if these arguments are invalid.</p><p id="aeooea_80">If the condition in <code class="code" id="aeooea_85">require()</code> is not met, it throws an <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/" id="aeooea_86" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_87">IllegalArgumentException</code></a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun getIndices(count: Int): List&lt;Int&gt; {
    require(count &gt;= 0) { &quot;Count must be non-negative. You set count to $count.&quot; }
    return List(count) { it + 1 }
}

fun main() {
    // This fails with an IllegalArgumentException
    println(getIndices(-1))
    
    // Uncomment the line below to see a working example
    // println(getIndices(3))
    // [1, 2, 3]
}
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_82"><p id="aeooea_88">The <code class="code" id="aeooea_90">require()</code> function allows the compiler to perform <a href="typecasts.html#smart-casts" id="aeooea_91" data-tooltip="In most cases, you don't need to use explicit cast operators because the compiler automatically casts objects for you. This is called smart-casting. The compiler tracks the type checks and explicit casts for immutable values and inserts implicit (safe) casts automatically when…">smart casting</a>. After a successful check, the variable is automatically cast to a non-nullable type. These functions are often used for nullability checks to ensure that the variable is not null before proceeding. For example:</p><div class="code-block" data-lang="kotlin">
fun printNonNullString(str: String?) {
    // Nullability check
    require(str != null) 
    // After this successful check, 'str' is guaranteed to be 
    // non-null and is automatically smart cast to non-nullable String
    println(str.length)
}
</div></aside></section><section class="chapter"><h4 id="check-function" data-toc="check-function">check() function</h4><p id="aeooea_92">Use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html" id="aeooea_96" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_97">check()</code></a> function to validate the state of an object or variable. If the check fails, it indicates a logic error that needs to be addressed.</p><p id="aeooea_93">If the condition specified in the <code class="code" id="aeooea_98">check()</code> function is <code class="code" id="aeooea_99">false</code>, it throws an <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/" id="aeooea_100" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_101">IllegalStateException</code></a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
    var someState: String? = null

    fun getStateValue(): String {

        val state = checkNotNull(someState) { &quot;State must be set beforehand!&quot; }
        check(state.isNotEmpty()) { &quot;State must be non-empty!&quot; }
        return state
    }
    // If you uncomment the line below then the program fails with IllegalStateException
    // getStateValue()

    someState = &quot;&quot;

    // If you uncomment the line below then the program fails with IllegalStateException
    // getStateValue() 
    someState = &quot;non-empty-state&quot;

    // This prints &quot;non-empty-state&quot;
    println(getStateValue())
}
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_95"><p id="aeooea_102">The <code class="code" id="aeooea_104">check()</code> function allows the compiler to perform <a href="typecasts.html#smart-casts" id="aeooea_105" data-tooltip="In most cases, you don't need to use explicit cast operators because the compiler automatically casts objects for you. This is called smart-casting. The compiler tracks the type checks and explicit casts for immutable values and inserts implicit (safe) casts automatically when…">smart casting</a>. After a successful check, the variable is automatically cast to a non-nullable type. These functions are often used for nullability checks to ensure that the variable is not null before proceeding. For example:</p><div class="code-block" data-lang="kotlin">
fun printNonNullString(str: String?) {
    // Nullability check
    check(str != null) 
    // After this successful check, 'str' is guaranteed to be 
    // non-null and is automatically smart cast to non-nullable String
    println(str.length)
}
</div></aside></section><section class="chapter"><h4 id="error-function" data-toc="error-function">error() function</h4><p id="aeooea_106">The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/error.html" id="aeooea_109" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_111">error()</code></a> function is used to signal an illegal state or a condition in the code that logically should not occur. It's suitable for scenarios when you want to throw an exception intentionally in your code, such as when the code encounters an unexpected state. This function is particularly useful in <code class="code" id="aeooea_110">when</code> expressions, providing a clear way to handle cases that shouldn't logically happen.</p><p id="aeooea_107">In the following example, the <code class="code" id="aeooea_112">error()</code> function is used to handle an undefined user role. If the role is not one of the predefined ones, an <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/" id="aeooea_113" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_114">IllegalStateException</code></a> is thrown:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
class User(val name: String, val role: String)

fun processUserRole(user: User) {
    when (user.role) {
        &quot;admin&quot; -&gt; println(&quot;${user.name} is an admin.&quot;)
        &quot;editor&quot; -&gt; println(&quot;${user.name} is an editor.&quot;)
        &quot;viewer&quot; -&gt; println(&quot;${user.name} is a viewer.&quot;)
        else -&gt; error(&quot;Undefined role: ${user.role}&quot;)
    }
}

fun main() {
    // This works as expected
    val user1 = User(&quot;Alice&quot;, &quot;admin&quot;)
    processUserRole(user1)
    // Alice is an admin.

    // This throws an IllegalStateException
    val user2 = User(&quot;Bob&quot;, &quot;guest&quot;)
    processUserRole(user2)
}
</div></section></section></section><section class="chapter"><h2 id="handle-exceptions-using-try-catch-blocks" data-toc="handle-exceptions-using-try-catch-blocks">Handle exceptions using try-catch blocks</h2><p id="aeooea_115">When an exception is thrown, it interrupts the normal execution of the program. You can handle exceptions gracefully with the <code class="code" id="aeooea_125">try</code> and <code class="code" id="aeooea_126">catch</code> keywords to keep your program stable. The <code class="code" id="aeooea_127">try</code> block contains the code that might throw an exception, while the <code class="code" id="aeooea_128">catch</code> block catches and handles the exception if it occurs. The exception is caught by the first <code class="code" id="aeooea_129">catch</code> block that matches its specific type or a <a href="inheritance.html" id="aeooea_130" data-tooltip="All classes in Kotlin have a common superclass, Any, which is the default superclass for a class with no supertypes declared:">superclass</a> of the exception.</p><p id="aeooea_116">Here's how you can use the <code class="code" id="aeooea_131">try</code> and <code class="code" id="aeooea_132">catch</code> keywords together:</p><div class="code-block" data-lang="kotlin">
try {
    // Code that may throw an exception
} catch (e: SomeException) {
    // Code for handling the exception
}
</div><p id="aeooea_118">It's a common approach to use <code class="code" id="aeooea_133">try-catch</code> as an expression, so it can return a value from either the <code class="code" id="aeooea_134">try</code> block or the <code class="code" id="aeooea_135">catch</code> block:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
    val num: Int = try {

        // If count() completes successfully, its return value is assigned to num
        count()
        
    } catch (e: ArithmeticException) {
        
        // If count() throws an exception, the catch block returns -1, 
        // which is assigned to num
        -1
    }
    println(&quot;Result: $num&quot;)
}

// Simulates a function that might throw ArithmeticException
fun count(): Int {
    
    // Change this value to return a different value to num
    val a = 0
    
    return 10 / a
}
</div><p id="aeooea_120">You can use multiple <code class="code" id="aeooea_136">catch</code> handlers for the same <code class="code" id="aeooea_137">try</code> block. You can add as many <code class="code" id="aeooea_138">catch</code> blocks as needed to handle different exceptions distinctively. When you have multiple <code class="code" id="aeooea_139">catch</code> blocks, it's important to order them from the most specific to the least specific exception, following a top-to-bottom order in your code. This ordering aligns with the program's execution flow.</p><p id="aeooea_121">Consider this example with <a href="#create-custom-exceptions" id="aeooea_140" data-tooltip="In Kotlin, you can define custom exceptions by creating classes that extend the built-in Exception class. This allows you to create more specific error types tailored to your application's needs.">custom exceptions</a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
open class WithdrawalException(message: String) : Exception(message)
class InsufficientFundsException(message: String) : WithdrawalException(message)

fun processWithdrawal(amount: Double, availableFunds: Double) {
    if (amount &gt; availableFunds) {
        throw InsufficientFundsException(&quot;Insufficient funds for the withdrawal.&quot;)
    }
    if (amount &lt; 1 || amount % 1 != 0.0) {
        throw WithdrawalException(&quot;Invalid withdrawal amount.&quot;)
    }
    println(&quot;Withdrawal processed&quot;)
}

fun main() {
    val availableFunds = 500.0

    // Change this value to test different scenarios
    val withdrawalAmount = 500.5

    try {
        processWithdrawal(withdrawalAmount.toDouble(), availableFunds)

    // The order of catch blocks is important!
    } catch (e: InsufficientFundsException) {
        println(&quot;Caught an InsufficientFundsException: ${e.message}&quot;)
    } catch (e: WithdrawalException) {
        println(&quot;Caught a WithdrawalException: ${e.message}&quot;)
    }
}
</div><p id="aeooea_123">A general catch block handling <code class="code" id="aeooea_141">WithdrawalException</code>, catches all exceptions of its type, including specific ones like <code class="code" id="aeooea_142">InsufficientFundsException</code>, unless they are caught earlier by a more specific catch block.</p><section class="chapter"><h3 id="the-finally-block" data-toc="the-finally-block">The finally block</h3><p id="aeooea_143">The <code class="code" id="aeooea_154">finally</code> block contains code that always executes, regardless of whether the <code class="code" id="aeooea_155">try</code> block completes successfully or throws an exception. With the <code class="code" id="aeooea_156">finally</code> block you can clean up code after the execution of <code class="code" id="aeooea_157">try</code> and <code class="code" id="aeooea_158">catch</code> blocks. This is especially important when working with resources like files or network connections, as <code class="code" id="aeooea_159">finally</code> guarantees they are properly closed or released.</p><p id="aeooea_144">Here is how you would typically use the <code class="code" id="aeooea_160">try-catch-finally</code> blocks together:</p><div class="code-block" data-lang="kotlin">
try {
    // Code that may throw an exception
}
catch (e: YourException) {
    // Exception handler
}
finally {
    // Code that is always executed
}
</div><p id="aeooea_146">The returned value of a <code class="code" id="aeooea_161">try</code> expression is determined by the last executed expression in either the <code class="code" id="aeooea_162">try</code> or <code class="code" id="aeooea_163">catch</code> block. If no exceptions occur, the result comes from the <code class="code" id="aeooea_164">try</code> block; if an exception is handled, it comes from the <code class="code" id="aeooea_165">catch</code> block. The <code class="code" id="aeooea_166">finally</code> block is always executed, but it doesn't change the result of the <code class="code" id="aeooea_167">try-catch</code> block.</p><p id="aeooea_147">Let's look at an example to demonstrate:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun divideOrNull(a: Int): Int {
    
    // The try block is always executed
    // An exception here (division by zero) causes an immediate jump to the catch block
    try {
        val b = 44 / a
        println(&quot;try block: Executing division: $b&quot;)
        return b
    }
    
    // The catch block is executed due to the ArithmeticException (division by zero if a ==0)
    catch (e: ArithmeticException) {
        println(&quot;catch block: Encountered ArithmeticException $e&quot;)
        return -1
    }
    finally {
        println(&quot;finally block: The finally block is always executed&quot;)
    }
}

fun main() {
    
    // Change this value to get a different result. An ArithmeticException will return: -1
    divideOrNull(0)
}
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_149"><p id="aeooea_168">In Kotlin, the idiomatic way to manage resources that implement the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-auto-closeable/" id="aeooea_170" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_176">AutoClosable</code></a> interface, such as file streams like <code class="code" id="aeooea_171">FileInputStream</code> or <code class="code" id="aeooea_172">FileOutputStream</code>, is to use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/use.html" id="aeooea_173" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_177">.use()</code></a> function. This function automatically closes the resource when the block of code completes, regardless of whether an exception is thrown, thereby eliminating the need for a <code class="code" id="aeooea_174">finally</code> block. Consequently, Kotlin does not require a special syntax like <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" id="aeooea_175" data-external="true" rel="noopener noreferrer" target="_blank">Java's try-with-resources</a> for resource management.</p><div class="code-block" data-lang="kotlin">
FileWriter(&quot;test.txt&quot;).use { writer -&gt;
writer.write(&quot;some text&quot;) 
// After this block, the .use function automatically calls writer.close(), similar to a finally block
}
</div></aside><p id="aeooea_150">If your code requires resource cleanup without handling exceptions, you can also use <code class="code" id="aeooea_178">try</code> with the <code class="code" id="aeooea_179">finally</code> block without <code class="code" id="aeooea_180">catch</code> blocks:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
class MockResource { 
    fun use() { 
        println(&quot;Resource being used&quot;) 
        // Simulate a resource being used 
        // This throws an ArithmeticException if division by zero occurs
        val result = 100 / 0
        
        // This line is not executed if an exception is thrown
        println(&quot;Result: $result&quot;) 
    }
    
    fun close() { 
        println(&quot;Resource closed&quot;) 
    }
}

fun main() { 
    val resource = MockResource()
//sampleStart 
    try {
        
        // Attempts to use the resource 
        resource.use()
        
    } finally {
        
        // Ensures that the resource is always closed, even if an exception occurs 
        resource.close()
    }

    // This line is not printed if an exception is thrown
    println(&quot;End of the program&quot;)
//sampleEnd
}
</div><p id="aeooea_152">As you can see, the <code class="code" id="aeooea_181">finally</code> block guarantees that the resource is closed, regardless of whether an exception occurs.</p><p id="aeooea_153">In Kotlin, you have the flexibility to use only a <code class="code" id="aeooea_182">catch</code> block, only a <code class="code" id="aeooea_183">finally</code> block, or both, depending on your specific needs, but a <code class="code" id="aeooea_184">try</code> block must always be accompanied by at least one <code class="code" id="aeooea_185">catch</code> block or a <code class="code" id="aeooea_186">finally</code> block.</p></section></section><section class="chapter"><h2 id="create-custom-exceptions" data-toc="create-custom-exceptions">Create custom exceptions</h2><p id="aeooea_187">In Kotlin, you can define custom exceptions by creating classes that extend the built-in <code class="code" id="aeooea_200">Exception</code> class. This allows you to create more specific error types tailored to your application's needs.</p><p id="aeooea_188">To create one, you can define a class that extends <code class="code" id="aeooea_201">Exception</code>:</p><div class="code-block" data-lang="kotlin">
class MyException: Exception(&quot;My message&quot;)
</div><p id="aeooea_190">In this example, there is a default error message, &quot;My message&quot;, but you can leave it blank if you want.</p><aside class="prompt" data-type="tip" data-title="" id="aeooea_191"><p id="aeooea_202">Exceptions in Kotlin are stateful objects, carrying information specific to the context of their creation, referred to as the <a href="#stack-trace" id="aeooea_203" data-tooltip="The stack trace is a report generated by the runtime environment, used for debugging. It shows the sequence of function calls leading to a specific point in the program, especially where an error or exception occurred.">stack trace</a>. Avoid creating exceptions using <a href="object-declarations.html#object-declarations-overview" id="aeooea_204" data-tooltip="You can create single instances of objects in Kotlin using object declarations, which always have a name following the object keyword. This allows you to define a class and create an instance of it in a single step, which is useful for implementing singletons:">object declarations</a>. Instead, create a new instance of the exception every time you need one. This way, you can ensure the exception's state accurately reflects the specific context.</p></aside><p id="aeooea_192">Custom exceptions can also be a subclass of any pre-existent exception subclass, like the <code class="code" id="aeooea_205">ArithmeticException</code> subclass:</p><div class="code-block" data-lang="kotlin">
class NumberTooLargeException: ArithmeticException(&quot;My message&quot;)
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_194"><p id="aeooea_206">If you want to create subclasses of custom exceptions, you must declare the parent class as <code class="code" id="aeooea_209">open</code> because <a href="inheritance.html" id="aeooea_210" data-tooltip="All classes in Kotlin have a common superclass, Any, which is the default superclass for a class with no supertypes declared:">classes are final by default</a> and cannot be subclassed otherwise.</p><p id="aeooea_207">For example:</p><div class="code-block" data-lang="kotlin">
// Declares a custom exception as an open class, making it subclassable
open class MyCustomException(message: String): Exception(message)

// Creates a subclass of the custom exception
class SpecificCustomException: MyCustomException(&quot;Specific error message&quot;)
</div></aside><p id="aeooea_195">Custom exceptions behave just like built-in exceptions. You can throw them using the <code class="code" id="aeooea_211">throw</code> keyword, and handle them with <code class="code" id="aeooea_212">try-catch-finally</code> blocks. Let's look at an example to demonstrate:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
class NegativeNumberException: Exception(&quot;Parameter is less than zero.&quot;)
class NonNegativeNumberException: Exception(&quot;Parameter is a non-negative number.&quot;)

fun myFunction(number: Int) {
    if (number &lt; 0) throw NegativeNumberException()
    else if (number &gt;= 0) throw NonNegativeNumberException()
}

fun main() {
    
    // Change the value in this function to a get a different exception
    myFunction(1)
}
</div><p id="aeooea_197">In applications with diverse error scenarios, creating a hierarchy of exceptions can help making the code clearer and more specific. You can achieve this by using an <a href="classes.html#abstract-classes" id="aeooea_213" data-tooltip="A class may be declared abstract, along with some or all of its members. An abstract member does not have an implementation in its class. You don't need to annotate abstract classes or functions with open.">abstract class</a> or a <a href="sealed-classes.html#constructors" id="aeooea_214" data-tooltip="A sealed class itself is always an abstract class, and as a result, can't be instantiated directly. However, it may contain or inherit constructors. These constructors aren't for creating instances of the sealed class itself but for its subclasses. Consider the following example…">sealed class</a> as a base for common exception features and creating specific subclasses for detailed exception types. Additionally, custom exceptions with optional parameters offer flexibility, allowing initialization with varied messages, which enables more granular error handling.</p><p id="aeooea_198">Let's look at an example using the sealed class <code class="code" id="aeooea_215">AccountException</code> as the base for an exception hierarchy, and class <code class="code" id="aeooea_216">APIKeyExpiredException</code>, a subclass, which showcases the use of optional parameters for improved exception detail:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
//sampleStart
// Creates an abstract class as the base for an exception hierarchy for account-related errors
sealed class AccountException(message: String, cause: Throwable? = null):
Exception(message, cause)

// Creates a subclass of AccountException
class InvalidAccountCredentialsException : AccountException(&quot;Invalid account credentials detected&quot;)

// Creates a subclass of AccountException, which allows the addition of custom messages and causes
class APIKeyExpiredException(message: String = &quot;API key expired&quot;, cause: Throwable? = null)	: AccountException(message, cause)

// Change values of placeholder functions to get different results
fun areCredentialsValid(): Boolean = true
fun isAPIKeyExpired(): Boolean = true
//sampleEnd

// Validates account credentials and API key
fun validateAccount() {
    if (!areCredentialsValid()) throw InvalidAccountCredentialsException()
    if (isAPIKeyExpired()) {
        // Example of throwing APIKeyExpiredException with a specific cause
        val cause = RuntimeException(&quot;API key validation failed due to network error&quot;)
        throw APIKeyExpiredException(cause = cause)
    }
}

fun main() {
    try {
        validateAccount()
        println(&quot;Operation successful: Account credentials and API key are valid.&quot;)
    } catch (e: AccountException) {
        println(&quot;Error: ${e.message}&quot;)
        e.cause?.let { println(&quot;Caused by: ${it.message}&quot;) }
    }
}
</div></section><section class="chapter"><h2 id="the-nothing-type" data-toc="the-nothing-type">The Nothing type</h2><p id="aeooea_217">In Kotlin, every expression has a type. The type of the expression <code class="code" id="aeooea_224">throw IllegalArgumentException()</code> is <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html" id="aeooea_225" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_228">Nothing</code></a>, a built-in type that is a subtype of all other types, also known as <a href="https://en.wikipedia.org/wiki/Bottom_type" id="aeooea_226" data-external="true" rel="noopener noreferrer" target="_blank">the bottom type</a>. This means <code class="code" id="aeooea_227">Nothing</code> can be used as a return type or generic type where any other type is expected, without causing type errors.</p><p id="aeooea_218"><code class="code" id="aeooea_229">Nothing</code> is a special type in Kotlin used to represent functions or expressions that never complete successfully, either because they always throw an exception or enter an endless execution path like an infinite loop. You can use <code class="code" id="aeooea_230">Nothing</code> to mark functions that are not yet implemented or are designed to always throw an exception, clearly indicating your intentions to both the compiler and code readers. If the compiler infers a <code class="code" id="aeooea_231">Nothing</code> type in a function signature, it will warn you. Explicitly defining <code class="code" id="aeooea_232">Nothing</code> as the return type can eliminate this warning.</p><p id="aeooea_219">This Kotlin code demonstrates the use of the <code class="code" id="aeooea_233">Nothing</code> type, where the compiler marks the code following the function call as unreachable:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
class Person(val name: String?)

fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
    // This function will never return successfully.
    // It will always throw an exception.
}

fun main() {
    // Creates an instance of Person with 'name' as null
    val person = Person(name = null)
    
    val s: String = person.name ?: fail(&quot;Name required&quot;)

    // 's' is guaranteed to be initialized at this point
    println(s)
}
</div><p id="aeooea_221">Kotlin's <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-t-o-d-o.html" id="aeooea_234" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_236">TODO()</code></a> function, which also uses the <code class="code" id="aeooea_235">Nothing</code> type, serves as a placeholder to highlight areas of the code that need future implementation:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun notImplementedFunction(): Int {
    TODO(&quot;This function is not yet implemented&quot;)
}

fun main() {
    val result = notImplementedFunction()
    // This throws a NotImplementedError
    println(result)
}
</div><p id="aeooea_223">As you can see, the <code class="code" id="aeooea_237">TODO()</code> function always throws a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-not-implemented-error/" id="aeooea_238" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_239">NotImplementedError</code></a> exception.</p></section><section class="chapter"><h2 id="exception-classes" data-toc="exception-classes">Exception classes</h2><p id="aeooea_240">Let's explore some common exception types found in Kotlin, which are all subclasses of the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-runtime-exception/" id="aeooea_244" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_245">RuntimeException</code></a> class:</p><ul class="list _bullet" id="aeooea_241"><li class="list__item" id="aeooea_246"><p id="aeooea_251"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-arithmetic-exception/" id="aeooea_253" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_254">ArithmeticException</code></a>: This exception occurs when an arithmetic operation is impossible to perform, like division by zero.</p><div class="code-block" data-lang="kotlin">
val example = 2 / 0 // throws ArithmeticException
</div></li><li class="list__item" id="aeooea_247"><p id="aeooea_255"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-index-out-of-bounds-exception/" id="aeooea_259" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_260">IndexOutOfBoundsException</code></a>: This exception is thrown to indicate that an index of some sort, such as an array or string is out of range.</p><div class="code-block" data-lang="kotlin">
val myList = mutableListOf(1, 2, 3)
myList.removeAt(3)  // throws IndexOutOfBoundsException
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_257"><p id="aeooea_261">To avoid this exception, use a safer alternative, such as the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-null.html" id="aeooea_263" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_264">getOrNull()</code></a> function:</p><div class="code-block" data-lang="kotlin">
val myList = listOf(1, 2, 3)
// Returns null, instead of IndexOutOfBoundsException
val element = myList.getOrNull(3)
println(&quot;Element at index 3: $element&quot;)
</div></aside><p id="aeooea_258"></p></li><li class="list__item" id="aeooea_248"><p id="aeooea_265"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-no-such-element-exception/" id="aeooea_269" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_272">NoSuchElementException</code></a>: This exception is thrown when an element that does not exist in a particular collection is accessed. It occurs when using methods that expect a specific element, such as <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first.html" id="aeooea_270" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_273">first()</code></a> or <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/last.html" id="aeooea_271" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_274">last()</code></a>.</p><div class="code-block" data-lang="kotlin">
val emptyList = listOf&lt;Int&gt;()
val firstElement = emptyList.first()  // throws NoSuchElementException
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_267"><p id="aeooea_275">To avoid this exception, use a safer alternative, such as the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/first-or-null.html" id="aeooea_277" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_278">firstOrNull()</code></a> function:</p><div class="code-block" data-lang="kotlin">
val emptyList = listOf&lt;Int&gt;()
// Returns null, instead of NoSuchElementException
val firstElement = emptyList.firstOrNull()
println(&quot;First element in empty list: $firstElement&quot;)
</div></aside><p id="aeooea_268"></p></li><li class="list__item" id="aeooea_249"><p id="aeooea_279"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-number-format-exception/" id="aeooea_283" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_284">NumberFormatException</code></a>: This exception occurs when attempting to convert a string to a numeric type, but the string doesn't have an appropriate format.</p><div class="code-block" data-lang="kotlin">
val string = &quot;This is not a number&quot;
val number = string.toInt() // throws NumberFormatException
</div><aside class="prompt" data-type="note" data-title="" id="aeooea_281"><p id="aeooea_285">To avoid this exception, use a safer alternative, such as the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int-or-null.html" id="aeooea_287" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_288">toIntOrNull()</code></a> function:</p><div class="code-block" data-lang="kotlin">
val nonNumericString = &quot;not a number&quot;
// Returns null, instead of NumberFormatException
val number = nonNumericString.toIntOrNull()
println(&quot;Converted number: $number&quot;)
</div></aside><p id="aeooea_282"></p></li><li class="list__item" id="aeooea_250"><p id="aeooea_289"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-null-pointer-exception/" id="aeooea_291" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_294">NullPointerException</code></a>: This exception is thrown when an application attempts to use an object reference that has the <code class="code" id="aeooea_292">null</code> value. Even though Kotlin's null safety features significantly reduce the risk of NullPointerExceptions, they can still occur either through deliberate use of the <code class="code" id="aeooea_293">!!</code> operator or when interacting with Java, which lacks Kotlin's null safety.</p><div class="code-block" data-lang="kotlin">
val text: String? = null
println(text!!.length)  // throws a NullPointerException
</div></li></ul><p id="aeooea_242">While all exceptions are unchecked in Kotlin, and you don't have to catch them explicitly, you still have the flexibility to catch them if desired.</p><section class="chapter"><h3 id="exception-hierarchy" data-toc="exception-hierarchy">Exception hierarchy</h3><p id="aeooea_295">The root of the Kotlin exception hierarchy is the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/" id="aeooea_300" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_303">Throwable</code></a> class. It has two direct subclasses, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-error/" id="aeooea_301" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_304">Error</code></a> and <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-exception/" id="aeooea_302" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_305">Exception</code></a>:</p><ul class="list _bullet" id="aeooea_296"><li class="list__item" id="aeooea_306"><p id="aeooea_308">The <code class="code" id="aeooea_309">Error</code> subclass represents serious fundamental problems that an application might not be able to recover from by itself. These are problems that you generally would not attempt to handle, such as <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-out-of-memory-error/" id="aeooea_310" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_312">OutOfMemoryError</code></a> or <code class="code" id="aeooea_311">StackOverflowError</code>.</p></li><li class="list__item" id="aeooea_307"><p id="aeooea_313">The <code class="code" id="aeooea_314">Exception</code> subclass is used for conditions that you might want to handle. Subtypes of the <code class="code" id="aeooea_315">Exception</code> type, such as the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-runtime-exception/" id="aeooea_316" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_318">RuntimeException</code></a> and <code class="code" id="aeooea_317">IOException</code> (Input/Output Exception), deal with exceptional events in applications.</p></li></ul><figure id="aeooea_297"><img alt="Exception hierarchy - the Throwable class" src="images/throwable.svg" title="Exception hierarchy - the Throwable class" width="700" height="440"></figure><p id="aeooea_298"><code class="code" id="aeooea_319">RuntimeException</code> is usually caused by insufficient checks in the program code and can be prevented programmatically. Kotlin helps prevent common <code class="code" id="aeooea_320">RuntimeExceptions</code> like <code class="code" id="aeooea_321">NullPointerException</code> and provides compile-time warnings for potential runtime errors, such as division by zero. The following picture demonstrates a hierarchy of subtypes descended from <code class="code" id="aeooea_322">RuntimeException</code>:</p><figure id="aeooea_299"><img alt="Hierarchy of RuntimeExceptions" src="images/runtime-exception.svg" title="Hierarchy of RuntimeExceptions" width="700" height="440"></figure></section></section><section class="chapter"><h2 id="stack-trace" data-toc="stack-trace">Stack trace</h2><p id="aeooea_323">The <span class="emphasis" id="aeooea_332">stack trace</span> is a report generated by the runtime environment, used for debugging. It shows the sequence of function calls leading to a specific point in the program, especially where an error or exception occurred.</p><p id="aeooea_324">Let's see an example where the stack trace is automatically printed because of an exception in a JVM environment:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
//sampleStart    
    throw ArithmeticException(&quot;This is an arithmetic exception!&quot;)
//sampleEnd    
}
</div><p id="aeooea_326">Running this code in a JVM environment produces the following output:</p><div class="code-block" data-lang="none">
Exception in thread &quot;main&quot; java.lang.ArithmeticException: This is an arithmetic exception!
    at MainKt.main(Main.kt:3)
    at MainKt.main(Main.kt)
</div><p id="aeooea_328">The first line is the exception description, which includes:</p><ul class="list _bullet" id="aeooea_329"><li class="list__item" id="aeooea_333"><p id="aeooea_336">Exception type: <code class="code" id="aeooea_337">java.lang.ArithmeticException</code></p></li><li class="list__item" id="aeooea_334"><p id="aeooea_338">Thread: <code class="code" id="aeooea_339">main</code></p></li><li class="list__item" id="aeooea_335"><p id="aeooea_340">Exception message: <code class="code" id="aeooea_341">&quot;This is an arithmetic exception!&quot;</code></p></li></ul><p id="aeooea_330">Each other line that starts with an <code class="code" id="aeooea_342">at</code> after the exception description is the stack trace. A single line is called a <span class="emphasis" id="aeooea_343">stack trace element</span> or a <span class="emphasis" id="aeooea_344">stack frame</span>:</p><ul class="list _bullet" id="aeooea_331"><li class="list__item" id="aeooea_345"><p id="aeooea_347"><code class="code" id="aeooea_348">at MainKt.main (Main.kt:3)</code>: This shows the method name (<code class="code" id="aeooea_349">MainKt.main</code>) and the source file and line number where the method was called (<code class="code" id="aeooea_350">Main.kt:3</code>).</p></li><li class="list__item" id="aeooea_346"><p id="aeooea_351"><code class="code" id="aeooea_352">at MainKt.main (Main.kt)</code>: This shows that the exception occurs in the <code class="code" id="aeooea_353">main()</code> function of the <code class="code" id="aeooea_354">Main.kt</code> file.</p></li></ul></section><section class="chapter"><h2 id="exception-interoperability-with-java-swift-and-objective-c" data-toc="exception-interoperability-with-java-swift-and-objective-c">Exception interoperability with Java, Swift, and Objective-C</h2><p id="aeooea_355">Since Kotlin treats all exceptions as unchecked, it can lead to complications when such exceptions are called from languages that distinguish between checked and unchecked exceptions. To address this disparity in exception handling between Kotlin and languages like Java, Swift, and Objective-C, you can use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throws/" id="aeooea_356" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="aeooea_359">@Throws</code></a> annotation. This annotation alerts callers about possible exceptions. For more information, see <a href="java-to-kotlin-interop.html#checked-exceptions" id="aeooea_357" data-tooltip="Kotlin does not have checked exceptions. So, normally the Java signatures of Kotlin functions do not declare exceptions thrown. Thus, if you have a function in Kotlin like this:">Calling Kotlin from Java</a> and <a href="native-objc-interop.html#errors-and-exceptions" id="aeooea_358" data-tooltip="All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. However, Swift has only checked errors that are handled at compile time. So, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with the…">Interoperability with Swift/Objective-C</a>.</p></section><div class="last-modified">19 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="returns.html" class="navigation-links__prev">Returns and jumps</a><a href="packages.html" class="navigation-links__next">Packages and imports</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>