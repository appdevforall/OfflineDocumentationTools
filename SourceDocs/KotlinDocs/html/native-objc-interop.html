<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-18T20:47:09.042326352"><title>Interoperability with Swift/Objective-C | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"importing-swift-objective-c-libraries-to-kotlin","level":0,"title":"Importing Swift/Objective-C libraries to Kotlin","anchor":"#importing-swift-objective-c-libraries-to-kotlin"},{"id":"using-kotlin-in-swift-objective-c","level":0,"title":"Using Kotlin in Swift/Objective-C","anchor":"#using-kotlin-in-swift-objective-c"},{"id":"hide-kotlin-declarations-from-objective-c-and-swift","level":1,"title":"Hide Kotlin declarations from Objective-C and Swift","anchor":"#hide-kotlin-declarations-from-objective-c-and-swift"},{"id":"use-refining-in-swift","level":1,"title":"Use refining in Swift","anchor":"#use-refining-in-swift"},{"id":"change-declaration-names","level":1,"title":"Change declaration names","anchor":"#change-declaration-names"},{"id":"provide-documentation-with-kdoc-comments","level":1,"title":"Provide documentation with KDoc comments","anchor":"#provide-documentation-with-kdoc-comments"},{"id":"mappings","level":0,"title":"Mappings","anchor":"#mappings"},{"id":"classes","level":1,"title":"Classes","anchor":"#classes"},{"id":"initializers","level":1,"title":"Initializers","anchor":"#initializers"},{"id":"setters","level":1,"title":"Setters","anchor":"#setters"},{"id":"top-level-functions-and-properties","level":1,"title":"Top-level functions and properties","anchor":"#top-level-functions-and-properties"},{"id":"method-names-translation","level":1,"title":"Method names translation","anchor":"#method-names-translation"},{"id":"errors-and-exceptions","level":1,"title":"Errors and exceptions","anchor":"#errors-and-exceptions"},{"id":"enums","level":1,"title":"Enums","anchor":"#enums"},{"id":"suspending-functions","level":1,"title":"Suspending functions","anchor":"#suspending-functions"},{"id":"extensions-and-category-members","level":1,"title":"Extensions and category members","anchor":"#extensions-and-category-members"},{"id":"kotlin-singletons","level":1,"title":"Kotlin singletons","anchor":"#kotlin-singletons"},{"id":"nsnumber","level":1,"title":"NSNumber","anchor":"#nsnumber"},{"id":"nsmutablestring","level":1,"title":"NSMutableString","anchor":"#nsmutablestring"},{"id":"collections","level":1,"title":"Collections","anchor":"#collections"},{"id":"function-types","level":1,"title":"Function types","anchor":"#function-types"},{"id":"generics","level":1,"title":"Generics","anchor":"#generics"},{"id":"forward-declarations","level":1,"title":"Forward declarations","anchor":"#forward-declarations"},{"id":"casting-between-mapped-types","level":0,"title":"Casting between mapped types","anchor":"#casting-between-mapped-types"},{"id":"subclassing","level":0,"title":"Subclassing","anchor":"#subclassing"},{"id":"subclassing-kotlin-classes-and-interfaces-from-swift-objective-c","level":1,"title":"Subclassing Kotlin classes and interfaces from Swift/Objective-C","anchor":"#subclassing-kotlin-classes-and-interfaces-from-swift-objective-c"},{"id":"subclassing-swift-objective-c-classes-and-protocols-from-kotlin","level":1,"title":"Subclassing Swift/Objective-C classes and protocols from Kotlin","anchor":"#subclassing-swift-objective-c-classes-and-protocols-from-kotlin"},{"id":"c-features","level":0,"title":"C features","anchor":"#c-features"},{"id":"unsupported","level":0,"title":"Unsupported","anchor":"#unsupported"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Interoperability with Swift/Objective-C | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/native-objc-interop.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Interoperability with Swift/Objective-C | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/native-objc-interop.html#webpage",
    "url": "writerside-documentation/native-objc-interop.html",
    "name": "Interoperability with Swift/Objective-C | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="native-objc-interop" data-main-title="Interoperability with Swift/Objective-C" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///Native///Objective-C interop"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="native-objc-interop" id="native-objc-interop.md">Interoperability with Swift/Objective-C</h1><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_2"><p id="-8xy1u6_13">The Objective-C libraries import is <a href="components-stability.html#stability-levels-explained" id="-8xy1u6_15" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the <code class="code" id="-8xy1u6_16">@ExperimentalForeignApi</code> annotation.</p><p id="-8xy1u6_14">Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.</p></aside><p id="-8xy1u6_3">This document covers some aspects of Kotlin/Native interoperability with Swift/Objective-C: how you can use Kotlin declarations in Swift/Objective-C code and Objective-C declarations in Kotlin code.</p><p id="-8xy1u6_4">Some other resources you might find useful:</p><ul class="list _bullet" id="-8xy1u6_5"><li class="list__item" id="-8xy1u6_17"><p id="-8xy1u6_19">The <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia" id="-8xy1u6_20" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin-Swift interopedia</a>, a collection of examples on how to use Kotlin declarations in Swift code.</p></li><li class="list__item" id="-8xy1u6_18"><p id="-8xy1u6_21">The <a href="native-arc-integration.html" id="-8xy1u6_22" data-tooltip="Kotlin and Objective-C use different memory management strategies. Kotlin has a tracing garbage collector, while Objective-C relies on automatic reference counting (ARC).">Integration with Swift/Objective-C ARC</a> section, covering the details of integration between Kotlin's tracing GC and Objective-C's ARC.</p></li></ul><section class="chapter"><h2 id="importing-swift-objective-c-libraries-to-kotlin" data-toc="importing-swift-objective-c-libraries-to-kotlin">Importing Swift/Objective-C libraries to Kotlin</h2><p id="-8xy1u6_23">Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). For more details, see:</p><ul class="list _bullet" id="-8xy1u6_24"><li class="list__item" id="-8xy1u6_26"><p id="-8xy1u6_28"><a href="native-definition-file.html" id="-8xy1u6_29" data-tooltip="Kotlin/Native enables you to consume C and Objective-C libraries, allowing you to use their functionality in Kotlin. A special tool called cinterop takes a C or an Objective-C library and generates the corresponding Kotlin bindings, so that the library's methods can be used in yourâ€¦">Create and configure a library definition file</a></p></li><li class="list__item" id="-8xy1u6_27"><p id="-8xy1u6_30"><a href="multiplatform-configure-compilations.html#configure-interop-with-native-languages" id="-8xy1u6_31" data-tooltip="Kotlin provides interoperability with native languages and DSL to configure this for a specific compilation.">Configure compilation for native libraries</a></p></li></ul><p id="-8xy1u6_25">A Swift library can be used in Kotlin code if its API is exported to Objective-C with <code class="code" id="-8xy1u6_32">@objc</code>. Pure Swift modules are not yet supported.</p></section><section class="chapter"><h2 id="using-kotlin-in-swift-objective-c" data-toc="using-kotlin-in-swift-objective-c">Using Kotlin in Swift/Objective-C</h2><p id="-8xy1u6_33">Kotlin modules can be used in Swift/Objective-C code if compiled into a framework:</p><ul class="list _bullet" id="-8xy1u6_34"><li class="list__item" id="-8xy1u6_39"><p id="-8xy1u6_41">See <a href="multiplatform-build-native-binaries.html#declare-binaries" id="-8xy1u6_42" data-tooltip="Use the following factory methods to declare elements of the binaries collection.">Build final native binaries</a> to see how to declare binaries.</p></li><li class="list__item" id="-8xy1u6_40"><p id="-8xy1u6_43">Check out the <a href="https://github.com/Kotlin/kmm-basic-sample" id="-8xy1u6_44" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Multiplatform sample project</a> for an example.</p></li></ul><section class="chapter"><h3 id="hide-kotlin-declarations-from-objective-c-and-swift" data-toc="hide-kotlin-declarations-from-objective-c-and-swift">Hide Kotlin declarations from Objective-C and Swift</h3><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_45"><p id="-8xy1u6_49">The <code class="code" id="-8xy1u6_50">@HiddenFromObjC</code> annotation is <a href="components-stability.html#stability-levels-explained" id="-8xy1u6_51" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a> and requires <a href="opt-in-requirements.html" id="-8xy1u6_52" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likelyâ€¦">opt-in</a>.</p></aside><p id="-8xy1u6_46">To make your Kotlin code more Objective-C/Swift-friendly, you can hide a Kotlin declaration from Objective-C and Swift with <code class="code" id="-8xy1u6_53">@HiddenFromObjC</code>. The annotation disables a function or property export to Objective-C.</p><p id="-8xy1u6_47">Alternatively, you can mark Kotlin declarations with the<code class="code" id="-8xy1u6_54">internal</code> modifier to restrict their visibility in the compilation module. Choose <code class="code" id="-8xy1u6_55">@HiddenFromObjC</code> if you only want to hide the Kotlin declaration from Objective-C and Swift, but still keep it visible from other Kotlin modules.</p><p id="-8xy1u6_48"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/HiddenFromObjC.md" id="-8xy1u6_56" data-external="true" rel="noopener noreferrer" target="_blank">See an example in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="use-refining-in-swift" data-toc="use-refining-in-swift">Use refining in Swift</h3><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_57"><p id="-8xy1u6_61">The <code class="code" id="-8xy1u6_62">@ShouldRefineInSwift</code> annotation is <a href="components-stability.html#stability-levels-explained" id="-8xy1u6_63" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a> and requires <a href="opt-in-requirements.html" id="-8xy1u6_64" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likelyâ€¦">opt-in</a>.</p></aside><p id="-8xy1u6_58"><code class="code" id="-8xy1u6_65">@ShouldRefineInSwift</code> helps to replace a Kotlin declaration with a wrapper written in Swift. The annotation marks a function or property as <code class="code" id="-8xy1u6_66">swift_private</code> in the generated Objective-C API. Such declarations get the <code class="code" id="-8xy1u6_67">__</code> prefix, which makes them invisible from Swift.</p><p id="-8xy1u6_59">You can still use these declarations in your Swift code to create a Swift-friendly API, but they won't be suggested in the Xcode autocomplete.</p><ul class="list _bullet" id="-8xy1u6_60"><li class="list__item" id="-8xy1u6_68"><p id="-8xy1u6_70">For more information on refining Objective-C declarations in Swift, see the <a href="https://developer.apple.com/documentation/swift/improving-objective-c-api-declarations-for-swift" id="-8xy1u6_71" data-external="true" rel="noopener noreferrer" target="_blank">official Apple documentation</a>.</p></li><li class="list__item" id="-8xy1u6_69"><p id="-8xy1u6_72">For an example on how to use the <code class="code" id="-8xy1u6_73">@ShouldRefineInSwift</code> annotation, see the <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" id="-8xy1u6_74" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin-Swift interopedia</a>.</p></li></ul></section><section class="chapter"><h3 id="change-declaration-names" data-toc="change-declaration-names">Change declaration names</h3><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_75"><p id="-8xy1u6_79">The <code class="code" id="-8xy1u6_80">@ObjCName</code> annotation is <a href="components-stability.html#stability-levels-explained" id="-8xy1u6_81" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a> and requires <a href="opt-in-requirements.html" id="-8xy1u6_82" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likelyâ€¦">opt-in</a>.</p></aside><p id="-8xy1u6_76">To avoid renaming Kotlin declarations, use the <code class="code" id="-8xy1u6_83">@ObjCName</code> annotation. It instructs the Kotlin compiler to use the custom Objective-C and Swift name for the annotated class, interface, or another Kotlin entity:</p><div class="code-block" data-lang="kotlin">
@ObjCName(swiftName = &quot;MySwiftArray&quot;)
class MyKotlinArray {
    @ObjCName(&quot;index&quot;)
    fun indexOf(@ObjCName(&quot;of&quot;) element: String): Int = TODO()
}

// Usage with the ObjCName annotations
let array = MySwiftArray()
let index = array.index(of: &quot;element&quot;)
</div><p id="-8xy1u6_78"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ObjCName.md" id="-8xy1u6_84" data-external="true" rel="noopener noreferrer" target="_blank">See another example in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="provide-documentation-with-kdoc-comments" data-toc="provide-documentation-with-kdoc-comments">Provide documentation with KDoc comments</h3><p id="-8xy1u6_85">Documentation is essential for understanding any API. Providing documentation for the shared Kotlin API allows you to communicate with its users on matters of usage, dos and don'ts, and so on.</p><p id="-8xy1u6_86">By default, <a href="kotlin-doc.html" id="-8xy1u6_98" data-tooltip="The language used to document Kotlin code (the equivalent of Java's Javadoc) is called KDoc. In essence, KDoc combines Javadoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.">KDocs</a> comments are not translated into corresponding comments when generating an Objective-C header. For example, the following Kotlin code with KDoc:</p><div class="code-block" data-lang="kotlin">
/**
 * Prints the sum of the arguments.
 * Properly handles the case when the sum doesn't fit in 32-bit integer.
 */
fun printSum(a: Int, b: Int) = println(a.toLong() + b)
</div><p id="-8xy1u6_88">Will produce an Objective-C declaration without any comments:</p><div class="code-block" data-lang="objectivec">
+ (void)printSumA:(int32_t)a b:(int32_t)b __attribute__((swift_name(&quot;printSum(a:b:)&quot;)));
</div><p id="-8xy1u6_90">To enable export of KDoc comments, add the following compiler option to your <code class="code" id="-8xy1u6_99">build.gradle(.kts)</code>:</p><div class="tabs" id="-8xy1u6_91" data-group="build-script" data-anchors="[-8xy1u6_100,-8xy1u6_101]"><div class="tabs__content" data-gtm="tab" id="-8xy1u6_100" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    targets.withType&lt;org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget&gt; {
        compilations.get(&quot;main&quot;).compilerOptions.options.freeCompilerArgs.add(&quot;-Xexport-kdoc&quot;)
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="-8xy1u6_101" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    targets.withType(org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget) {
        compilations.get(&quot;main&quot;).compilerOptions.options.freeCompilerArgs.add(&quot;-Xexport-kdoc&quot;)
    }
}
</div></div></div><p id="-8xy1u6_92">After that, the Objective-C header will contain a corresponding comment:</p><div class="code-block" data-lang="objectivec">
/**
 * Prints the sum of the arguments.
 * Properly handles the case when the sum doesn't fit in 32-bit integer.
 */
+ (void)printSumA:(int32_t)a b:(int32_t)b __attribute__((swift_name(&quot;printSum(a:b:)&quot;)));
</div><p id="-8xy1u6_94">You'll be able to see comments on classes and methods in autocompletion, for example, in Xcode. If you go to the definition of functions (in the <code class="code" id="-8xy1u6_104">.h</code> file), you'll see comments on <code class="code" id="-8xy1u6_105">@param</code>, <code class="code" id="-8xy1u6_106">@return</code>, and so on.</p><p id="-8xy1u6_95">Known limitations:</p><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_96"><p id="-8xy1u6_107">The ability to export KDoc comments to generated Objective-C headers is <a href="components-stability.html" id="-8xy1u6_108" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in aâ€¦">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-38600" id="-8xy1u6_109" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><ul class="list _bullet" id="-8xy1u6_97"><li class="list__item" id="-8xy1u6_110"><p id="-8xy1u6_112">Dependency documentation is not exported unless it is compiled with <code class="code" id="-8xy1u6_113">-Xexport-kdoc</code> itself. The feature is Experimental, so libraries compiled with this option might be incompatible with other compiler versions.</p></li><li class="list__item" id="-8xy1u6_111"><p id="-8xy1u6_114">KDoc comments are mostly exported as is. Many KDoc features, for example <code class="code" id="-8xy1u6_115">@property</code>, are not supported.</p></li></ul></section></section><section class="chapter"><h2 id="mappings" data-toc="mappings">Mappings</h2><p id="-8xy1u6_116">The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</p><p id="-8xy1u6_117">&quot;-&gt;&quot; and &quot;&lt;-&quot; indicate that mapping only goes one way.</p><div class="table-wrapper"><table class="wide" id="-8xy1u6_118"><thead><tr class="ijRowHead" id="-8xy1u6_135"><th id="-8xy1u6_160"><p>Kotlin</p></th><th id="-8xy1u6_161"><p>Swift</p></th><th id="-8xy1u6_162"><p>Objective-C</p></th><th id="-8xy1u6_163"><p>Notes</p></th></tr></thead><tbody><tr id="-8xy1u6_136"><td id="-8xy1u6_164"><p><code class="code" id="-8xy1u6_168">class</code></p></td><td id="-8xy1u6_165"><p><code class="code" id="-8xy1u6_169">class</code></p></td><td id="-8xy1u6_166"><p><code class="code" id="-8xy1u6_170">@interface</code></p></td><td id="-8xy1u6_167"><p><a href="#classes" id="-8xy1u6_171" data-tooltip="Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with a Protocol name suffix, for example, @protocol Foo -&gt; interface FooProtocol. These classes and interfaces are placed into a package specified in build configurationâ€¦">note</a></p></td></tr><tr id="-8xy1u6_137"><td id="-8xy1u6_172"><p><code class="code" id="-8xy1u6_176">interface</code></p></td><td id="-8xy1u6_173"><p><code class="code" id="-8xy1u6_177">protocol</code></p></td><td id="-8xy1u6_174"><p><code class="code" id="-8xy1u6_178">@protocol</code></p></td><td id="-8xy1u6_175"></td></tr><tr id="-8xy1u6_138"><td id="-8xy1u6_179"><p><code class="code" id="-8xy1u6_183">constructor</code>/<code class="code" id="-8xy1u6_184">create</code></p></td><td id="-8xy1u6_180"><p>Initializer</p></td><td id="-8xy1u6_181"><p>Initializer</p></td><td id="-8xy1u6_182"><p><a href="#initializers" id="-8xy1u6_185" data-tooltip="A Swift/Objective-C initializer is imported to Kotlin as constructors or as factory methods named create. The latter happens with initializers declared in the Objective-C category or as a Swift extension, because Kotlin has no concept of extension constructors.">note</a></p></td></tr><tr id="-8xy1u6_139"><td id="-8xy1u6_186"><p>Property</p></td><td id="-8xy1u6_187"><p>Property</p></td><td id="-8xy1u6_188"><p>Property</p></td><td id="-8xy1u6_189"><p><a href="#top-level-functions-and-properties" id="-8xy1u6_190" data-tooltip="Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class, for example:">note 1</a>, <a href="#setters" id="-8xy1u6_191" data-tooltip="Writeable Objective-C properties overriding read-only properties of the superclass are represented as setFoo() method for the property foo. The same goes for a protocol's read-only properties that are implemented as mutable.">note 2</a></p></td></tr><tr id="-8xy1u6_140"><td id="-8xy1u6_192"><p>Method</p></td><td id="-8xy1u6_193"><p>Method</p></td><td id="-8xy1u6_194"><p>Method</p></td><td id="-8xy1u6_195"><p><a href="#top-level-functions-and-properties" id="-8xy1u6_196" data-tooltip="Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class, for example:">note 1</a>, <a href="#method-names-translation" id="-8xy1u6_197" data-tooltip="Generally, Swift argument labels and Objective-C selector pieces are mapped to Kotlin parameter names. These two concepts have different semantics, so sometimes Swift/Objective-C methods can be imported with a clashing Kotlin signature. In this case, the clashing methods can beâ€¦">note 2</a></p></td></tr><tr id="-8xy1u6_141"><td id="-8xy1u6_198"><p><code class="code" id="-8xy1u6_202">enum class</code></p></td><td id="-8xy1u6_199"><p><code class="code" id="-8xy1u6_203">class</code></p></td><td id="-8xy1u6_200"><p><code class="code" id="-8xy1u6_204">@interface</code></p></td><td id="-8xy1u6_201"><p><a href="#enums" id="-8xy1u6_205" data-tooltip="Kotlin enums are imported into Objective-C as @interface and into Swift as class. These data structures have properties corresponding to each enum value. Consider this Kotlin code:">note</a></p></td></tr><tr id="-8xy1u6_142"><td id="-8xy1u6_206"><p><code class="code" id="-8xy1u6_210">suspend</code>-&gt;</p></td><td id="-8xy1u6_207"><p><code class="code" id="-8xy1u6_211">completionHandler:</code>/<code class="code" id="-8xy1u6_212">async</code></p></td><td id="-8xy1u6_208"><p><code class="code" id="-8xy1u6_213">completionHandler:</code></p></td><td id="-8xy1u6_209"><p><a href="#errors-and-exceptions" id="-8xy1u6_214" data-tooltip="All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. However, Swift has only checked errors that are handled at compile time. So, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with theâ€¦">note 1</a>, <a href="#suspending-functions" id="-8xy1u6_215" data-tooltip="Support for calling suspend functions from Swift code as async is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">note 2</a></p></td></tr><tr id="-8xy1u6_143"><td id="-8xy1u6_216"><p><code class="code" id="-8xy1u6_220">@Throws fun</code></p></td><td id="-8xy1u6_217"><p><code class="code" id="-8xy1u6_221">throws</code></p></td><td id="-8xy1u6_218"><p><code class="code" id="-8xy1u6_222">error:(NSError**)error</code></p></td><td id="-8xy1u6_219"><p><a href="#errors-and-exceptions" id="-8xy1u6_223" data-tooltip="All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. However, Swift has only checked errors that are handled at compile time. So, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with theâ€¦">note</a></p></td></tr><tr id="-8xy1u6_144"><td id="-8xy1u6_224"><p>Extension</p></td><td id="-8xy1u6_225"><p>Extension</p></td><td id="-8xy1u6_226"><p>Category member</p></td><td id="-8xy1u6_227"><p><a href="#extensions-and-category-members" id="-8xy1u6_228" data-tooltip="Members of Objective-C categories and Swift extensions are generally imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin, and the extension initializers aren't available as Kotlin constructors.">note</a></p></td></tr><tr id="-8xy1u6_145"><td id="-8xy1u6_229"><p><code class="code" id="-8xy1u6_233">companion</code> member &lt;-</p></td><td id="-8xy1u6_230"><p>Class method or property</p></td><td id="-8xy1u6_231"><p>Class method or property</p></td><td id="-8xy1u6_232"></td></tr><tr id="-8xy1u6_146"><td id="-8xy1u6_234"><p><code class="code" id="-8xy1u6_238">null</code></p></td><td id="-8xy1u6_235"><p><code class="code" id="-8xy1u6_239">nil</code></p></td><td id="-8xy1u6_236"><p><code class="code" id="-8xy1u6_240">nil</code></p></td><td id="-8xy1u6_237"></td></tr><tr id="-8xy1u6_147"><td id="-8xy1u6_241"><p><code class="code" id="-8xy1u6_245">Singleton</code></p></td><td id="-8xy1u6_242"><p><code class="code" id="-8xy1u6_246">shared</code> or <code class="code" id="-8xy1u6_247">companion</code> property</p></td><td id="-8xy1u6_243"><p><code class="code" id="-8xy1u6_248">shared</code> or <code class="code" id="-8xy1u6_249">companion</code> property</p></td><td id="-8xy1u6_244"><p><a href="#kotlin-singletons" id="-8xy1u6_250" data-tooltip="Kotlin singleton (made with an object declaration, including companion object) is imported to Swift/Objective-C as a class with a single instance.">note</a></p></td></tr><tr id="-8xy1u6_148"><td id="-8xy1u6_251"><p>Primitive type</p></td><td id="-8xy1u6_252"><p>Primitive type / <code class="code" id="-8xy1u6_255">NSNumber</code></p></td><td id="-8xy1u6_253"></td><td id="-8xy1u6_254"><p><a href="#nsnumber" id="-8xy1u6_256" data-tooltip="Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, the kotlin.Int box is represented as KotlinInt class instance in Swift (or ${prefix}Int instance in Objective-C, where prefix is the framework names prefix). These classes are derived fromâ€¦">note</a></p></td></tr><tr id="-8xy1u6_149"><td id="-8xy1u6_257"><p><code class="code" id="-8xy1u6_261">Unit</code> return type</p></td><td id="-8xy1u6_258"><p><code class="code" id="-8xy1u6_262">Void</code></p></td><td id="-8xy1u6_259"><p><code class="code" id="-8xy1u6_263">void</code></p></td><td id="-8xy1u6_260"></td></tr><tr id="-8xy1u6_150"><td id="-8xy1u6_264"><p><code class="code" id="-8xy1u6_268">String</code></p></td><td id="-8xy1u6_265"><p><code class="code" id="-8xy1u6_269">String</code></p></td><td id="-8xy1u6_266"><p><code class="code" id="-8xy1u6_270">NSString</code></p></td><td id="-8xy1u6_267"></td></tr><tr id="-8xy1u6_151"><td id="-8xy1u6_271"><p><code class="code" id="-8xy1u6_275">String</code></p></td><td id="-8xy1u6_272"><p><code class="code" id="-8xy1u6_276">NSMutableString</code></p></td><td id="-8xy1u6_273"><p><code class="code" id="-8xy1u6_277">NSMutableString</code></p></td><td id="-8xy1u6_274"><p><a href="#nsmutablestring" id="-8xy1u6_278" data-tooltip="NSMutableString Objective-C class is not available from Kotlin. All instances of NSMutableString are copied when passed to Kotlin.">note</a></p></td></tr><tr id="-8xy1u6_152"><td id="-8xy1u6_279"><p><code class="code" id="-8xy1u6_283">List</code></p></td><td id="-8xy1u6_280"><p><code class="code" id="-8xy1u6_284">Array</code></p></td><td id="-8xy1u6_281"><p><code class="code" id="-8xy1u6_285">NSArray</code></p></td><td id="-8xy1u6_282"></td></tr><tr id="-8xy1u6_153"><td id="-8xy1u6_286"><p><code class="code" id="-8xy1u6_290">MutableList</code></p></td><td id="-8xy1u6_287"><p><code class="code" id="-8xy1u6_291">NSMutableArray</code></p></td><td id="-8xy1u6_288"><p><code class="code" id="-8xy1u6_292">NSMutableArray</code></p></td><td id="-8xy1u6_289"></td></tr><tr id="-8xy1u6_154"><td id="-8xy1u6_293"><p><code class="code" id="-8xy1u6_297">Set</code></p></td><td id="-8xy1u6_294"><p><code class="code" id="-8xy1u6_298">Set</code></p></td><td id="-8xy1u6_295"><p><code class="code" id="-8xy1u6_299">NSSet</code></p></td><td id="-8xy1u6_296"></td></tr><tr id="-8xy1u6_155"><td id="-8xy1u6_300"><p><code class="code" id="-8xy1u6_304">MutableSet</code></p></td><td id="-8xy1u6_301"><p><code class="code" id="-8xy1u6_305">NSMutableSet</code></p></td><td id="-8xy1u6_302"><p><code class="code" id="-8xy1u6_306">NSMutableSet</code></p></td><td id="-8xy1u6_303"><p><a href="#collections" id="-8xy1u6_307" data-tooltip="Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for NSMutableSet and NSMutableDictionary.">note</a></p></td></tr><tr id="-8xy1u6_156"><td id="-8xy1u6_308"><p><code class="code" id="-8xy1u6_312">Map</code></p></td><td id="-8xy1u6_309"><p><code class="code" id="-8xy1u6_313">Dictionary</code></p></td><td id="-8xy1u6_310"><p><code class="code" id="-8xy1u6_314">NSDictionary</code></p></td><td id="-8xy1u6_311"></td></tr><tr id="-8xy1u6_157"><td id="-8xy1u6_315"><p><code class="code" id="-8xy1u6_319">MutableMap</code></p></td><td id="-8xy1u6_316"><p><code class="code" id="-8xy1u6_320">NSMutableDictionary</code></p></td><td id="-8xy1u6_317"><p><code class="code" id="-8xy1u6_321">NSMutableDictionary</code></p></td><td id="-8xy1u6_318"><p><a href="#collections" id="-8xy1u6_322" data-tooltip="Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for NSMutableSet and NSMutableDictionary.">note</a></p></td></tr><tr id="-8xy1u6_158"><td id="-8xy1u6_323"><p>Function type</p></td><td id="-8xy1u6_324"><p>Function type</p></td><td id="-8xy1u6_325"><p>Block pointer type</p></td><td id="-8xy1u6_326"><p><a href="#function-types" id="-8xy1u6_327" data-tooltip="Kotlin function-typed objects (for example, lambdas) are converted to functions in Swift and blocks in Objective-C. See an example of a Kotlin function with a lambda in the Kotlin-Swift interopedia.">note</a></p></td></tr><tr id="-8xy1u6_159"><td id="-8xy1u6_328"><p>Inline classes</p></td><td id="-8xy1u6_329"><p>Unsupported</p></td><td id="-8xy1u6_330"><p>Unsupported</p></td><td id="-8xy1u6_331"><p><a href="#unsupported" id="-8xy1u6_332" data-tooltip="Some features of Kotlin programming language are not yet mapped into the respective features of Objective-C or Swift. Currently, the following features are not properly exposed in generated framework headers:">note</a></p></td></tr></tbody></table></div><section class="chapter"><h3 id="classes" data-toc="classes">Classes</h3><section class="chapter"><h4 id="name-translation" data-toc="name-translation">Name translation</h4><p id="-8xy1u6_335">Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with a <code class="code" id="-8xy1u6_338">Protocol</code> name suffix, for example, <code class="code" id="-8xy1u6_339">@protocol Foo</code>-&gt; <code class="code" id="-8xy1u6_340">interface FooProtocol</code>. These classes and interfaces are placed into a package <a href="#importing-swift-objective-c-libraries-to-kotlin" id="-8xy1u6_341" data-tooltip="Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). For more details, see:">specified in build configuration</a> (<code class="code" id="-8xy1u6_342">platform.*</code> packages for preconfigured system frameworks).</p><p id="-8xy1u6_336">The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</p><p id="-8xy1u6_337">Objective-C does not support packages in a framework. If the Kotlin compiler finds Kotlin classes in the same framework which have the same name but different packages, it renames them. This algorithm is not stable yet and can change between Kotlin releases. To work around this, you can rename the conflicting Kotlin classes in the framework.</p></section><section class="chapter"><h4 id="strong-linking" data-toc="strong-linking">Strong linking</h4><p id="-8xy1u6_343">Whenever you use an Objective-C class in the Kotlin source, it's marked as a strongly linked symbol. The resulting build artifact mentions related symbols as strong external references.</p><p id="-8xy1u6_344">This means that the app tries to link symbols during the launch dynamically, and if they are unavailable, the app crashes. The crash happens even if symbols were never used. Symbols might be unavailable on a particular device or OS version.</p><p id="-8xy1u6_345">To work around this issue and avoid &quot;Symbol not found&quot; errors, use a Swift or Objective-C wrapper that checks if the class is actually available. <a href="https://github.com/JetBrains/compose-multiplatform-core/pull/1278/files" id="-8xy1u6_346" data-external="true" rel="noopener noreferrer" target="_blank">See how this workaround was implemented in the Compose Multiplatform framework</a>.</p></section></section><section class="chapter"><h3 id="initializers" data-toc="initializers">Initializers</h3><p id="-8xy1u6_347">A Swift/Objective-C initializer is imported to Kotlin as constructors or as factory methods named <code class="code" id="-8xy1u6_350">create</code>. The latter happens with initializers declared in the Objective-C category or as a Swift extension, because Kotlin has no concept of extension constructors.</p><aside class="prompt" data-type="tip" data-title="" id="-8xy1u6_348"><p id="-8xy1u6_351">Before importing Swift initializers to Kotlin, don't forget to annotate them with <code class="code" id="-8xy1u6_352">@objc</code>.</p></aside><p id="-8xy1u6_349">Kotlin constructors are imported as initializers to Swift/Objective-C.</p></section><section class="chapter"><h3 id="setters" data-toc="setters">Setters</h3><p id="-8xy1u6_353">Writeable Objective-C properties overriding read-only properties of the superclass are represented as <code class="code" id="-8xy1u6_354">setFoo()</code> method for the property <code class="code" id="-8xy1u6_355">foo</code>. The same goes for a protocol's read-only properties that are implemented as mutable.</p></section><section class="chapter"><h3 id="top-level-functions-and-properties" data-toc="top-level-functions-and-properties">Top-level functions and properties</h3><p id="-8xy1u6_356">Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class, for example:</p><div class="code-block" data-lang="kotlin">
// MyLibraryUtils.kt
package my.library

fun foo() {}
</div><p id="-8xy1u6_358">You can then call the <code class="code" id="-8xy1u6_362">foo()</code> function from Swift like this:</p><div class="code-block" data-lang="swift">
MyLibraryUtilsKt.foo()
</div><p id="-8xy1u6_360">See a collection of examples on accessing top-level Kotlin declarations in the Kotlin-Swift interopedia:</p><ul class="list _bullet" id="-8xy1u6_361"><li class="list__item" id="-8xy1u6_363"><p id="-8xy1u6_366"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Top-level%20functions.md" id="-8xy1u6_367" data-external="true" rel="noopener noreferrer" target="_blank">Top-level functions</a></p></li><li class="list__item" id="-8xy1u6_364"><p id="-8xy1u6_368"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20val%20properties.md" id="-8xy1u6_369" data-external="true" rel="noopener noreferrer" target="_blank">Top-level read-only properties</a></p></li><li class="list__item" id="-8xy1u6_365"><p id="-8xy1u6_370"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Top-level%20mutable%20var%20properties.md" id="-8xy1u6_371" data-external="true" rel="noopener noreferrer" target="_blank">Top-level mutable properties</a></p></li></ul></section><section class="chapter"><h3 id="method-names-translation" data-toc="method-names-translation">Method names translation</h3><p id="-8xy1u6_372">Generally, Swift argument labels and Objective-C selector pieces are mapped to Kotlin parameter names. These two concepts have different semantics, so sometimes Swift/Objective-C methods can be imported with a clashing Kotlin signature. In this case, the clashing methods can be called from Kotlin using named arguments, for example:</p><div class="code-block" data-lang="swift">
[player moveTo:LEFT byMeters:17]
[player moveTo:UP byInches:42]
</div><p id="-8xy1u6_374">In Kotlin, it's:</p><div class="code-block" data-lang="kotlin">
player.moveTo(LEFT, byMeters = 17)
player.moveTo(UP, byInches = 42)
</div><p id="-8xy1u6_376">Here's how the <code class="code" id="-8xy1u6_380">kotlin.Any</code> functions are mapped to Swift/Objective-C:</p><div class="table-wrapper"><table class="wide" id="-8xy1u6_377"><thead><tr class="ijRowHead" id="-8xy1u6_381"><th id="-8xy1u6_385"><p>Kotlin</p></th><th id="-8xy1u6_386"><p>Swift</p></th><th id="-8xy1u6_387"><p>Objective-C</p></th></tr></thead><tbody><tr id="-8xy1u6_382"><td id="-8xy1u6_388"><p><code class="code" id="-8xy1u6_391">equals()</code></p></td><td id="-8xy1u6_389"><p><code class="code" id="-8xy1u6_392">isEquals(_:)</code></p></td><td id="-8xy1u6_390"><p><code class="code" id="-8xy1u6_393">isEquals:</code></p></td></tr><tr id="-8xy1u6_383"><td id="-8xy1u6_394"><p><code class="code" id="-8xy1u6_397">hashCode()</code></p></td><td id="-8xy1u6_395"><p><code class="code" id="-8xy1u6_398">hash</code></p></td><td id="-8xy1u6_396"><p><code class="code" id="-8xy1u6_399">hash</code></p></td></tr><tr id="-8xy1u6_384"><td id="-8xy1u6_400"><p><code class="code" id="-8xy1u6_403">toString()</code></p></td><td id="-8xy1u6_401"><p><code class="code" id="-8xy1u6_404">description</code></p></td><td id="-8xy1u6_402"><p><code class="code" id="-8xy1u6_405">description</code></p></td></tr></tbody></table></div><p id="-8xy1u6_378"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Data%20classes.md" id="-8xy1u6_406" data-external="true" rel="noopener noreferrer" target="_blank">See an example with data classes in the Kotlin-Swift interopedia</a>.</p><p id="-8xy1u6_379">You can specify a more idiomatic name in Swift or Objective-C, instead of renaming the Kotlin declaration with the <a href="#change-declaration-names" id="-8xy1u6_407" data-tooltip="The @ObjCName annotation is Experimental and requires opt-in."><code class="code" id="-8xy1u6_408">@ObjCName</code> annotation</a>.</p></section><section class="chapter"><h3 id="errors-and-exceptions" data-toc="errors-and-exceptions">Errors and exceptions</h3><p id="-8xy1u6_409">All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. However, Swift has only checked errors that are handled at compile time. So, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with the <code class="code" id="-8xy1u6_415">@Throws</code> annotation, specifying a list of &quot;expected&quot; exception classes.</p><p id="-8xy1u6_410">When compiling to the Objective-C/Swift framework, non-<code class="code" id="-8xy1u6_416">suspend</code> functions that have or inherit the <code class="code" id="-8xy1u6_417">@Throws</code> annotation are represented as <code class="code" id="-8xy1u6_418">NSError*</code>-producing methods in Objective-C and as <code class="code" id="-8xy1u6_419">throws</code> methods in Swift. Representations for <code class="code" id="-8xy1u6_420">suspend</code> functions always have<code class="code" id="-8xy1u6_421">NSError*</code>/<code class="code" id="-8xy1u6_422">Error</code> parameter in completion handler.</p><p id="-8xy1u6_411">When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the <code class="code" id="-8xy1u6_423">@Throws</code>-specified classes or their subclasses, it is propagated as <code class="code" id="-8xy1u6_424">NSError</code>. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</p><p id="-8xy1u6_412"><code class="code" id="-8xy1u6_425">suspend</code> functions without <code class="code" id="-8xy1u6_426">@Throws</code> propagate only <code class="code" id="-8xy1u6_427">CancellationException</code> (as <code class="code" id="-8xy1u6_428">NSError</code>). Non-<code class="code" id="-8xy1u6_429">suspend</code> functions without <code class="code" id="-8xy1u6_430">@Throws</code> don't propagate Kotlin exceptions at all.</p><p id="-8xy1u6_413">Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</p><p id="-8xy1u6_414"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Exceptions.md" id="-8xy1u6_431" data-external="true" rel="noopener noreferrer" target="_blank">See an example in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="enums" data-toc="enums">Enums</h3><p id="-8xy1u6_432">Kotlin enums are imported into Objective-C as <code class="code" id="-8xy1u6_439">@interface</code> and into Swift as <code class="code" id="-8xy1u6_440">class</code>. These data structures have properties corresponding to each enum value. Consider this Kotlin code:</p><div class="code-block" data-lang="kotlin">
// Kotlin
enum class Colors {
    RED, GREEN, BLUE
}
</div><p id="-8xy1u6_434">You can access the properties of this enum class from Swift as follows:</p><div class="code-block" data-lang="swift">
// Swift
Colors.red
Colors.green
Colors.blue
</div><p id="-8xy1u6_436">To use variables of a Kotlin enum in a Swift <code class="code" id="-8xy1u6_441">switch</code> statement, provide a default statement to prevent a compilation error:</p><div class="code-block" data-lang="swift">
switch color {
    case .red: print(&quot;It's red&quot;)
    case .green: print(&quot;It's green&quot;)
    case .blue: print(&quot;It's blue&quot;)
    default: fatalError(&quot;No such color&quot;)
}
</div><p id="-8xy1u6_438"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Enum%20classes.md" id="-8xy1u6_442" data-external="true" rel="noopener noreferrer" target="_blank">See another example in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="suspending-functions" data-toc="suspending-functions">Suspending functions</h3><aside class="prompt" data-type="warning" data-title="" id="-8xy1u6_443"><p id="-8xy1u6_447">Support for calling <code class="code" id="-8xy1u6_448">suspend</code> functions from Swift code as <code class="code" id="-8xy1u6_449">async</code> is <a href="components-stability.html" id="-8xy1u6_450" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in aâ€¦">Experimental</a>. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="-8xy1u6_451" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-8xy1u6_444">Kotlin's <span id="-8xy1u6_452">suspending functions</span> (<code class="code" id="-8xy1u6_453">suspend</code>) are presented in the generated Objective-C headers as functions with callbacks, or <a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" id="-8xy1u6_454" data-external="true" rel="noopener noreferrer" target="_blank">completion handlers</a> in Swift/Objective-C terminology.</p><p id="-8xy1u6_445">Starting from Swift 5.5, Kotlin's <code class="code" id="-8xy1u6_455">suspend</code> functions are also available for calling from Swift as <code class="code" id="-8xy1u6_456">async</code> functions without using the completion handlers. Currently, this functionality is highly experimental and has certain limitations. See <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="-8xy1u6_457" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack issue</a> for details.</p><ul class="list _bullet" id="-8xy1u6_446"><li class="list__item" id="-8xy1u6_458"><p id="-8xy1u6_460">Learn more about the <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" id="-8xy1u6_461" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-8xy1u6_462">async</code>/<code class="code" id="-8xy1u6_463">await</code> mechanism in the Swift documentation</a>.</p></li><li class="list__item" id="-8xy1u6_459"><p id="-8xy1u6_464">See an example and recommendations on third-party libraries that implement the same functionality in the <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/coroutines/Suspend%20functions.md" id="-8xy1u6_465" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin-Swift interopedia</a>.</p></li></ul></section><section class="chapter"><h3 id="extensions-and-category-members" data-toc="extensions-and-category-members">Extensions and category members</h3><p id="-8xy1u6_466">Members of Objective-C categories and Swift extensions are generally imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin, and the extension initializers aren't available as Kotlin constructors.</p><aside class="prompt" data-type="note" data-title="" id="-8xy1u6_467"><p id="-8xy1u6_471">Currently, there are two exceptions. Starting with Kotlin 1.8.20, category members that are declared in the same headers as the NSView class (from the AppKit framework) or UIView classes (from the UIKit framework) are imported as members of these classes. This means that you can override methods that subclass from NSView or UIView.</p></aside><p id="-8xy1u6_468">Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members, respectively. Kotlin extensions to other types are treated as <a href="#top-level-functions-and-properties" id="-8xy1u6_472" data-tooltip="Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class, for example:">top-level declarations</a> with an additional receiver parameter. These types include:</p><ul class="list _bullet" id="-8xy1u6_469"><li class="list__item" id="-8xy1u6_473"><p id="-8xy1u6_481">Kotlin <code class="code" id="-8xy1u6_482">String</code> type</p></li><li class="list__item" id="-8xy1u6_474"><p id="-8xy1u6_483">Kotlin collection types and subtypes</p></li><li class="list__item" id="-8xy1u6_475"><p id="-8xy1u6_484">Kotlin <code class="code" id="-8xy1u6_485">interface</code> types</p></li><li class="list__item" id="-8xy1u6_476"><p id="-8xy1u6_486">Kotlin primitive types</p></li><li class="list__item" id="-8xy1u6_477"><p id="-8xy1u6_487">Kotlin <code class="code" id="-8xy1u6_488">inline</code> classes</p></li><li class="list__item" id="-8xy1u6_478"><p id="-8xy1u6_489">Kotlin <code class="code" id="-8xy1u6_490">Any</code> type</p></li><li class="list__item" id="-8xy1u6_479"><p id="-8xy1u6_491">Kotlin function types and subtypes</p></li><li class="list__item" id="-8xy1u6_480"><p id="-8xy1u6_492">Objective-C classes and protocols</p></li></ul><p id="-8xy1u6_470"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/tree/main/docs/extensions" id="-8xy1u6_493" data-external="true" rel="noopener noreferrer" target="_blank">See a collection of examples in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="kotlin-singletons" data-toc="kotlin-singletons">Kotlin singletons</h3><p id="-8xy1u6_494">Kotlin singleton (made with an <code class="code" id="-8xy1u6_503">object</code> declaration, including <code class="code" id="-8xy1u6_504">companion object</code>) is imported to Swift/Objective-C as a class with a single instance.</p><p id="-8xy1u6_495">The instance is available through the <code class="code" id="-8xy1u6_505">shared</code> and <code class="code" id="-8xy1u6_506">companion</code> properties.</p><p id="-8xy1u6_496">For the following Kotlin code:</p><div class="code-block" data-lang="kotlin">
object MyObject {
    val x = &quot;Some value&quot;
}

class MyClass {
    companion object {
        val x = &quot;Some value&quot;
    }
}
</div><p id="-8xy1u6_498">Access these objects as follows:</p><div class="code-block" data-lang="swift">
MyObject.shared
MyObject.shared.x
MyClass.companion
MyClass.Companion.shared
</div><aside class="prompt" data-type="note" data-title="" id="-8xy1u6_500"><p id="-8xy1u6_507">Access objects through <code class="code" id="-8xy1u6_508">[MySingleton mySingleton]</code> in Objective-C and <code class="code" id="-8xy1u6_509">MySingleton()</code> in Swift has been deprecated.</p></aside><p id="-8xy1u6_501">See more examples in the Kotlin-Swift interopedia:</p><ul class="list _bullet" id="-8xy1u6_502"><li class="list__item" id="-8xy1u6_510"><p id="-8xy1u6_512"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Objects.md" id="-8xy1u6_513" data-external="true" rel="noopener noreferrer" target="_blank">How to access Kotlin objects using <code class="code" id="-8xy1u6_514">shared</code></a></p></li><li class="list__item" id="-8xy1u6_511"><p id="-8xy1u6_515"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/classesandinterfaces/Companion%20objects.md" id="-8xy1u6_516" data-external="true" rel="noopener noreferrer" target="_blank">How to access members of Kotlin companion objects from Swift</a>.</p></li></ul></section><section class="chapter"><h3 id="nsnumber" data-toc="nsnumber">NSNumber</h3><p id="-8xy1u6_517">Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, the <code class="code" id="-8xy1u6_519">kotlin.Int</code> box is represented as <code class="code" id="-8xy1u6_520">KotlinInt</code> class instance in Swift (or <code class="code" id="-8xy1u6_521">${prefix}Int</code> instance in Objective-C, where <code class="code" id="-8xy1u6_522">prefix</code> is the framework names prefix). These classes are derived from <code class="code" id="-8xy1u6_523">NSNumber</code>, so the instances are proper <code class="code" id="-8xy1u6_524">NSNumber</code>s supporting all corresponding operations.</p><p id="-8xy1u6_518"><code class="code" id="-8xy1u6_525">NSNumber</code> type is not automatically translated to Kotlin primitive types when used as a Swift/Objective-C parameter type or return value. The reason is that <code class="code" id="-8xy1u6_526">NSNumber</code> type doesn't provide enough information about a wrapped primitive value type, for example, <code class="code" id="-8xy1u6_527">NSNumber</code> is statically not known to be <code class="code" id="-8xy1u6_528">Byte</code>, <code class="code" id="-8xy1u6_529">Boolean</code>, or <code class="code" id="-8xy1u6_530">Double</code>. So Kotlin primitive values should be <a href="#casting-between-mapped-types" id="-8xy1u6_531" data-tooltip="When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case, a plain old Kotlin cast can be used, for example:">cast to and from <code class="code" id="-8xy1u6_532">NSNumber</code> manually</a>.</p></section><section class="chapter"><h3 id="nsmutablestring" data-toc="nsmutablestring">NSMutableString</h3><p id="-8xy1u6_533"><code class="code" id="-8xy1u6_534">NSMutableString</code> Objective-C class is not available from Kotlin. All instances of <code class="code" id="-8xy1u6_535">NSMutableString</code> are copied when passed to Kotlin.</p></section><section class="chapter"><h3 id="collections" data-toc="collections">Collections</h3><p id="-8xy1u6_536">Kotlin collections are converted to Swift/Objective-C collections as described in the <a href="#mappings" id="-8xy1u6_539" data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.">table above</a>. Swift/Objective-C collections are mapped to Kotlin in the same way, except for <code class="code" id="-8xy1u6_540">NSMutableSet</code> and <code class="code" id="-8xy1u6_541">NSMutableDictionary</code>.</p><p id="-8xy1u6_537"><code class="code" id="-8xy1u6_542">NSMutableSet</code> isn't converted to a Kotlin <code class="code" id="-8xy1u6_543">MutableSet</code>. To pass an object to Kotlin <code class="code" id="-8xy1u6_544">MutableSet</code>, explicitly create this kind of Kotlin collection. To do this, use, for example, the <code class="code" id="-8xy1u6_545">mutableSetOf()</code> function in Kotlin or the <code class="code" id="-8xy1u6_546">KotlinMutableSet</code> class in Swift and <code class="code" id="-8xy1u6_547">${prefix}MutableSet</code> in Objective-C (<code class="code" id="-8xy1u6_548">prefix</code> is the framework names prefix). The same is true for <code class="code" id="-8xy1u6_549">MutableMap</code>.</p><p id="-8xy1u6_538"><a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/Collections.md" id="-8xy1u6_550" data-external="true" rel="noopener noreferrer" target="_blank">See an example in the Kotlin-Swift interopedia</a>.</p></section><section class="chapter"><h3 id="function-types" data-toc="function-types">Function types</h3><p id="-8xy1u6_551">Kotlin function-typed objects (for example, lambdas) are converted to functions in Swift and blocks in Objective-C. <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/functionsandproperties/Functions%20returning%20function%20type.md" id="-8xy1u6_559" data-external="true" rel="noopener noreferrer" target="_blank">See an example of a Kotlin function with a lambda in the Kotlin-Swift interopedia</a>.</p><p id="-8xy1u6_552">However, there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case, primitive types are mapped to their boxed representation. Kotlin <code class="code" id="-8xy1u6_560">Unit</code> return value is represented as a corresponding <code class="code" id="-8xy1u6_561">Unit</code> singleton in Swift/Objective-C. The value of this singleton can be retrieved the same way as for any other Kotlin <code class="code" id="-8xy1u6_562">object</code>. See singletons in the <a href="#mappings" id="-8xy1u6_563" data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.">table above</a>.</p><p id="-8xy1u6_553">Consider the following Kotlin function:</p><div class="code-block" data-lang="kotlin">
fun foo(block: (Int) -&gt; Unit) { ... }
</div><p id="-8xy1u6_555">It's represented in Swift as follows:</p><div class="code-block" data-lang="swift">
func foo(block: (KotlinInt) -&gt; KotlinUnit)
</div><p id="-8xy1u6_557">And you can call it like this:</p><div class="code-block" data-lang="kotlin">
foo {
    bar($0 as! Int32)
    return KotlinUnit()
}
</div></section><section class="chapter"><h3 id="generics" data-toc="generics">Generics</h3><p id="-8xy1u6_564">Objective-C supports &quot;lightweight generics&quot; defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</p><p id="-8xy1u6_565">Generic feature support for Objective-C and Swift differ from Kotlin, so the translation will inevitably lose some information, but the features supported retain meaningful information.</p><p id="-8xy1u6_566">For specific examples on how to use Kotlin generics in Swift, see the <a href="https://github.com/kotlin-hands-on/kotlin-swift-interopedia/blob/main/docs/overview/ShouldRefineInSwift.md" id="-8xy1u6_572" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin-Swift interopedia</a>.</p><section class="chapter"><h4 id="limitations" data-toc="limitations">Limitations</h4><p id="-8xy1u6_573">Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</p><p id="-8xy1u6_574">Generics can only be defined on classes, not on interfaces (protocols in Objective-C and Swift) or functions.</p></section><section class="chapter"><h4 id="nullability" data-toc="nullability">Nullability</h4><p id="-8xy1u6_575">Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. So, the following Kotlin code:</p><div class="code-block" data-lang="kotlin">
class Sample&lt;T&gt;() {
    fun myVal(): T
}
</div><p id="-8xy1u6_577">Looks in Swift like this:</p><div class="code-block" data-lang="swift">
class Sample&lt;T&gt;() {
    fun myVal(): T?
}
</div><p id="-8xy1u6_579">To support a potentially nullable type, the Objective-C header needs to define <code class="code" id="-8xy1u6_583">myVal</code> with a nullable return value.</p><p id="-8xy1u6_580">To mitigate this, when defining your generic classes, provide a non-nullable type constraint if the generic type should <span class="emphasis" id="-8xy1u6_584">never</span> be null:</p><div class="code-block" data-lang="kotlin">
class Sample&lt;T : Any&gt;() {
    fun myVal(): T
}
</div><p id="-8xy1u6_582">That will force the Objective-C header to mark <code class="code" id="-8xy1u6_585">myVal</code> as non-nullable.</p></section><section class="chapter"><h4 id="variance" data-toc="variance">Variance</h4><p id="-8xy1u6_586">Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</p><div class="code-block" data-lang="kotlin">
data class SomeData(val num: Int = 42) : BaseData()
class GenVarOut&lt;out T : Any&gt;(val arg: T)
</div><div class="code-block" data-lang="swift">
let variOut = GenVarOut&lt;SomeData&gt;(arg: sd)
let variOutAny : GenVarOut&lt;BaseData&gt; = variOut as! GenVarOut&lt;BaseData&gt;
</div></section><section class="chapter"><h4 id="constraints" data-toc="constraints">Constraints</h4><p id="-8xy1u6_589">In Kotlin, you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-nullable upper bound will make Objective-C methods/properties non-nullable.</p></section><section class="chapter"><h4 id="to-disable" data-toc="to-disable">To disable</h4><p id="-8xy1u6_590">To have the framework header written without generics, add the following compiler option in your build file:</p><div class="code-block" data-lang="kotlin">
binaries.framework {
    freeCompilerArgs += &quot;-Xno-objc-generics&quot;
}
</div></section></section><section class="chapter"><h3 id="forward-declarations" data-toc="forward-declarations">Forward declarations</h3><p id="-8xy1u6_592">To import forward declarations, use the <code class="code" id="-8xy1u6_599">objcnames.classes</code> and <code class="code" id="-8xy1u6_600">objcnames.protocols</code> packages. For example, to import a <code class="code" id="-8xy1u6_601">objcprotocolName</code> forward declaration declared in an Objective-C library with a <code class="code" id="-8xy1u6_602">library.package</code>, use a special forward declaration package: <code class="code" id="-8xy1u6_603">import objcnames.protocols.objcprotocolName</code>.</p><p id="-8xy1u6_593">Consider two objcinterop libraries: one that uses <code class="code" id="-8xy1u6_604">objcnames.protocols.ForwardDeclaredProtocolProtocol</code> and another with an actual implementation in another package:</p><div class="code-block" data-lang="objectivec">
// First objcinterop library
#import &lt;Foundation/Foundation.h&gt;

@protocol ForwardDeclaredProtocol;

NSString* consumeProtocol(id&lt;ForwardDeclaredProtocol&gt; s) {
    return [NSString stringWithUTF8String:&quot;Protocol&quot;];
}
</div><div class="code-block" data-lang="objectivec">
// Second objcinterop library
// Header:
#import &lt;Foundation/Foundation.h&gt;
@protocol ForwardDeclaredProtocol
@end
// Implementation:
@interface ForwardDeclaredProtocolImpl : NSObject &lt;ForwardDeclaredProtocol&gt;
@end

id&lt;ForwardDeclaredProtocol&gt; produceProtocol() {
    return [ForwardDeclaredProtocolImpl new];
}
</div><p id="-8xy1u6_596">To transfer objects between the two libraries, use an explicit <code class="code" id="-8xy1u6_605">as</code> cast in you Kotlin code:</p><div class="code-block" data-lang="kotlin">
// Kotlin code:
fun test() {
    consumeProtocol(produceProtocol() as objcnames.protocols.ForwardDeclaredProtocolProtocol)
}
</div><aside class="prompt" data-type="note" data-title="" id="-8xy1u6_598"><p id="-8xy1u6_606">Ypu can only cast to <code class="code" id="-8xy1u6_607">objcnames.protocols.ForwardDeclaredProtocolProtocol</code> from the corresponding real class. Otherwise, you'll get an error.</p></aside></section></section><section class="chapter"><h2 id="casting-between-mapped-types" data-toc="casting-between-mapped-types">Casting between mapped types</h2><p id="-8xy1u6_608">When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case, a plain old Kotlin cast can be used, for example:</p><div class="code-block" data-lang="kotlin">
val nsArray = listOf(1, 2, 3) as NSArray
val string = nsString as String
val nsNumber = 42 as NSNumber
</div></section><section class="chapter"><h2 id="subclassing" data-toc="subclassing">Subclassing</h2><section class="chapter"><h3 id="subclassing-kotlin-classes-and-interfaces-from-swift-objective-c" data-toc="subclassing-kotlin-classes-and-interfaces-from-swift-objective-c">Subclassing Kotlin classes and interfaces from Swift/Objective-C</h3><p id="-8xy1u6_612">Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</p></section><section class="chapter"><h3 id="subclassing-swift-objective-c-classes-and-protocols-from-kotlin" data-toc="subclassing-swift-objective-c-classes-and-protocols-from-kotlin">Subclassing Swift/Objective-C classes and protocols from Kotlin</h3><p id="-8xy1u6_613">Swift/Objective-C classes and protocols can be subclassed with a Kotlin <code class="code" id="-8xy1u6_620">final</code> class. Non-<code class="code" id="-8xy1u6_621">final</code> Kotlin classes inheriting Swift/Objective-C types aren't supported yet, so it is not possible to declare a complex class hierarchy inheriting Swift/Objective-C types.</p><p id="-8xy1u6_614">Normal methods can be overridden using the <code class="code" id="-8xy1u6_622">override</code> Kotlin keyword. In this case, the overriding method must have the same parameter names as the overridden one.</p><p id="-8xy1u6_615">Sometimes it is required to override initializers, for example when subclassing <code class="code" id="-8xy1u6_623">UIViewController</code>. Initializers imported as Kotlin constructors can be overridden by Kotlin constructors marked with the <code class="code" id="-8xy1u6_624">@OverrideInit</code> annotation:</p><div class="code-block" data-lang="swift">
class ViewController : UIViewController {
    @OverrideInit constructor(coder: NSCoder) : super(coder)

    ...
}
</div><p id="-8xy1u6_617">The overriding constructor must have the same parameter names and types as the overridden one.</p><p id="-8xy1u6_618">To override different methods with clashing Kotlin signatures, you can add the <code class="code" id="-8xy1u6_625">@ObjCSignatureOverride</code> annotation to the class. The annotation instructs the Kotlin compiler to ignore conflicting overloads, in case several functions with the same argument types, but different argument names, are inherited from the Objective-C class.</p><p id="-8xy1u6_619">By default, the Kotlin/Native compiler doesn't allow calling a non-designated Objective-C initializer as a <code class="code" id="-8xy1u6_626">super()</code> constructor. This behaviour can be inconvenient if the designated initializers aren't marked properly in the Objective-C library. To disable these compiler checks, add the <code class="code" id="-8xy1u6_627">disableDesignatedInitializerChecks = true</code> to the library's <a href="native-definition-file.html" id="-8xy1u6_628" data-tooltip="Kotlin/Native enables you to consume C and Objective-C libraries, allowing you to use their functionality in Kotlin. A special tool called cinterop takes a C or an Objective-C library and generates the corresponding Kotlin bindings, so that the library's methods can be used in yourâ€¦"><code class="code" id="-8xy1u6_629">.def</code> file</a>.</p></section></section><section class="chapter"><h2 id="c-features" data-toc="c-features">C features</h2><p id="-8xy1u6_630">See <a href="native-c-interop.html" id="-8xy1u6_631" data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation.">Interoperability with C</a> for an example case where the library uses some plain C features, such as unsafe pointers, structs, and so on.</p></section><section class="chapter"><h2 id="unsupported" data-toc="unsupported">Unsupported</h2><p id="-8xy1u6_632">Some features of Kotlin programming language are not yet mapped into the respective features of Objective-C or Swift. Currently, the following features are not properly exposed in generated framework headers:</p><ul class="list _bullet" id="-8xy1u6_633"><li class="list__item" id="-8xy1u6_634"><p id="-8xy1u6_637">Inline classes (arguments are mapped as either underlying primitive type or <code class="code" id="-8xy1u6_638">id</code>)</p></li><li class="list__item" id="-8xy1u6_635"><p id="-8xy1u6_639">Custom classes implementing standard Kotlin collection interfaces (<code class="code" id="-8xy1u6_640">List</code>, <code class="code" id="-8xy1u6_641">Map</code>, <code class="code" id="-8xy1u6_642">Set</code>) and other special classes</p></li><li class="list__item" id="-8xy1u6_636"><p id="-8xy1u6_643">Kotlin subclasses of Objective-C classes</p></li></ul></section><div class="last-modified">19 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="native-app-with-c-and-libcurl.html" class="navigation-links__prev">Create an app using C interop and libcurl &ndash; tutorial</a><a href="apple-framework.html" class="navigation-links__next">Kotlin/Native as an Apple framework &ndash; tutorial</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>