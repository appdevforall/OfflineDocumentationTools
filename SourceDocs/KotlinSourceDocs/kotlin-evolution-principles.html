<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T12:59:59.920385561"><title>Kotlin evolution principles | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"principles-of-pragmatic-evolution","level":0,"title":"Principles of pragmatic evolution","anchor":"#principles-of-pragmatic-evolution"},{"id":"incompatible-changes","level":0,"title":"Incompatible changes","anchor":"#incompatible-changes"},{"id":"dealing-with-compiler-bugs","level":1,"title":"Dealing with compiler bugs","anchor":"#dealing-with-compiler-bugs"},{"id":"decision-making","level":0,"title":"Decision making","anchor":"#decision-making"},{"id":"language-and-tooling-releases","level":0,"title":"Language and tooling releases","anchor":"#language-and-tooling-releases"},{"id":"eap-builds","level":1,"title":"EAP builds","anchor":"#eap-builds"},{"id":"pre-stable-features","level":1,"title":"Pre-stable features","anchor":"#pre-stable-features"},{"id":"status-of-different-components","level":1,"title":"Status of different components","anchor":"#status-of-different-components"},{"id":"libraries","level":0,"title":"Libraries","anchor":"#libraries"},{"id":"compiler-options","level":0,"title":"Compiler options","anchor":"#compiler-options"},{"id":"compatibility-tools","level":0,"title":"Compatibility tools","anchor":"#compatibility-tools"},{"id":"compatibility-options","level":1,"title":"Compatibility options","anchor":"#compatibility-options"},{"id":"evolving-the-binary-format","level":1,"title":"Evolving the binary format","anchor":"#evolving-the-binary-format"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Kotlin evolution principles | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/kotlin-evolution-principles.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Kotlin evolution principles | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/kotlin-evolution-principles.html#webpage",
    "url": "writerside-documentation/kotlin-evolution-principles.html",
    "name": "Kotlin evolution principles | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="kotlin-evolution-principles" data-main-title="Kotlin evolution principles" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Kotlin evolution and roadmap"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="kotlin-evolution-principles" id="kotlin-evolution-principles.md">Kotlin evolution principles</h1><section class="chapter"><h2 id="principles-of-pragmatic-evolution" data-toc="principles-of-pragmatic-evolution">Principles of pragmatic evolution</h2><aside class="prompt" data-type="tip" data-title="" id="n6dwxc_9"><p id="n6dwxc_16"><span class="emphasis" id="n6dwxc_20">Language design is cast in stone,</span></p><p id="n6dwxc_17"><span class="emphasis" id="n6dwxc_21">but this stone is reasonably soft,</span></p><p id="n6dwxc_18"><span class="emphasis" id="n6dwxc_22">and with some effort we can reshape it later.</span></p><p id="n6dwxc_19"><span class="emphasis" id="n6dwxc_23">Kotlin Design Team</span></p></aside><p id="n6dwxc_10">Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</p><ul class="list _bullet" id="n6dwxc_11"><li class="list__item" id="n6dwxc_24"><p id="n6dwxc_27">Keep the language modern over time.</p></li><li class="list__item" id="n6dwxc_25"><p id="n6dwxc_28">Maintain a continuous feedback loop with users.</p></li><li class="list__item" id="n6dwxc_26"><p id="n6dwxc_29">Make updating to new versions easy and comfortable for the users.</p></li></ul><p id="n6dwxc_12">As this is key to understanding how Kotlin is moving forward, let's expand on these principles.</p><p id="n6dwxc_13"><span class="control" id="n6dwxc_30">Keeping the Language Modern</span>. We recognize that systems accumulate legacy over time. What was once been cutting-edge technology can become hopelessly outdated today. We have to evolve the language to keep it relevant to the needs of our users and up-to-date with their expectations. This includes not only adding new features, but also phasing out old ones that are no longer recommended for production use and have become legacy.</p><p id="n6dwxc_14"><span class="control" id="n6dwxc_31">Comfortable Updates</span>. Incompatible changes, such as removing things from a language, may lead to painful migration from one version to the next if carried out without proper care. We will always announce such changes well in advance, mark things as deprecated and provide automated migration tools <span class="emphasis" id="n6dwxc_32">before the change happens</span>. By the time the language changes we want most of the code in the world to be already updated and thus have no issues migrating to the new version.</p><p id="n6dwxc_15"><span class="control" id="n6dwxc_33">Feedback Loop</span>. Going through deprecation cycles requires significant effort, so we want to minimize the number of incompatible changes we'll be making in the future. Apart from using our best judgement, we believe that trying things out in real life is the best way to validate a design. Before casting things in stone we want them battle-tested. This is why we use every opportunity to make early versions of our designs available in production versions of the language, but in one of the <span class="emphasis" id="n6dwxc_34">pre-stable</span> statuses: <a href="components-stability.html" id="n6dwxc_35" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental, Alpha, or Beta</a>. Such features are not stable, they can be changed at any time, and the users that opt into using them do so explicitly to indicate that they are ready to deal with the future migration issues. These users provide invaluable feedback that we gather to iterate on the design and make it rock-solid.</p></section><section class="chapter"><h2 id="incompatible-changes" data-toc="incompatible-changes">Incompatible changes</h2><p id="n6dwxc_36">If, upon updating from one version to another, some code that used to work doesn't work anymore, it is an <span class="emphasis" id="n6dwxc_46">incompatible change</span> in the language (sometimes referred to as a &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work anymore&quot; means precisely in some cases, but it definitely includes the following:</p><ul class="list _bullet" id="n6dwxc_37"><li class="list__item" id="n6dwxc_47"><p id="n6dwxc_49">Code that compiled and ran fine is now rejected with an error (at compile or link time). This includes removing language constructs and adding new restrictions.</p></li><li class="list__item" id="n6dwxc_48"><p id="n6dwxc_50">Code that executed normally is now throwing an exception.</p></li></ul><p id="n6dwxc_38">The less obvious cases that belong to the &quot;gray area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, modifying undocumented or undefined behavior, renaming binary artifacts, and others. Sometimes such changes are crucial and affect migration experience dramatically, sometimes they are insignificant.</p><p id="n6dwxc_39">Some examples of what definitely isn't an incompatible change include:</p><ul class="list _bullet" id="n6dwxc_40"><li class="list__item" id="n6dwxc_51"><p id="n6dwxc_54">Adding new warnings.</p></li><li class="list__item" id="n6dwxc_52"><p id="n6dwxc_55">Enabling new language constructs or relaxing limitations for existing ones.</p></li><li class="list__item" id="n6dwxc_53"><p id="n6dwxc_56">Changing private/internal APIs and other implementation details.</p></li></ul><p id="n6dwxc_41">The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make users aware of upcoming changes well in advance to let them migrate their code comfortably.</p><p id="n6dwxc_42">Ideally, every incompatible change should be announced through a compile-time warning reported in the problematic code (usually referred to as a <span class="emphasis" id="n6dwxc_57">deprecation warning</span>) and accompanied by automated migration aids. So, the ideal migration workflow is as follows:</p><ul class="list _bullet" id="n6dwxc_43"><li class="list__item" id="n6dwxc_58"><p id="n6dwxc_60">Update to version A (where the change is announced)</p><ul class="list _bullet" id="n6dwxc_61"><li class="list__item" id="n6dwxc_62"><p id="n6dwxc_64">See warnings about the upcoming change</p></li><li class="list__item" id="n6dwxc_63"><p id="n6dwxc_65">Migrate the code with help from tools</p></li></ul></li><li class="list__item" id="n6dwxc_59"><p id="n6dwxc_66">Update to version B (where the change happens)</p><ul class="list _bullet" id="n6dwxc_67"><li class="list__item" id="n6dwxc_68"><p id="n6dwxc_69">See no issues at all</p></li></ul></li></ul><p id="n6dwxc_44">In practice, some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through the release notes of version A that a change is coming in version B.</p><section class="chapter"><h3 id="dealing-with-compiler-bugs" data-toc="dealing-with-compiler-bugs">Dealing with compiler bugs</h3><p id="n6dwxc_70">Compilers are complicated software, and despite the best efforts of their developers, they have bugs. The bugs that cause the compiler itself to fail or report spurious errors or generate obviously failing code, though annoying and often embarrassing, are easy to fix, because the fixes do not constitute incompatible changes. Other bugs may cause the compiler to generate incorrect code that does not fail: for example, by missing some errors in the source or simply generating the wrong instructions. Fixes for such bugs are technically incompatible changes (some code used to compile fine, but now it won't anymore), but we are inclined to fix them as soon as possible to prevent the bad code patterns from spreading across user code. In our opinion, this supports the principle of Comfortable Updates, because fewer users have a chance of encountering the issue. Of course, this applies only to bugs that are found soon after appearing in a released version.</p></section></section><section class="chapter"><h2 id="decision-making" data-toc="decision-making">Decision making</h2><p id="n6dwxc_71"><a href="https://jetbrains.com" id="n6dwxc_74" data-external="true" rel="noopener noreferrer" target="_blank">JetBrains</a>, the original creator of Kotlin, is driving its progress with the help of the community and in collaboration with the <a href="https://kotlinfoundation.org/" id="n6dwxc_75" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Foundation</a>.</p><p id="n6dwxc_72">All changes to the Kotlin Programming Language are overseen by the <a href="https://kotlinfoundation.org/structure/" id="n6dwxc_76" data-external="true" rel="noopener noreferrer" target="_blank">Lead Language Designer</a> (currently Michail Zarečenskij). The Lead Designer has the final say in all matters related to language evolution. Additionally, incompatible changes to fully stable components have to be approved by the <a href="https://kotlinfoundation.org/structure/" id="n6dwxc_77" data-external="true" rel="noopener noreferrer" target="_blank">Language Committee</a>, designated under the <a href="https://kotlinfoundation.org/structure/" id="n6dwxc_78" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Foundation</a> (currently comprising Jeffrey van Gogh, Werner Dietl, and Michail Zarečenskij).</p><p id="n6dwxc_73">The Language Committee makes final decisions on which incompatible changes will be made and what exact measures should be taken to make user updates as seamless as possible. In doing so, it relies on a set of <a href="https://kotlinfoundation.org/language-committee-guidelines/" id="n6dwxc_79" data-external="true" rel="noopener noreferrer" target="_blank">Language committee guidelines</a>.</p></section><section class="chapter"><h2 id="language-and-tooling-releases" data-toc="language-and-tooling-releases">Language and tooling releases</h2><p id="n6dwxc_80">Stable releases with versions, such as 2.0.0, are usually considered to be <span class="emphasis" id="n6dwxc_86">language releases</span> bringing major changes in the language. Normally, we publish <span class="emphasis" id="n6dwxc_87">tooling releases</span>, numbered x.x. <span class="control" id="n6dwxc_88">20</span> in between language releases.</p><p id="n6dwxc_81">Tooling releases bring updates in the tooling (often including features), performance improvements, and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may be added, removed, or changed at any time.</p><p id="n6dwxc_82">Language releases often add new features and may remove or change previously deprecated ones. Feature graduation from pre-stable to stable also happens in language releases.</p><section class="chapter"><h3 id="eap-builds" data-toc="eap-builds">EAP builds</h3><p id="n6dwxc_89">Before releasing stable versions of language and tooling releases, we publish a number of preview builds dubbed EAP (for &quot;Early Access Preview&quot;) that let us iterate faster and gather feedback from the community. EAPs of language releases usually produce binaries that will be later rejected by the stable compiler to make sure that possible bugs in the binary format survive no longer than the preview period. Final Release Candidates normally do not bear this limitation.</p></section><section class="chapter"><h3 id="pre-stable-features" data-toc="pre-stable-features">Pre-stable features</h3><p id="n6dwxc_90">According to the Feedback Loop principle described above, we iterate on our designs in the open and release versions of the language where some features have one of the <span class="emphasis" id="n6dwxc_94">pre-stable</span> statuses and <span class="emphasis" id="n6dwxc_95">are supposed to change</span>. Such features can be added, changed or removed at any point and without warning. We do our best to ensure that pre-stable features can't be used accidentally by an unsuspecting user. Such features usually require some sort of explicit opt-in either in the code or in the project configuration.</p><p id="n6dwxc_91">A Kotlin language feature can have one of the following statuses:</p><ul class="list _bullet" id="n6dwxc_92"><li class="list__item" id="n6dwxc_96"><p id="n6dwxc_101"><span class="control" id="n6dwxc_102">Exploration and design</span>. We are considering the introduction of a new feature to the language. This involves discussing how it would integrate with existing features, gathering use cases, and assessing its potential impact. We need feedback from users on the problems this feature would solve and the use cases it addresses. Whenever possible, we try to estimate how often these use cases and problems occur would also be beneficial. Typically, ideas are documented as YouTrack issues, where the discussion continues.</p></li><li class="list__item" id="n6dwxc_97"><p id="n6dwxc_103"><span class="control" id="n6dwxc_104">KEEP discussion</span>. We are fairly certain that the feature should be added to the language. We aim to provide a motivation, use-cases, design, and other important details in a document called a <span class="emphasis" id="n6dwxc_105">KEEP</span>. We expect feedback from users to focus on discussing all the information provided in the KEEP.</p></li><li class="list__item" id="n6dwxc_98"><p id="n6dwxc_106"><span class="control" id="n6dwxc_107">In preview</span>. A feature prototype is ready, and you can enable it using a feature-specific compiler option. We seek feedback on your experience with the feature, including how easily it integrates into your codebase, how it interacts with existing code, and any IDE support issues or suggestions. The feature's design may change significantly, or it could be completely revoked based on feedback. When a feature is <span class="emphasis" id="n6dwxc_108">in preview</span>, it has a <a href="components-stability.html#stability-levels-explained" id="n6dwxc_109" data-tooltip="Here's a quick guide to these stability levels and their meaning:">stability level</a>.</p></li><li class="list__item" id="n6dwxc_99"><p id="n6dwxc_110"><span class="control" id="n6dwxc_111">Stable</span>. The language feature is now a first-class citizen in the Kotlin language. We guarantee its backward compatibility and that we'll provide tooling support.</p></li><li class="list__item" id="n6dwxc_100"><p id="n6dwxc_112"><span class="control" id="n6dwxc_113">Revoked</span>. We have revoked the proposal and will not implement the feature in the Kotlin language. We may revoke a feature that is <span class="emphasis" id="n6dwxc_114">in preview</span> if it is not a good fit for Kotlin.</p></li></ul><p id="n6dwxc_93"><a href="kotlin-language-features-and-proposals.html" id="n6dwxc_115" data-tooltip="JetBrains evolves the Kotlin language according to the Kotlin language evolution principles, guided by pragmatic design.">See the full list of Kotlin language proposals and their statuses</a>.</p></section><section class="chapter"><h3 id="status-of-different-components" data-toc="status-of-different-components">Status of different components</h3><p id="n6dwxc_116">Learn more about the <a href="components-stability.html" id="n6dwxc_117" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">stability status of different components in Kotlin</a>, such as Kotlin/JVM, JS, and Native compilers, and various libraries.</p></section></section><section class="chapter"><h2 id="libraries" data-toc="libraries">Libraries</h2><p id="n6dwxc_118">A language is nothing without its ecosystem, so we pay extra attention to enable smooth library evolution.</p><p id="n6dwxc_119">Ideally, a new version of a library can be used as a &quot;drop-in replacement&quot; for an older version. This means that upgrading a binary dependency should not break anything, even if the application is not recompiled (this is possible under dynamic linking).</p><p id="n6dwxc_120">On the one hand, to achieve this, the compiler has to provide certain <span class="emphasis" id="n6dwxc_126">Application Binary Interface</span> (ABI) stability guarantees under the constraints of separate compilation. This is why every change in the language is examined from a binary compatibility standpoint.</p><p id="n6dwxc_121">On the other hand, a lot depends on the library authors being careful about which changes are safe to make. Thus, it's crucial that library authors understand how source changes affect compatibility and follow certain best practices to keep both APIs and ABIs of their libraries stable. Here are some assumptions that we make when considering language changes from the library evolution standpoint:</p><ul class="list _bullet" id="n6dwxc_122"><li class="list__item" id="n6dwxc_127"><p id="n6dwxc_129">Library code should always specify return types of public/protected functions and properties explicitly, thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</p></li><li class="list__item" id="n6dwxc_128"><p id="n6dwxc_130">Overloaded functions and properties provided by the same library should do essentially the same thing. Changes in type inference may result in more precise static types to be known at call sites, causing changes in overload resolution.</p></li></ul><p id="n6dwxc_123">Library authors can use the <code class="code" id="n6dwxc_131">@Deprecated</code> and <a href="opt-in-requirements.html" id="n6dwxc_132" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…"><code class="code" id="n6dwxc_134">@RequiresOptIn</code></a> annotations to control the evolution of their API surface. Note that <code class="code" id="n6dwxc_133">@Deprecated(level=HIDDEN)</code> can be used to preserve binary compatibility even for declarations removed from the API.</p><p id="n6dwxc_124">Also, by convention, packages named &quot;internal&quot; are not considered public API. All API residing in packages named &quot;experimental&quot; is considered pre-stable and can change at any moment.</p><p id="n6dwxc_125">We evolve the Kotlin Standard Library (<code class="code" id="n6dwxc_135">kotlin-stdlib</code>) for stable platforms according to the principles stated above. Changes to the contracts for its API undergo the same procedures as changes in the language itself.</p></section><section class="chapter"><h2 id="compiler-options" data-toc="compiler-options">Compiler options</h2><p id="n6dwxc_136">Command line options accepted by the compiler are also a kind of public API, and they are subject to the same considerations. Supported options (those that don't have the &quot;-X&quot; or &quot;-XX&quot; prefix) can be added only in language releases and should be properly deprecated before removing them. The &quot;-X&quot; and &quot;-XX&quot; options are experimental and can be added and removed at any time.</p></section><section class="chapter"><h2 id="compatibility-tools" data-toc="compatibility-tools">Compatibility tools</h2><p id="n6dwxc_137">As legacy features get removed and bugs fixed, the source language changes, and old code that has not been properly migrated may not compile anymore. The normal deprecation cycle allows a comfortable period of time for migration, and even when it's over and the change ships in a stable version, there's still a way to compile non-migrated code.</p><section class="chapter"><h3 id="compatibility-options" data-toc="compatibility-options">Compatibility options</h3><p id="n6dwxc_140">We provide the <code class="code" id="n6dwxc_143">-language-version X.Y</code> and <code class="code" id="n6dwxc_144">-api-version X.Y</code> options that make a new version emulate the behavior of an old one for compatibility purposes. To give you more time for migration, we <a href="compatibility-modes.html" id="n6dwxc_145" data-tooltip="When a big team is migrating onto a new version, it may appear in an &quot;inconsistent state&quot; at some point, when some developers have already updated but others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide…">support</a> the three previous language and API versions in addition to the latest stable one.</p><p id="n6dwxc_141">Actively maintained code bases can benefit from getting bug fixes as soon as possible, without waiting for a full deprecation cycle to complete. Currently, such projects can enable the <code class="code" id="n6dwxc_146">-progressive</code> option and get such fixes enabled even in tooling releases.</p><p id="n6dwxc_142">All options are available in the command line as well as in <a href="gradle-compiler-options.html" id="n6dwxc_147" data-tooltip="Each release of Kotlin includes compilers for the supported targets: JVM, JavaScript, and native binaries for supported platforms.">Gradle</a> and in <a href="maven.html#specify-compiler-options" id="n6dwxc_148" data-tooltip="Additional options and arguments for the compiler can be specified as tags under the &lt;configuration&gt; element of the Maven plugin node:">Maven</a>.</p></section><section class="chapter"><h3 id="evolving-the-binary-format" data-toc="evolving-the-binary-format">Evolving the binary format</h3><p id="n6dwxc_149">Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility crucial in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</p><p id="n6dwxc_150">For fully stable versions of the compiler, the default binary compatibility protocol is the following:</p><ul class="list _bullet" id="n6dwxc_151"><li class="list__item" id="n6dwxc_155"><p id="n6dwxc_158">All binaries are backwards compatible; that means a newer compiler can read older binaries (for example, 1.3 understands 1.0 through 1.2).</p></li><li class="list__item" id="n6dwxc_156"><p id="n6dwxc_159">Older compilers reject binaries that rely on new features (for example, the 1.0 compiler rejects binaries that use coroutines).</p></li><li class="list__item" id="n6dwxc_157"><p id="n6dwxc_160">Preferably (but we can't guarantee it), the binary format is mostly forwards compatible with the next language release, but not later ones (in the cases when new features are not used, for example, 1.9 can understand most binaries from 2.0, but not 2.1).</p></li></ul><p id="n6dwxc_152">This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</p><p id="n6dwxc_153">Note that not all target platforms have reached this level of stability, but Kotlin/JVM has.</p><section class="chapter"><h4 id="kotlin-klib-binaries" data-toc="kotlin-klib-binaries">Kotlin klib binaries</h4><p id="n6dwxc_161">Kotlin klib binaries have reached the <a href="components-stability.html#stability-levels-explained" id="n6dwxc_164" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Stable</a> level in Kotlin 1.9.20. However, there are some compatibility details you need to keep in mind:</p><ul class="list _bullet" id="n6dwxc_162"><li class="list__item" id="n6dwxc_165"><p id="n6dwxc_167">klib binaries are backwards compatible starting with Kotlin 1.9.20. For example, the 2.0.x compiler can read binaries produced by the 1.9.2x compiler.</p></li><li class="list__item" id="n6dwxc_166"><p id="n6dwxc_168">Forward compatibility is <span class="emphasis" id="n6dwxc_169">not</span> guaranteed. For example, the 2.0.x compiler is <span class="emphasis" id="n6dwxc_170">not</span> guaranteed to read binaries produced by the 2.1.x compiler.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="n6dwxc_163"><p id="n6dwxc_171">The Kotlin cinterop klib binaries are still in <a href="components-stability.html#stability-levels-explained" id="n6dwxc_172" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Beta</a>. Currently, we cannot give specific compatibility guarantees between different Kotlin versions for cinterop klib binaries.</p></aside></section></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="kotlin-language-features-and-proposals.html" class="navigation-links__prev">Kotlin language features and proposals</a><a href="components-stability.html" class="navigation-links__next">Stability of Kotlin components</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>