<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:02.641044057"><title>What's new in Kotlin 1.1 | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"table-of-contents","level":0,"title":"Table of contents","anchor":"#table-of-contents"},{"id":"javascript","level":0,"title":"JavaScript","anchor":"#javascript"},{"id":"coroutines-experimental","level":0,"title":"Coroutines (experimental)","anchor":"#coroutines-experimental"},{"id":"other-language-features","level":0,"title":"Other language features","anchor":"#other-language-features"},{"id":"type-aliases","level":1,"title":"Type aliases","anchor":"#type-aliases"},{"id":"bound-callable-references","level":1,"title":"Bound callable references","anchor":"#bound-callable-references"},{"id":"sealed-and-data-classes","level":1,"title":"Sealed and data classes","anchor":"#sealed-and-data-classes"},{"id":"destructuring-in-lambdas","level":1,"title":"Destructuring in lambdas","anchor":"#destructuring-in-lambdas"},{"id":"underscores-for-unused-parameters","level":1,"title":"Underscores for unused parameters","anchor":"#underscores-for-unused-parameters"},{"id":"underscores-in-numeric-literals","level":1,"title":"Underscores in numeric literals","anchor":"#underscores-in-numeric-literals"},{"id":"shorter-syntax-for-properties","level":1,"title":"Shorter syntax for properties","anchor":"#shorter-syntax-for-properties"},{"id":"inline-property-accessors","level":1,"title":"Inline property accessors","anchor":"#inline-property-accessors"},{"id":"local-delegated-properties","level":1,"title":"Local delegated properties","anchor":"#local-delegated-properties"},{"id":"interception-of-delegated-property-binding","level":1,"title":"Interception of delegated property binding","anchor":"#interception-of-delegated-property-binding"},{"id":"generic-enum-value-access","level":1,"title":"Generic enum value access","anchor":"#generic-enum-value-access"},{"id":"scope-control-for-implicit-receivers-in-dsls","level":1,"title":"Scope control for implicit receivers in DSLs","anchor":"#scope-control-for-implicit-receivers-in-dsls"},{"id":"rem-operator","level":1,"title":"rem operator","anchor":"#rem-operator"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"string-to-number-conversions","level":1,"title":"String to number conversions","anchor":"#string-to-number-conversions"},{"id":"oneach","level":1,"title":"onEach()","anchor":"#oneach"},{"id":"also-takeif-and-takeunless","level":1,"title":"also(), takeIf(), and takeUnless()","anchor":"#also-takeif-and-takeunless"},{"id":"groupingby","level":1,"title":"groupingBy()","anchor":"#groupingby"},{"id":"map-tomap-and-map-tomutablemap","level":1,"title":"Map.toMap() and Map.toMutableMap()","anchor":"#map-tomap-and-map-tomutablemap"},{"id":"map-minus-key","level":1,"title":"Map.minus(key)","anchor":"#map-minus-key"},{"id":"minof-and-maxof","level":1,"title":"minOf() and maxOf()","anchor":"#minof-and-maxof"},{"id":"array-like-list-instantiation-functions","level":1,"title":"Array-like List instantiation functions","anchor":"#array-like-list-instantiation-functions"},{"id":"map-getvalue","level":1,"title":"Map.getValue()","anchor":"#map-getvalue"},{"id":"abstract-collections","level":1,"title":"Abstract collections","anchor":"#abstract-collections"},{"id":"array-manipulation-functions","level":1,"title":"Array manipulation functions","anchor":"#array-manipulation-functions"},{"id":"jvm-backend","level":0,"title":"JVM Backend","anchor":"#jvm-backend"},{"id":"java-8-bytecode-support","level":1,"title":"Java 8 bytecode support","anchor":"#java-8-bytecode-support"},{"id":"java-8-standard-library-support","level":1,"title":"Java 8 standard library support","anchor":"#java-8-standard-library-support"},{"id":"parameter-names-in-the-bytecode","level":1,"title":"Parameter names in the bytecode","anchor":"#parameter-names-in-the-bytecode"},{"id":"constant-inlining","level":1,"title":"Constant inlining","anchor":"#constant-inlining"},{"id":"mutable-closure-variables","level":1,"title":"Mutable closure variables","anchor":"#mutable-closure-variables"},{"id":"javax-script-support","level":1,"title":"javax.script support","anchor":"#javax-script-support"},{"id":"kotlin-reflect-full","level":1,"title":"kotlin.reflect.full","anchor":"#kotlin-reflect-full"},{"id":"javascript-backend","level":0,"title":"JavaScript backend","anchor":"#javascript-backend"},{"id":"unified-standard-library","level":1,"title":"Unified standard library","anchor":"#unified-standard-library"},{"id":"better-code-generation","level":1,"title":"Better code generation","anchor":"#better-code-generation"},{"id":"the-external-modifier","level":1,"title":"The external modifier","anchor":"#the-external-modifier"},{"id":"improved-import-handling","level":1,"title":"Improved import handling","anchor":"#improved-import-handling"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.1 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/whatsnew11.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="What's new in Kotlin 1.1 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/whatsnew11.html#webpage",
    "url": "writerside-documentation/whatsnew11.html",
    "name": "What's new in Kotlin 1.1 | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="whatsnew11" data-main-title="What's new in Kotlin 1.1" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew11" id="whatsnew11.md">What's new in Kotlin 1.1</h1><p id="-t8ub1o_2"><span class="emphasis" id="-t8ub1o_10">Released: 15 February 2016</span></p><section class="chapter"><h2 id="table-of-contents" data-toc="table-of-contents">Table of contents</h2><ul class="list _bullet" id="-t8ub1o_11"><li class="list__item" id="-t8ub1o_12"><p id="-t8ub1o_17"><a href="#coroutines-experimental" id="-t8ub1o_18" data-tooltip="The key new feature in Kotlin 1.1 is coroutines, bringing the support of async/await, yield, and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any…">Coroutines</a></p></li><li class="list__item" id="-t8ub1o_13"><p id="-t8ub1o_19"><a href="#other-language-features" id="-t8ub1o_20" data-tooltip="A type alias allows you to define an alternative name for an existing type. This is most useful for generic types such as collections, as well as for function types. Here is an example:">Other language features</a></p></li><li class="list__item" id="-t8ub1o_14"><p id="-t8ub1o_21"><a href="#standard-library" id="-t8ub1o_22" data-tooltip="There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: String.toIntOrNull(): Int?, String.toDoubleOrNull(): Double? etc.">Standard library</a></p></li><li class="list__item" id="-t8ub1o_15"><p id="-t8ub1o_23"><a href="#jvm-backend" id="-t8ub1o_24" data-tooltip="Kotlin has now the option of generating Java 8 bytecode (-jvm-target 1.8 command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly…">JVM backend</a></p></li><li class="list__item" id="-t8ub1o_16"><p id="-t8ub1o_25"><a href="#javascript-backend" id="-t8ub1o_26" data-tooltip="A much larger part of the Kotlin standard library can now be used from code compiled to JavaScript. In particular, key classes such as collections (ArrayList, HashMap etc.), exceptions (IllegalArgumentException etc.) and a few others (StringBuilder, Comparator) are now defined under…">JavaScript backend</a></p></li></ul></section><section class="chapter"><h2 id="javascript" data-toc="javascript">JavaScript</h2><p id="-t8ub1o_27">Starting with Kotlin 1.1, the JavaScript target is no longer considered experimental. All language features are supported, and there are many new tools for integration with the frontend development environment. See <a href="#javascript-backend" id="-t8ub1o_28" data-tooltip="A much larger part of the Kotlin standard library can now be used from code compiled to JavaScript. In particular, key classes such as collections (ArrayList, HashMap etc.), exceptions (IllegalArgumentException etc.) and a few others (StringBuilder, Comparator) are now defined under…">below</a> for a more detailed list of changes.</p></section><section class="chapter"><h2 id="coroutines-experimental" data-toc="coroutines-experimental">Coroutines (experimental)</h2><p id="-t8ub1o_29">The key new feature in Kotlin 1.1 is <span class="emphasis" id="-t8ub1o_39">coroutines</span>, bringing the support of <code class="code" id="-t8ub1o_40">async</code>/<code class="code" id="-t8ub1o_41">await</code>, <code class="code" id="-t8ub1o_42">yield</code>, and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</p><p id="-t8ub1o_30">A coroutine is effectively a light-weight thread that can be suspended and resumed later. Coroutines are supported through <span class="emphasis" id="-t8ub1o_43"><span id="-t8ub1o_44">suspending functions</span></span>: a call to such a function can potentially suspend a coroutine, and to start a new coroutine we usually use an anonymous suspending functions (i.e. suspending lambdas).</p><p id="-t8ub1o_31">Let's look at <code class="code" id="-t8ub1o_45">async</code>/<code class="code" id="-t8ub1o_46">await</code> which is implemented in an external library, <a href="https://github.com/kotlin/kotlinx.coroutines" id="-t8ub1o_47" data-external="true" rel="noopener noreferrer" target="_blank">kotlinx.coroutines</a>:</p><div class="code-block" data-lang="kotlin">
// runs the code in the background thread pool
fun asyncOverlay() = async(CommonPool) {
    // start two async operations
    val original = asyncLoadImage(&quot;original&quot;)
    val overlay = asyncLoadImage(&quot;overlay&quot;)
    // and then apply overlay to both results
    applyOverlay(original.await(), overlay.await())
}

// launches new coroutine in UI context
launch(UI) {
    // wait for async overlay to complete
    val image = asyncOverlay().await()
    // and then show it in UI
    showImage(image)
}
</div><p id="-t8ub1o_33">Here, <code class="code" id="-t8ub1o_48">async { ... }</code> starts a coroutine and, when we use <code class="code" id="-t8ub1o_49">await()</code>, the execution of the coroutine is suspended while the operation being awaited is executed, and is resumed (possibly on a different thread) when the operation being awaited completes.</p><p id="-t8ub1o_34">The standard library uses coroutines to support <span class="emphasis" id="-t8ub1o_50">lazily generated sequences</span> with <code class="code" id="-t8ub1o_51">yield</code> and <code class="code" id="-t8ub1o_52">yieldAll</code> functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</p><div class="code-block" data-lang="kotlin">
import kotlin.coroutines.experimental.*

fun main(args: Array&lt;String&gt;) {
    val seq = buildSequence {
      for (i in 1..5) {
          // yield a square of i
          yield(i * i)
      }
      // yield a range
      yieldAll(26..28)
    }

    // print the sequence
    println(seq.toList())
}
</div><p id="-t8ub1o_36">Run the code above to see the result. Feel free to edit it and run again!</p><p id="-t8ub1o_37">For more information, please refer to the <a href="coroutines-overview.html" id="-t8ub1o_53" data-tooltip="Asynchronous or non-blocking programming is an important part of the development landscape. When creating server-side, desktop, or mobile applications, it's important to provide an experience that is not only fluid from the user's perspective, but also scalable when needed.">coroutines documentation</a> and <span id="-t8ub1o_54">tutorial</span>.</p><p id="-t8ub1o_38">Note that coroutines are currently considered an <span class="control" id="-t8ub1o_55">experimental feature</span>, meaning that the Kotlin team is not committing to supporting the backwards compatibility of this feature after the final 1.1 release.</p></section><section class="chapter"><h2 id="other-language-features" data-toc="other-language-features">Other language features</h2><section class="chapter"><h3 id="type-aliases" data-toc="type-aliases">Type aliases</h3><p id="-t8ub1o_69">A type alias allows you to define an alternative name for an existing type. This is most useful for generic types such as collections, as well as for function types. Here is an example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
typealias OscarWinners = Map&lt;String, String&gt;

fun countLaLaLand(oscarWinners: OscarWinners) =
        oscarWinners.count { it.value.contains(&quot;La La Land&quot;) }

// Note that the type names (initial and the type alias) are interchangeable:
fun checkLaLaLandIsTheBestMovie(oscarWinners: Map&lt;String, String&gt;) =
        oscarWinners[&quot;Best picture&quot;] == &quot;La La Land&quot;
//sampleEnd

fun oscarWinners(): OscarWinners {
    return mapOf(
            &quot;Best song&quot; to &quot;City of Stars (La La Land)&quot;,
            &quot;Best actress&quot; to &quot;Emma Stone (La La Land)&quot;,
            &quot;Best picture&quot; to &quot;Moonlight&quot; /* ... */)
}

fun main(args: Array&lt;String&gt;) {
    val oscarWinners = oscarWinners()

    val laLaLandAwards = countLaLaLand(oscarWinners)
    println(&quot;LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.&quot;)

    val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners)
    println(&quot;LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie&quot;)
}
</div><p id="-t8ub1o_71">See the <a href="type-aliases.html" id="-t8ub1o_72" data-tooltip="Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.">type aliases documentation</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md" id="-t8ub1o_73" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="bound-callable-references" data-toc="bound-callable-references">Bound callable references</h3><p id="-t8ub1o_74">You can now use the <code class="code" id="-t8ub1o_77">::</code> operator to get a <a href="reflection.html#function-references" id="-t8ub1o_78" data-tooltip="When you have a named function declared as below, you can call it directly (isOdd(5)):">member reference</a> pointing to a method or property of a specific object instance. Previously this could only be expressed with a lambda. Here's an example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
val numberRegex = &quot;\\d+&quot;.toRegex()
val numbers = listOf(&quot;abc&quot;, &quot;123&quot;, &quot;456&quot;).filter(numberRegex::matches)
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    println(&quot;Result is $numbers&quot;)
}
</div><p id="-t8ub1o_76">Read the <a href="reflection.html" id="-t8ub1o_79" data-tooltip="Reflection is a set of language and library features that allows you to introspect the structure of your program at runtime. Functions and properties are first-class citizens in Kotlin, and the ability to introspect them (for example, learning the name or the type of a property or…">documentation</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/bound-callable-references.md" id="-t8ub1o_80" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="sealed-and-data-classes" data-toc="sealed-and-data-classes">Sealed and data classes</h3><p id="-t8ub1o_81">Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
sealed class Expr

data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when (expr) {
    is Const -&gt; expr.number
    is Sum -&gt; eval(expr.e1) + eval(expr.e2)
    NotANumber -&gt; Double.NaN
}
val e = eval(Sum(Const(1.0), Const(2.0)))
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    println(&quot;e is $e&quot;) // 3.0
}
</div><p id="-t8ub1o_83">Read the <a href="sealed-classes.html" id="-t8ub1o_84" data-tooltip="Sealed classes and interfaces provide controlled inheritance of your class hierarchies. All direct subclasses of a sealed class are known at compile time. No other subclasses may appear outside the module and package within which the sealed class is defined. The same logic applies…">sealed classes documentation</a> or KEEPs for <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/sealed-class-inheritance.md" id="-t8ub1o_85" data-external="true" rel="noopener noreferrer" target="_blank">sealed class</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/data-class-inheritance.md" id="-t8ub1o_86" data-external="true" rel="noopener noreferrer" target="_blank">data class</a> for more detail.</p></section><section class="chapter"><h3 id="destructuring-in-lambdas" data-toc="destructuring-in-lambdas">Destructuring in lambdas</h3><p id="-t8ub1o_87">You can now use the <a href="destructuring-declarations.html" id="-t8ub1o_90" data-tooltip="Sometimes it is convenient to destructure an object into a number of variables, for example:">destructuring declaration</a> syntax to unpack the arguments passed to a lambda. Here's an example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;)
    // before
    println(map.mapValues { entry -&gt;
      val (key, value) = entry
      &quot;$key -&gt; $value!&quot;
    })
    // now
    println(map.mapValues { (key, value) -&gt; &quot;$key -&gt; $value!&quot; })
//sampleEnd
}
</div><p id="-t8ub1o_89">Read the <a href="destructuring-declarations.html" id="-t8ub1o_91" data-tooltip="Sometimes it is convenient to destructure an object into a number of variables, for example:">destructuring declarations documentation</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/destructuring-in-parameters.md" id="-t8ub1o_92" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="underscores-for-unused-parameters" data-toc="underscores-for-unused-parameters">Underscores for unused parameters</h3><p id="-t8ub1o_93">For a lambda with multiple parameters, you can use the <code class="code" id="-t8ub1o_98">_</code> character to replace the names of the parameters you don't use:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
    val map = mapOf(1 to &quot;one&quot;, 2 to &quot;two&quot;)

//sampleStart
    map.forEach { _, value -&gt; println(&quot;$value!&quot;) }
//sampleEnd
}
</div><p id="-t8ub1o_95">This also works in <a href="destructuring-declarations.html" id="-t8ub1o_99" data-tooltip="Sometimes it is convenient to destructure an object into a number of variables, for example:">destructuring declarations</a>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
data class Result(val value: Any, val status: String)

fun getResult() = Result(42, &quot;ok&quot;).also { println(&quot;getResult() returns $it&quot;) }

fun main(args: Array&lt;String&gt;) {
//sampleStart
    val (_, status) = getResult()
//sampleEnd
    println(&quot;status is '$status'&quot;)
}
</div><p id="-t8ub1o_97">Read the <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/underscore-for-unused-parameters.md" id="-t8ub1o_100" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="underscores-in-numeric-literals" data-toc="underscores-in-numeric-literals">Underscores in numeric literals</h3><p id="-t8ub1o_101">Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
val oneMillion = 1_000_000
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    println(oneMillion)
    println(hexBytes.toString(16))
    println(bytes.toString(2))
}
</div><p id="-t8ub1o_103">Read the <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md" id="-t8ub1o_104" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="shorter-syntax-for-properties" data-toc="shorter-syntax-for-properties">Shorter syntax for properties</h3><p id="-t8ub1o_105">For properties with the getter defined as an expression body, the property type can now be omitted:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
    data class Person(val name: String, val age: Int) {
    val isAdult get() = age &gt;= 20 // Property type inferred to be 'Boolean'
}
//sampleEnd
fun main(args: Array&lt;String&gt;) {
    val akari = Person(&quot;Akari&quot;, 26)
    println(&quot;$akari.isAdult = ${akari.isAdult}&quot;)
}
</div></section><section class="chapter"><h3 id="inline-property-accessors" data-toc="inline-property-accessors">Inline property accessors</h3><p id="-t8ub1o_107">You can now mark property accessors with the <code class="code" id="-t8ub1o_111">inline</code> modifier if the properties don't have a backing field. Such accessors are compiled in the same way as <a href="inline-functions.html" id="-t8ub1o_112" data-tooltip="Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure. A closure is a scope of variables that can be accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls…">inline functions</a>.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
public val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    inline get() = this.size - 1
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    val list = listOf('a', 'b')
    // the getter will be inlined
    println(&quot;Last index of $list is ${list.lastIndex}&quot;)
}
</div><p id="-t8ub1o_109">You can also mark the entire property as <code class="code" id="-t8ub1o_113">inline</code> - then the modifier is applied to both accessors.</p><p id="-t8ub1o_110">Read the <a href="inline-functions.html#inline-properties" id="-t8ub1o_114" data-tooltip="The inline modifier can be used on accessors of properties that don't have backing fields. You can annotate individual property accessors:">inline functions documentation</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-properties.md" id="-t8ub1o_115" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="local-delegated-properties" data-toc="local-delegated-properties">Local delegated properties</h3><p id="-t8ub1o_116">You can now use the <a href="delegated-properties.html" id="-t8ub1o_119" data-tooltip="With some common kinds of properties, even though you can implement them manually every time you need them, it is more helpful to implement them once, add them to a library, and reuse them later. For example:">delegated property</a> syntax with local variables. One possible use is defining a lazily evaluated local variable:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
import java.util.Random

fun needAnswer() = Random().nextBoolean()

fun main(args: Array&lt;String&gt;) {
//sampleStart
    val answer by lazy {
        println(&quot;Calculating the answer...&quot;)
        42
    }
    if (needAnswer()) {                     // returns the random value
        println(&quot;The answer is $answer.&quot;)   // answer is calculated at this point
    }
    else {
        println(&quot;Sometimes no answer is the answer...&quot;)
    }
//sampleEnd
}
</div><p id="-t8ub1o_118">Read the <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/local-delegated-properties.md" id="-t8ub1o_120" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="interception-of-delegated-property-binding" data-toc="interception-of-delegated-property-binding">Interception of delegated property binding</h3><p id="-t8ub1o_121">For <a href="delegated-properties.html" id="-t8ub1o_125" data-tooltip="With some common kinds of properties, even though you can implement them manually every time you need them, it is more helpful to implement them once, add them to a library, and reuse them later. For example:">delegated properties</a>, it is now possible to intercept delegate to property binding using the <code class="code" id="-t8ub1o_126">provideDelegate</code> operator. For example, if we want to check the property name before binding, we can write something like this:</p><div class="code-block" data-lang="kotlin">
class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) {
    operator fun provideDelegate(thisRef: MyUI, prop: KProperty&lt;*&gt;): ReadOnlyProperty&lt;MyUI, T&gt; {
        checkProperty(thisRef, prop.name)
        ... // property creation
    }

    private fun checkProperty(thisRef: MyUI, name: String) { ... }
}

fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; { ... }

class MyUI {
    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}
</div><p id="-t8ub1o_123">The <code class="code" id="-t8ub1o_127">provideDelegate</code> method will be called for each property during the creation of a <code class="code" id="-t8ub1o_128">MyUI</code> instance, and it can perform the necessary validation right away.</p><p id="-t8ub1o_124">Read the <a href="delegated-properties.html" id="-t8ub1o_129" data-tooltip="With some common kinds of properties, even though you can implement them manually every time you need them, it is more helpful to implement them once, add them to a library, and reuse them later. For example:">delegated properties documentation</a> for more details.</p></section><section class="chapter"><h3 id="generic-enum-value-access" data-toc="generic-enum-value-access">Generic enum value access</h3><p id="-t8ub1o_130">It is now possible to enumerate the values of an enum class in a generic way.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
enum class RGB { RED, GREEN, BLUE }

inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() {
    print(enumValues&lt;T&gt;().joinToString { it.name })
}
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    printAllValues&lt;RGB&gt;() // prints RED, GREEN, BLUE
}
</div></section><section class="chapter"><h3 id="scope-control-for-implicit-receivers-in-dsls" data-toc="scope-control-for-implicit-receivers-in-dsls">Scope control for implicit receivers in DSLs</h3><p id="-t8ub1o_132">The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/index.html" id="-t8ub1o_137" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8ub1o_139">@DslMarker</code></a> annotation allows to restrict the use of receivers from outer scopes in a DSL context. Consider the canonical <a href="type-safe-builders.html" id="-t8ub1o_138" data-tooltip="By using well-named functions as builders in combination with function literals with receiver it is possible to create type-safe, statically-typed builders in Kotlin.">HTML builder example</a>:</p><div class="code-block" data-lang="kotlin">
table {
    tr {
        td { + &quot;Text&quot; }
    }
}
</div><p id="-t8ub1o_134">In Kotlin 1.0, code in the lambda passed to <code class="code" id="-t8ub1o_140">td</code> has access to three implicit receivers: the one passed to <code class="code" id="-t8ub1o_141">table</code>, to <code class="code" id="-t8ub1o_142">tr</code> and to <code class="code" id="-t8ub1o_143">td</code>. This allows you to call methods that make no sense in the context - for example to call <code class="code" id="-t8ub1o_144">tr</code> inside <code class="code" id="-t8ub1o_145">td</code> and thus to put a <code class="code" id="-t8ub1o_146">&lt;tr&gt;</code> tag in a <code class="code" id="-t8ub1o_147">&lt;td&gt;</code>.</p><p id="-t8ub1o_135">In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of <code class="code" id="-t8ub1o_148">td</code> will be available inside the lambda passed to <code class="code" id="-t8ub1o_149">td</code>. You do that by defining your annotation marked with the <code class="code" id="-t8ub1o_150">@DslMarker</code> meta-annotation and applying it to the base class of the tag classes.</p><p id="-t8ub1o_136">Read the <a href="type-safe-builders.html" id="-t8ub1o_151" data-tooltip="By using well-named functions as builders in combination with function literals with receiver it is possible to create type-safe, statically-typed builders in Kotlin.">type safe builders documentation</a> and <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md" id="-t8ub1o_152" data-external="true" rel="noopener noreferrer" target="_blank">KEEP</a> for more details.</p></section><section class="chapter"><h3 id="rem-operator" data-toc="rem-operator">rem operator</h3><p id="-t8ub1o_153">The <code class="code" id="-t8ub1o_154">mod</code> operator is now deprecated, and <code class="code" id="-t8ub1o_155">rem</code> is used instead. See <a href="https://youtrack.jetbrains.com/issue/KT-14650" id="-t8ub1o_156" data-external="true" rel="noopener noreferrer" target="_blank">this issue</a> for motivation.</p></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><section class="chapter"><h3 id="string-to-number-conversions" data-toc="string-to-number-conversions">String to number conversions</h3><p id="-t8ub1o_168">There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: <code class="code" id="-t8ub1o_171">String.toIntOrNull(): Int?</code>, <code class="code" id="-t8ub1o_172">String.toDoubleOrNull(): Double?</code> etc.</p><div class="code-block" data-lang="kotlin">
val port = System.getenv(&quot;PORT&quot;)?.toIntOrNull() ?: 80
</div><p id="-t8ub1o_170">Also integer conversion functions, like <code class="code" id="-t8ub1o_173">Int.toString()</code>, <code class="code" id="-t8ub1o_174">String.toInt()</code>, <code class="code" id="-t8ub1o_175">String.toIntOrNull()</code>, each got an overload with <code class="code" id="-t8ub1o_176">radix</code> parameter, which allows to specify the base of conversion (2 to 36).</p></section><section class="chapter"><h3 id="oneach" data-toc="oneach">onEach()</h3><p id="-t8ub1o_177"><code class="code" id="-t8ub1o_179">onEach</code> is a small, but useful extension function for collections and sequences, which allows to perform some action, possibly with side-effects, on each element of the collection/sequence in a chain of operations. On iterables it behaves like <code class="code" id="-t8ub1o_180">forEach</code> but also returns the iterable instance further. And on sequences it returns a wrapping sequence, which applies the given action lazily as the elements are being iterated.</p><div class="code-block" data-lang="kotlin">
inputDir.walk()
        .filter { it.isFile &amp;&amp; it.name.endsWith(&quot;.txt&quot;) }
        .onEach { println(&quot;Moving $it to $outputDir&quot;) }
        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }
</div></section><section class="chapter"><h3 id="also-takeif-and-takeunless" data-toc="also-takeif-and-takeunless">also(), takeIf(), and takeUnless()</h3><p id="-t8ub1o_181">These are three general-purpose extension functions applicable to any receiver.</p><p id="-t8ub1o_182"><code class="code" id="-t8ub1o_191">also</code> is like <code class="code" id="-t8ub1o_192">apply</code>: it takes the receiver, does some action on it, and returns that receiver. The difference is that in the block inside <code class="code" id="-t8ub1o_193">apply</code> the receiver is available as <code class="code" id="-t8ub1o_194">this</code>, while in the block inside <code class="code" id="-t8ub1o_195">also</code> it's available as <code class="code" id="-t8ub1o_196">it</code> (and you can give it another name if you want). This comes handy when you do not want to shadow <code class="code" id="-t8ub1o_197">this</code> from the outer scope:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
class Block {
    lateinit var content: String
}

//sampleStart
fun Block.copy() = Block().also {
    it.content = this.content
}
//sampleEnd

// using 'apply' instead
fun Block.copy1() = Block().apply {
    this.content = this@copy1.content
}

fun main(args: Array&lt;String&gt;) {
    val block = Block().apply { content = &quot;content&quot; }
    val copy = block.copy()
    println(&quot;Testing the content was copied:&quot;)
    println(block.content == copy.content)
}
</div><p id="-t8ub1o_184"><code class="code" id="-t8ub1o_198">takeIf</code> is like <code class="code" id="-t8ub1o_199">filter</code> for a single value. It checks whether the receiver meets the predicate, and returns the receiver, if it does or <code class="code" id="-t8ub1o_200">null</code> if it doesn't. Combined with an elvis operator (?:) and early returns it allows writing constructs like:</p><div class="code-block" data-lang="kotlin">
val outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false
// do something with existing outDirFile
</div><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
    val input = &quot;Kotlin&quot;
    val keyword = &quot;in&quot;

//sampleStart
    val index = input.indexOf(keyword).takeIf { it &gt;= 0 } ?: error(&quot;keyword not found&quot;)
    // do something with index of keyword in input string, given that it's found
//sampleEnd
    
    println(&quot;'$keyword' was found in '$input'&quot;)
    println(input)
    println(&quot; &quot;.repeat(index) + &quot;^&quot;)
}
</div><p id="-t8ub1o_187"><code class="code" id="-t8ub1o_201">takeUnless</code> is the same as <code class="code" id="-t8ub1o_202">takeIf</code>, but it takes the inverted predicate. It returns the receiver when it <span class="emphasis" id="-t8ub1o_203">doesn't</span> meet the predicate and <code class="code" id="-t8ub1o_204">null</code> otherwise. So one of the examples above could be rewritten with <code class="code" id="-t8ub1o_205">takeUnless</code> as following:</p><div class="code-block" data-lang="kotlin">
val index = input.indexOf(keyword).takeUnless { it &lt; 0 } ?: error(&quot;keyword not found&quot;)
</div><p id="-t8ub1o_189">It is also convenient to use when you have a callable reference instead of the lambda:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
private fun testTakeUnless(string: String) {
//sampleStart
    val result = string.takeUnless(String::isEmpty)
//sampleEnd

    println(&quot;string = \&quot;$string\&quot;; result = \&quot;$result\&quot;&quot;)
}

fun main(args: Array&lt;String&gt;) {
    testTakeUnless(&quot;&quot;)
    testTakeUnless(&quot;abc&quot;)
}
</div></section><section class="chapter"><h3 id="groupingby" data-toc="groupingby">groupingBy()</h3><p id="-t8ub1o_206">This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
    val words = &quot;one two three four five six seven eight nine ten&quot;.split(' ')
//sampleStart
    val frequencies = words.groupingBy { it.first() }.eachCount()
//sampleEnd
    println(&quot;Counting first letters: $frequencies.&quot;)

    // The alternative way that uses 'groupBy' and 'mapValues' creates an intermediate map, 
    // while 'groupingBy' way counts on the fly.
    val groupBy = words.groupBy { it.first() }.mapValues { (_, list) -&gt; list.size }
    println(&quot;Comparing the result with using 'groupBy': ${groupBy == frequencies}.&quot;)
}
</div></section><section class="chapter"><h3 id="map-tomap-and-map-tomutablemap" data-toc="map-tomap-and-map-tomutablemap">Map.toMap() and Map.toMutableMap()</h3><p id="-t8ub1o_208">These functions can be used for easy copying of maps:</p><div class="code-block" data-lang="kotlin">
class ImmutablePropertyBag(map: Map&lt;String, Any&gt;) {
    private val mapCopy = map.toMap()
}
</div></section><section class="chapter"><h3 id="map-minus-key" data-toc="map-minus-key">Map.minus(key)</h3><p id="-t8ub1o_210">The operator <code class="code" id="-t8ub1o_212">plus</code> provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like <code class="code" id="-t8ub1o_213">Map.filter()</code> or <code class="code" id="-t8ub1o_214">Map.filterKeys()</code>. Now the operator <code class="code" id="-t8ub1o_215">minus</code> fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val map = mapOf(&quot;key&quot; to 42)
    val emptyMap = map - &quot;key&quot;
//sampleEnd
    
    println(&quot;map: $map&quot;)
    println(&quot;emptyMap: $emptyMap&quot;)
}
</div></section><section class="chapter"><h3 id="minof-and-maxof" data-toc="minof-and-maxof">minOf() and maxOf()</h3><p id="-t8ub1o_216">These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or <code class="code" id="-t8ub1o_218">Comparable</code> objects. There is also an overload of each function that take an additional <code class="code" id="-t8ub1o_219">Comparator</code> instance if you want to compare objects that are not comparable themselves.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val list1 = listOf(&quot;a&quot;, &quot;b&quot;)
    val list2 = listOf(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
    val minSize = minOf(list1.size, list2.size)
    val longestList = maxOf(list1, list2, compareBy { it.size })
//sampleEnd
    
    println(&quot;minSize = $minSize&quot;)
    println(&quot;longestList = $longestList&quot;)
}
</div></section><section class="chapter"><h3 id="array-like-list-instantiation-functions" data-toc="array-like-list-instantiation-functions">Array-like List instantiation functions</h3><p id="-t8ub1o_220">Similar to the <code class="code" id="-t8ub1o_222">Array</code> constructor, there are now functions that create <code class="code" id="-t8ub1o_223">List</code> and <code class="code" id="-t8ub1o_224">MutableList</code> instances and initialize each element by calling a lambda:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val squares = List(10) { index -&gt; index * index }
    val mutable = MutableList(10) { 0 }
//sampleEnd

    println(&quot;squares: $squares&quot;)
    println(&quot;mutable: $mutable&quot;)
}
</div></section><section class="chapter"><h3 id="map-getvalue" data-toc="map-getvalue">Map.getValue()</h3><p id="-t8ub1o_225">This extension on <code class="code" id="-t8ub1o_227">Map</code> returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with <code class="code" id="-t8ub1o_228">withDefault</code>, this function will return the default value instead of throwing an exception.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart    
    val map = mapOf(&quot;key&quot; to 42)
    // returns non-nullable Int value 42
    val value: Int = map.getValue(&quot;key&quot;)

    val mapWithDefault = map.withDefault { k -&gt; k.length }
    // returns 4
    val value2 = mapWithDefault.getValue(&quot;key2&quot;)

    // map.getValue(&quot;anotherKey&quot;) // &lt;- this will throw NoSuchElementException
//sampleEnd
    
    println(&quot;value is $value&quot;)
    println(&quot;value2 is $value2&quot;)
}
</div></section><section class="chapter"><h3 id="abstract-collections" data-toc="abstract-collections">Abstract collections</h3><p id="-t8ub1o_229">These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are <code class="code" id="-t8ub1o_230">AbstractCollection</code>, <code class="code" id="-t8ub1o_231">AbstractList</code>, <code class="code" id="-t8ub1o_232">AbstractSet</code> and <code class="code" id="-t8ub1o_233">AbstractMap</code>, and for mutable collections there are <code class="code" id="-t8ub1o_234">AbstractMutableCollection</code>, <code class="code" id="-t8ub1o_235">AbstractMutableList</code>, <code class="code" id="-t8ub1o_236">AbstractMutableSet</code> and <code class="code" id="-t8ub1o_237">AbstractMutableMap</code>. On JVM, these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</p></section><section class="chapter"><h3 id="array-manipulation-functions" data-toc="array-manipulation-functions">Array manipulation functions</h3><p id="-t8ub1o_238">The standard library now provides a set of functions for element-by-element operations on arrays: comparison (<code class="code" id="-t8ub1o_240">contentEquals</code> and <code class="code" id="-t8ub1o_241">contentDeepEquals</code>), hash code calculation (<code class="code" id="-t8ub1o_242">contentHashCode</code> and <code class="code" id="-t8ub1o_243">contentDeepHashCode</code>), and conversion to a string (<code class="code" id="-t8ub1o_244">contentToString</code> and <code class="code" id="-t8ub1o_245">contentDeepToString</code>). They're supported both for the JVM (where they act as aliases for the corresponding functions in <code class="code" id="-t8ub1o_246">java.util.Arrays</code>) and for JS (where the implementation is provided in the Kotlin standard library).</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
    println(array.toString())  // JVM implementation: type-and-hash gibberish
    println(array.contentToString())  // nicely formatted as list
//sampleEnd
}
</div></section></section><section class="chapter"><h2 id="jvm-backend" data-toc="jvm-backend">JVM Backend</h2><section class="chapter"><h3 id="java-8-bytecode-support" data-toc="java-8-bytecode-support">Java 8 bytecode support</h3><p id="-t8ub1o_254">Kotlin has now the option of generating Java 8 bytecode (<code class="code" id="-t8ub1o_255">-jvm-target 1.8</code> command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</p></section><section class="chapter"><h3 id="java-8-standard-library-support" data-toc="java-8-standard-library-support">Java 8 standard library support</h3><p id="-t8ub1o_256">There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use <code class="code" id="-t8ub1o_257">kotlin-stdlib-jre7</code> and <code class="code" id="-t8ub1o_258">kotlin-stdlib-jre8</code> maven artifacts instead of the standard <code class="code" id="-t8ub1o_259">kotlin-stdlib</code>. These artifacts are tiny extensions on top of <code class="code" id="-t8ub1o_260">kotlin-stdlib</code> and they bring it to your project as a transitive dependency.</p></section><section class="chapter"><h3 id="parameter-names-in-the-bytecode" data-toc="parameter-names-in-the-bytecode">Parameter names in the bytecode</h3><p id="-t8ub1o_261">Kotlin now supports storing parameter names in the bytecode. This can be enabled using the <code class="code" id="-t8ub1o_262">-java-parameters</code> command line option.</p></section><section class="chapter"><h3 id="constant-inlining" data-toc="constant-inlining">Constant inlining</h3><p id="-t8ub1o_263">The compiler now inlines values of <code class="code" id="-t8ub1o_264">const val</code> properties into the locations where they are used.</p></section><section class="chapter"><h3 id="mutable-closure-variables" data-toc="mutable-closure-variables">Mutable closure variables</h3><p id="-t8ub1o_265">The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</p></section><section class="chapter"><h3 id="javax-script-support" data-toc="javax-script-support">javax.script support</h3><p id="-t8ub1o_266">Kotlin now integrates with the <a href="https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html" id="-t8ub1o_269" data-external="true" rel="noopener noreferrer" target="_blank">javax.script API</a> (JSR-223). The API allows to evaluate snippets of code at runtime:</p><div class="code-block" data-lang="kotlin">
val engine = ScriptEngineManager().getEngineByExtension(&quot;kts&quot;)!!
engine.eval(&quot;val x = 3&quot;)
println(engine.eval(&quot;x + 2&quot;))  // Prints out 5
</div><p id="-t8ub1o_268">See <a href="https://github.com/JetBrains/kotlin/tree/1.1.0/libraries/examples/kotlin-jsr223-local-example" id="-t8ub1o_270" data-external="true" rel="noopener noreferrer" target="_blank">here</a> for a larger example project using the API.</p></section><section class="chapter"><h3 id="kotlin-reflect-full" data-toc="kotlin-reflect-full">kotlin.reflect.full</h3><p id="-t8ub1o_271">To <a href="https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/" id="-t8ub1o_272" data-external="true" rel="noopener noreferrer" target="_blank">prepare for Java 9 support</a>, the extension functions and properties in the <code class="code" id="-t8ub1o_273">kotlin-reflect.jar</code> library have been moved to the package <code class="code" id="-t8ub1o_274">kotlin.reflect.full</code>. The names in the old package (<code class="code" id="-t8ub1o_275">kotlin.reflect</code>) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as <code class="code" id="-t8ub1o_276">KClass</code>) are part of the Kotlin standard library, not <code class="code" id="-t8ub1o_277">kotlin-reflect</code>, and are not affected by the move.</p></section></section><section class="chapter"><h2 id="javascript-backend" data-toc="javascript-backend">JavaScript backend</h2><section class="chapter"><h3 id="unified-standard-library" data-toc="unified-standard-library">Unified standard library</h3><p id="-t8ub1o_282">A much larger part of the Kotlin standard library can now be used from code compiled to JavaScript. In particular, key classes such as collections (<code class="code" id="-t8ub1o_283">ArrayList</code>, <code class="code" id="-t8ub1o_284">HashMap</code> etc.), exceptions (<code class="code" id="-t8ub1o_285">IllegalArgumentException</code> etc.) and a few others (<code class="code" id="-t8ub1o_286">StringBuilder</code>, <code class="code" id="-t8ub1o_287">Comparator</code>) are now defined under the <code class="code" id="-t8ub1o_288">kotlin</code> package. On the JVM, the names are type aliases for the corresponding JDK classes, and on the JS, the classes are implemented in the Kotlin standard library.</p></section><section class="chapter"><h3 id="better-code-generation" data-toc="better-code-generation">Better code generation</h3><p id="-t8ub1o_289">JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</p></section><section class="chapter"><h3 id="the-external-modifier" data-toc="the-external-modifier">The external modifier</h3><p id="-t8ub1o_290">If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the <code class="code" id="-t8ub1o_292">external</code> modifier. (In Kotlin 1.0, the <code class="code" id="-t8ub1o_293">@native</code> annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM <code class="code" id="-t8ub1o_294">Node</code> class:</p><div class="code-block" data-lang="kotlin">
external class Node {
    val firstChild: Node

    fun appendChild(child: Node): Node

    fun removeChild(child: Node): Node

    // etc
}
</div></section><section class="chapter"><h3 id="improved-import-handling" data-toc="improved-import-handling">Improved import handling</h3><p id="-t8ub1o_295">You can now describe declarations which should be imported from JavaScript modules more precisely. If you add the <code class="code" id="-t8ub1o_301">@JsModule(&quot;&lt;module-name&gt;&quot;)</code> annotation on an external declaration it will be properly imported to a module system (either CommonJS or AMD) during the compilation. For example, with CommonJS the declaration will be imported via <code class="code" id="-t8ub1o_302">require(...)</code> function. Additionally, if you want to import a declaration either as a module or as a global JavaScript object, you can use the <code class="code" id="-t8ub1o_303">@JsNonModule</code> annotation.</p><p id="-t8ub1o_296">For example, here's how you can import JQuery into a Kotlin module:</p><div class="code-block" data-lang="kotlin">
external interface JQuery {
    fun toggle(duration: Int = definedExternally): JQuery
    fun click(handler: (Event) -&gt; Unit): JQuery
}

@JsModule(&quot;jquery&quot;)
@JsNonModule
@JsName(&quot;$&quot;)
external fun jquery(selector: String): JQuery
</div><p id="-t8ub1o_298">In this case, JQuery will be imported as a module named <code class="code" id="-t8ub1o_304">jquery</code>. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</p><p id="-t8ub1o_299">You can use these declarations in your application like this:</p><div class="code-block" data-lang="kotlin">
fun main(args: Array&lt;String&gt;) {
    jquery(&quot;.toggle-button&quot;).click {
        jquery(&quot;.toggle-panel&quot;).toggle(300)
    }
}
</div></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew12.html" class="navigation-links__prev">What's new in Kotlin 1.2</a><a href="roadmap.html" class="navigation-links__next">Kotlin roadmap</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>