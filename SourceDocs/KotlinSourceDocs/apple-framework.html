<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T12:59:59.920386782"><title>Kotlin/Native as an Apple framework &ndash; tutorial | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"create-a-kotlin-library","level":0,"title":"Create a Kotlin library","anchor":"#create-a-kotlin-library"},{"id":"generated-framework-headers","level":0,"title":"Generated framework headers","anchor":"#generated-framework-headers"},{"id":"kotlin-native-runtime-declarations","level":1,"title":"Kotlin/Native runtime declarations","anchor":"#kotlin-native-runtime-declarations"},{"id":"kotlin-numbers-and-nsnumber","level":1,"title":"Kotlin numbers and NSNumber","anchor":"#kotlin-numbers-and-nsnumber"},{"id":"classes-and-objects-from-kotlin","level":1,"title":"Classes and objects from Kotlin","anchor":"#classes-and-objects-from-kotlin"},{"id":"global-declarations-from-kotlin","level":1,"title":"Global declarations from Kotlin","anchor":"#global-declarations-from-kotlin"},{"id":"garbage-collection-and-reference-counting","level":0,"title":"Garbage collection and reference counting","anchor":"#garbage-collection-and-reference-counting"},{"id":"use-code-from-objective-c","level":0,"title":"Use code from Objective-C","anchor":"#use-code-from-objective-c"},{"id":"use-code-from-swift","level":0,"title":"Use code from Swift","anchor":"#use-code-from-swift"},{"id":"connect-the-framework-to-your-ios-project","level":0,"title":"Connect the framework to your iOS project","anchor":"#connect-the-framework-to-your-ios-project"},{"id":"what-s-next","level":0,"title":"What\u0027s next","anchor":"#what-s-next"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Kotlin/Native as an Apple framework &ndash; tutorial | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/apple-framework.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Kotlin/Native as an Apple framework &ndash; tutorial | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/apple-framework.html#webpage",
    "url": "writerside-documentation/apple-framework.html",
    "name": "Kotlin/Native as an Apple framework &ndash; tutorial | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="apple-framework" data-main-title="Kotlin/Native as an Apple framework – tutorial" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///Native///Objective-C interop"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="apple-framework" id="apple-framework.md">Kotlin/Native as an Apple framework – tutorial</h1><aside class="prompt" data-type="warning" data-title="" id="-n8lvq_2"><p id="-n8lvq_16">The Objective-C libraries import is <a href="components-stability.html#stability-levels-explained" id="-n8lvq_18" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the <code class="code" id="-n8lvq_19">@ExperimentalForeignApi</code> annotation.</p><p id="-n8lvq_17">Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.</p></aside><p id="-n8lvq_3">Kotlin/Native provides bidirectional interoperability with Swift/Objective-C. You can both use Objective-C frameworks and libraries in Kotlin code, and Kotlin modules in Swift/Objective-C code.</p><p id="-n8lvq_4">Kotlin/Native comes with a set of pre-imported system frameworks; it's also possible to import an existing framework and use it from Kotlin. In this tutorial, you'll learn how to create your own framework and use Kotlin/Native code from Swift/Objective-C applications on macOS and iOS.</p><p id="-n8lvq_5">In this tutorial, you will:</p><ul class="list _bullet" id="-n8lvq_6"><li class="list__item" id="-n8lvq_20"><p id="-n8lvq_24"><a href="#create-a-kotlin-library" id="-n8lvq_25" data-tooltip="See the Get started with Kotlin/Native tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.">Create a Kotlin library and compile it to a framework</a></p></li><li class="list__item" id="-n8lvq_21"><p id="-n8lvq_26"><a href="#generated-framework-headers" id="-n8lvq_27" data-tooltip="Each framework variant contains a header file. The headers don't depend on the target platform. Header files contain definitions for your Kotlin code and a few Kotlin-wide declarations. Let's see what's inside.">Examine the generated Swift/Objective-C API code</a></p></li><li class="list__item" id="-n8lvq_22"><p id="-n8lvq_28"><a href="#use-code-from-objective-c" id="-n8lvq_29" data-tooltip="Let's call the framework from Objective-C. In the framework directory, create the main.m file with the following code:">Use the framework from Objective-C</a></p></li><li class="list__item" id="-n8lvq_23"><p id="-n8lvq_30"><a href="#use-code-from-swift" id="-n8lvq_31" data-tooltip="The framework you generated has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift.">Use the framework from Swift</a></p></li></ul><p id="-n8lvq_7">You can use the command line to generate a Kotlin framework, either directly or with a script file (such as <code class="code" id="-n8lvq_32">.sh</code> or <code class="code" id="-n8lvq_33">.bat</code> file). However, this approach doesn't scale well for larger projects that have hundreds of files and libraries. Using a build system simplifies the process by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, as well as by running the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="-n8lvq_34" data-external="true" rel="noopener noreferrer" target="_blank">Gradle</a> build system through the <a href="gradle-configure-project.html#targeting-multiple-platforms" id="-n8lvq_35" data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin.">Kotlin Multiplatform plugin</a>.</p><aside class="prompt" data-type="note" data-title="" id="-n8lvq_8"><p id="-n8lvq_36">If you use a Mac and want to create and run applications for iOS or other Apple targets, you also need to install the <a href="https://developer.apple.com/download/" id="-n8lvq_37" data-external="true" rel="noopener noreferrer" target="_blank">Xcode Command Line Tools</a>, launch it, and accept the license terms first.</p></aside><section class="chapter"><h2 id="create-a-kotlin-library" data-toc="create-a-kotlin-library">Create a Kotlin library</h2><aside class="prompt" data-type="tip" data-title="" id="-n8lvq_38"><p id="-n8lvq_44">See the <a href="native-get-started.html#using-gradle" id="-n8lvq_45" data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems.">Get started with Kotlin/Native</a> tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.</p></aside><p id="-n8lvq_39">The Kotlin/Native compiler can produce a framework for macOS and iOS from the Kotlin code. The created framework contains all declarations and binaries needed to use it with Swift/Objective-C.</p><p id="-n8lvq_40">Let's first create a Kotlin library:</p><ol class="list _decimal" id="-n8lvq_41" type="1"><li class="list__item" id="-n8lvq_46"><p id="-n8lvq_49">In the <code class="code" id="-n8lvq_51">src/nativeMain/kotlin</code> directory, create the <code class="code" id="-n8lvq_52">lib.kt</code> file with the library contents:</p><div class="code-block" data-lang="kotlin">
package example

object Object {
    val field = &quot;A&quot;
}

interface Interface {
    fun iMember() {}
}

class Clazz : Interface {
    fun member(p: Int): ULong? = 42UL
}

fun forIntegers(b: Byte, s: UShort, i: Int, l: ULong?) { }
fun forFloats(f: Float, d: Double?) { }

fun strings(str: String?) : String {
    return &quot;That is '$str' from C&quot;
}

fun acceptFun(f: (String) -&gt; String?) = f(&quot;Kotlin/Native rocks!&quot;)
fun supplyFun() : (String) -&gt; String? = { &quot;$it is cool!&quot; }
</div></li><li class="list__item" id="-n8lvq_47"><p id="-n8lvq_53">Update your <code class="code" id="-n8lvq_59">build.gradle(.kts)</code> Gradle build file with the following:</p><div class="tabs" id="-n8lvq_54" data-group="build-script" data-anchors="[-n8lvq_60,-n8lvq_61]"><div class="tabs__content" data-gtm="tab" id="-n8lvq_60" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
plugins {
    kotlin(&quot;multiplatform&quot;) version &quot;2.1.20&quot;
}

repositories {
    mavenCentral()
}

kotlin {
    iosArm64(&quot;native&quot;) {
        binaries {
            framework {
                baseName = &quot;Demo&quot;
            }
        }
    }
}

tasks.wrapper {
    gradleVersion = &quot;8.10&quot;
    distributionType = Wrapper.DistributionType.ALL
}
</div></div><div class="tabs__content" data-gtm="tab" id="-n8lvq_61" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.20'
}

repositories {
    mavenCentral()
}

kotlin {
    iosArm64(&quot;native&quot;) {
        binaries {
            framework {
                baseName = &quot;Demo&quot;
            }
        }
    }
}

wrapper {
    gradleVersion = &quot;8.10&quot;
    distributionType = &quot;ALL&quot;
}
</div></div></div><p id="-n8lvq_55">The <code class="code" id="-n8lvq_64">binaries {}</code> block configures the project to generate a dynamic or shared library.</p><p id="-n8lvq_56">Kotlin/Native supports the <code class="code" id="-n8lvq_65">iosArm64</code>, <code class="code" id="-n8lvq_66">iosX64</code>, and <code class="code" id="-n8lvq_67">iosSimulatorArm64</code> targets for iOS, as well as <code class="code" id="-n8lvq_68">macosX64</code> and <code class="code" id="-n8lvq_69">macosArm64</code> targets for macOS. So, you can replace the <code class="code" id="-n8lvq_70">iosArm64()</code> with the respective Gradle function for your target platform:</p><div class="table-wrapper"><table class="wide" id="-n8lvq_57"><thead><tr class="ijRowHead" id="-n8lvq_71"><th id="-n8lvq_77"><p>Target platform/device</p></th><th id="-n8lvq_78"><p>Gradle function</p></th></tr></thead><tbody><tr id="-n8lvq_72"><td id="-n8lvq_79"><p>macOS x86_64</p></td><td id="-n8lvq_80"><p><code class="code" id="-n8lvq_81">macosX64()</code></p></td></tr><tr id="-n8lvq_73"><td id="-n8lvq_82"><p>macOS ARM64</p></td><td id="-n8lvq_83"><p><code class="code" id="-n8lvq_84">macosArm64()</code></p></td></tr><tr id="-n8lvq_74"><td id="-n8lvq_85"><p>iOS ARM64</p></td><td id="-n8lvq_86"><p><code class="code" id="-n8lvq_87">iosArm64()</code></p></td></tr><tr id="-n8lvq_75"><td id="-n8lvq_88"><p>iOS Simulator (x86_64)</p></td><td id="-n8lvq_89"><p><code class="code" id="-n8lvq_90">iosX64()</code></p></td></tr><tr id="-n8lvq_76"><td id="-n8lvq_91"><p>iOS Simulator (ARM64)</p></td><td id="-n8lvq_92"><p><code class="code" id="-n8lvq_93">iosSimulatorArm64()</code></p></td></tr></tbody></table></div><p id="-n8lvq_58">For information on other supported Apple targets, see <a href="native-target-support.html" id="-n8lvq_94" data-tooltip="The Kotlin/Native compiler supports a great number of different targets, though it is hard to provide the same level of support for all of them. This document describes which targets Kotlin/Native supports and breaks them into several tiers depending on how well the compiler…">Kotlin/Native target support</a>.</p></li><li class="list__item" id="-n8lvq_48"><p id="-n8lvq_95">Run the <code class="code" id="-n8lvq_97">linkDebugFrameworkNative</code> Gradle task in the IDE or use the following console command in your terminal to build the framework:</p><div class="code-block" data-lang="bash">
./gradlew linkDebugFrameworkNative
</div></li></ol><p id="-n8lvq_42">The build generates the framework into the <code class="code" id="-n8lvq_98">build/bin/native/debugFramework</code> directory.</p><aside class="prompt" data-type="tip" data-title="" id="-n8lvq_43"><p id="-n8lvq_99">You can also use the <code class="code" id="-n8lvq_100">linkNative</code> Gradle task to generate both <code class="code" id="-n8lvq_101">debug</code> and <code class="code" id="-n8lvq_102">release</code> variants of the framework.</p></aside></section><section class="chapter"><h2 id="generated-framework-headers" data-toc="generated-framework-headers">Generated framework headers</h2><p id="-n8lvq_103">Each framework variant contains a header file. The headers don't depend on the target platform. Header files contain definitions for your Kotlin code and a few Kotlin-wide declarations. Let's see what's inside.</p><section class="chapter"><h3 id="kotlin-native-runtime-declarations" data-toc="kotlin-native-runtime-declarations">Kotlin/Native runtime declarations</h3><p id="-n8lvq_108">In the <code class="code" id="-n8lvq_112">build/bin/native/debugFramework/Demo.framework/Headers</code> directory, open the <code class="code" id="-n8lvq_113">Demo.h</code> header file. Take a look at Kotlin runtime declarations:</p><div class="code-block" data-lang="objectivec">
NS_ASSUME_NONNULL_BEGIN
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wunknown-warning-option&quot;
#pragma clang diagnostic ignored &quot;-Wincompatible-property-type&quot;
#pragma clang diagnostic ignored &quot;-Wnullability&quot;

#pragma push_macro(&quot;_Nullable_result&quot;)
#if !__has_feature(nullability_nullable_result)
#undef _Nullable_result
#define _Nullable_result _Nullable
#endif

__attribute__((swift_name(&quot;KotlinBase&quot;)))
@interface DemoBase : NSObject
- (instancetype)init __attribute__((unavailable));
+ (instancetype)new __attribute__((unavailable));
+ (void)initialize __attribute__((objc_requires_super));
@end

@interface DemoBase (DemoBaseCopying) &lt;NSCopying&gt;
@end

__attribute__((swift_name(&quot;KotlinMutableSet&quot;)))
@interface DemoMutableSet&lt;ObjectType&gt; : NSMutableSet&lt;ObjectType&gt;
@end

__attribute__((swift_name(&quot;KotlinMutableDictionary&quot;)))
@interface DemoMutableDictionary&lt;KeyType, ObjectType&gt; : NSMutableDictionary&lt;KeyType, ObjectType&gt;
@end

@interface NSError (NSErrorDemoKotlinException)
@property (readonly) id _Nullable kotlinException;
@end
</div><p id="-n8lvq_110">Kotlin classes have a <code class="code" id="-n8lvq_114">KotlinBase</code> base class in Swift/Objective-C that extends the <code class="code" id="-n8lvq_115">NSObject</code> class there. There are also wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types in Swift/Objective-C:</p><div class="table-wrapper"><table class="wide" id="-n8lvq_111"><thead><tr class="ijRowHead" id="-n8lvq_116"><th id="-n8lvq_123"><p>Kotlin</p></th><th id="-n8lvq_124"><p>Swift</p></th><th id="-n8lvq_125"><p>Objective-C</p></th></tr></thead><tbody><tr id="-n8lvq_117"><td id="-n8lvq_126"><p>List</p></td><td id="-n8lvq_127"><p>Array</p></td><td id="-n8lvq_128"><p>NSArray</p></td></tr><tr id="-n8lvq_118"><td id="-n8lvq_129"><p>MutableList</p></td><td id="-n8lvq_130"><p>NSMutableArray</p></td><td id="-n8lvq_131"><p>NSMutableArray</p></td></tr><tr id="-n8lvq_119"><td id="-n8lvq_132"><p>Set</p></td><td id="-n8lvq_133"><p>Set</p></td><td id="-n8lvq_134"><p>NSSet</p></td></tr><tr id="-n8lvq_120"><td id="-n8lvq_135"><p>MutableSet</p></td><td id="-n8lvq_136"><p>NSMutableSet</p></td><td id="-n8lvq_137"><p>NSMutableSet</p></td></tr><tr id="-n8lvq_121"><td id="-n8lvq_138"><p>Map</p></td><td id="-n8lvq_139"><p>Dictionary</p></td><td id="-n8lvq_140"><p>NSDictionary</p></td></tr><tr id="-n8lvq_122"><td id="-n8lvq_141"><p>MutableMap</p></td><td id="-n8lvq_142"><p>NSMutableDictionary</p></td><td id="-n8lvq_143"><p>NSMutableDictionary</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="kotlin-numbers-and-nsnumber" data-toc="kotlin-numbers-and-nsnumber">Kotlin numbers and NSNumber</h3><p id="-n8lvq_144">The next part of the <code class="code" id="-n8lvq_151">Demo.h</code> file contains type mappings between Kotlin/Native number types and <code class="code" id="-n8lvq_152">NSNumber</code>. The base class is called <code class="code" id="-n8lvq_153">DemoNumber</code> in Objective-C and <code class="code" id="-n8lvq_154">KotlinNumber</code> in Swift. It extends <code class="code" id="-n8lvq_155">NSNumber</code>.</p><p id="-n8lvq_145">For each Kotlin number type, there is a corresponding predefined child class:</p><div class="table-wrapper"><table class="wide" id="-n8lvq_146"><thead><tr class="ijRowHead" id="-n8lvq_156"><th id="-n8lvq_169"><p>Kotlin</p></th><th id="-n8lvq_170"><p>Swift</p></th><th id="-n8lvq_171"><p>Objective-C</p></th><th id="-n8lvq_172"><p>Simple type</p></th></tr></thead><tbody><tr id="-n8lvq_157"><td id="-n8lvq_173"><p><code class="code" id="-n8lvq_177">-</code></p></td><td id="-n8lvq_174"><p><code class="code" id="-n8lvq_178">KotlinNumber</code></p></td><td id="-n8lvq_175"><p><code class="code" id="-n8lvq_179">&lt;Package&gt;Number</code></p></td><td id="-n8lvq_176"><p><code class="code" id="-n8lvq_180">-</code></p></td></tr><tr id="-n8lvq_158"><td id="-n8lvq_181"><p><code class="code" id="-n8lvq_185">Byte</code></p></td><td id="-n8lvq_182"><p><code class="code" id="-n8lvq_186">KotlinByte</code></p></td><td id="-n8lvq_183"><p><code class="code" id="-n8lvq_187">&lt;Package&gt;Byte</code></p></td><td id="-n8lvq_184"><p><code class="code" id="-n8lvq_188">char</code></p></td></tr><tr id="-n8lvq_159"><td id="-n8lvq_189"><p><code class="code" id="-n8lvq_193">UByte</code></p></td><td id="-n8lvq_190"><p><code class="code" id="-n8lvq_194">KotlinUByte</code></p></td><td id="-n8lvq_191"><p><code class="code" id="-n8lvq_195">&lt;Package&gt;UByte</code></p></td><td id="-n8lvq_192"><p><code class="code" id="-n8lvq_196">unsigned char</code></p></td></tr><tr id="-n8lvq_160"><td id="-n8lvq_197"><p><code class="code" id="-n8lvq_201">Short</code></p></td><td id="-n8lvq_198"><p><code class="code" id="-n8lvq_202">KotlinShort</code></p></td><td id="-n8lvq_199"><p><code class="code" id="-n8lvq_203">&lt;Package&gt;Short</code></p></td><td id="-n8lvq_200"><p><code class="code" id="-n8lvq_204">short</code></p></td></tr><tr id="-n8lvq_161"><td id="-n8lvq_205"><p><code class="code" id="-n8lvq_209">UShort</code></p></td><td id="-n8lvq_206"><p><code class="code" id="-n8lvq_210">KotlinUShort</code></p></td><td id="-n8lvq_207"><p><code class="code" id="-n8lvq_211">&lt;Package&gt;UShort</code></p></td><td id="-n8lvq_208"><p><code class="code" id="-n8lvq_212">unsigned short</code></p></td></tr><tr id="-n8lvq_162"><td id="-n8lvq_213"><p><code class="code" id="-n8lvq_217">Int</code></p></td><td id="-n8lvq_214"><p><code class="code" id="-n8lvq_218">KotlinInt</code></p></td><td id="-n8lvq_215"><p><code class="code" id="-n8lvq_219">&lt;Package&gt;Int</code></p></td><td id="-n8lvq_216"><p><code class="code" id="-n8lvq_220">int</code></p></td></tr><tr id="-n8lvq_163"><td id="-n8lvq_221"><p><code class="code" id="-n8lvq_225">UInt</code></p></td><td id="-n8lvq_222"><p><code class="code" id="-n8lvq_226">KotlinUInt</code></p></td><td id="-n8lvq_223"><p><code class="code" id="-n8lvq_227">&lt;Package&gt;UInt</code></p></td><td id="-n8lvq_224"><p><code class="code" id="-n8lvq_228">unsigned int</code></p></td></tr><tr id="-n8lvq_164"><td id="-n8lvq_229"><p><code class="code" id="-n8lvq_233">Long</code></p></td><td id="-n8lvq_230"><p><code class="code" id="-n8lvq_234">KotlinLong</code></p></td><td id="-n8lvq_231"><p><code class="code" id="-n8lvq_235">&lt;Package&gt;Long</code></p></td><td id="-n8lvq_232"><p><code class="code" id="-n8lvq_236">long long</code></p></td></tr><tr id="-n8lvq_165"><td id="-n8lvq_237"><p><code class="code" id="-n8lvq_241">ULong</code></p></td><td id="-n8lvq_238"><p><code class="code" id="-n8lvq_242">KotlinULong</code></p></td><td id="-n8lvq_239"><p><code class="code" id="-n8lvq_243">&lt;Package&gt;ULong</code></p></td><td id="-n8lvq_240"><p><code class="code" id="-n8lvq_244">unsigned long long</code></p></td></tr><tr id="-n8lvq_166"><td id="-n8lvq_245"><p><code class="code" id="-n8lvq_249">Float</code></p></td><td id="-n8lvq_246"><p><code class="code" id="-n8lvq_250">KotlinFloat</code></p></td><td id="-n8lvq_247"><p><code class="code" id="-n8lvq_251">&lt;Package&gt;Float</code></p></td><td id="-n8lvq_248"><p><code class="code" id="-n8lvq_252">float</code></p></td></tr><tr id="-n8lvq_167"><td id="-n8lvq_253"><p><code class="code" id="-n8lvq_257">Double</code></p></td><td id="-n8lvq_254"><p><code class="code" id="-n8lvq_258">KotlinDouble</code></p></td><td id="-n8lvq_255"><p><code class="code" id="-n8lvq_259">&lt;Package&gt;Double</code></p></td><td id="-n8lvq_256"><p><code class="code" id="-n8lvq_260">double</code></p></td></tr><tr id="-n8lvq_168"><td id="-n8lvq_261"><p><code class="code" id="-n8lvq_265">Boolean</code></p></td><td id="-n8lvq_262"><p><code class="code" id="-n8lvq_266">KotlinBoolean</code></p></td><td id="-n8lvq_263"><p><code class="code" id="-n8lvq_267">&lt;Package&gt;Boolean</code></p></td><td id="-n8lvq_264"><p><code class="code" id="-n8lvq_268">BOOL/Bool</code></p></td></tr></tbody></table></div><p id="-n8lvq_147">Every number type has a class method to create a new instance from the corresponding simple type. Also, there is an instance method to extract a simple value back. Schematically, all such declarations look like that:</p><div class="code-block" data-lang="objectivec">
__attribute__((swift_name(&quot;Kotlin__TYPE__&quot;)))
@interface Demo__TYPE__ : DemoNumber
- (instancetype)initWith__TYPE__:(__CTYPE__)value;
+ (instancetype)numberWith__TYPE__:(__CTYPE__)value;
@end;
</div><p id="-n8lvq_149">Here, <code class="code" id="-n8lvq_269">__TYPE__</code> is one of the simple type names, and <code class="code" id="-n8lvq_270">__CTYPE__</code> is the corresponding Objective-C type, for example, <code class="code" id="-n8lvq_271">initWithChar(char)</code>.</p><p id="-n8lvq_150">These types are used to map boxed Kotlin number types to Swift/Objective-C. In Swift, you can call the constructor to create an instance, for example, <code class="code" id="-n8lvq_272">KotlinLong(value: 42)</code>.</p></section><section class="chapter"><h3 id="classes-and-objects-from-kotlin" data-toc="classes-and-objects-from-kotlin">Classes and objects from Kotlin</h3><p id="-n8lvq_273">Let's see how <code class="code" id="-n8lvq_277">class</code> and <code class="code" id="-n8lvq_278">object</code> are mapped to Swift/Objective-C. The generated <code class="code" id="-n8lvq_279">Demo.h</code> file contains the exact definitions for <code class="code" id="-n8lvq_280">Class</code>, <code class="code" id="-n8lvq_281">Interface</code>, and <code class="code" id="-n8lvq_282">Object</code>:</p><div class="code-block" data-lang="objectivec">
__attribute__((swift_name(&quot;Interface&quot;)))
@protocol DemoInterface
@required
- (void)iMember __attribute__((swift_name(&quot;iMember()&quot;)));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name(&quot;Clazz&quot;)))
@interface DemoClazz : DemoBase &lt;DemoInterface&gt;
- (instancetype)init __attribute__((swift_name(&quot;init()&quot;))) __attribute__((objc_designated_initializer));
+ (instancetype)new __attribute__((availability(swift, unavailable, message=&quot;use object initializers instead&quot;)));
- (DemoULong * _Nullable)memberP:(int32_t)p __attribute__((swift_name(&quot;member(p:)&quot;)));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name(&quot;Object&quot;)))
@interface DemoObject : DemoBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)object __attribute__((swift_name(&quot;init()&quot;)));
@property (class, readonly, getter=shared) DemoObject *shared __attribute__((swift_name(&quot;shared&quot;)));
@property (readonly) NSString *field __attribute__((swift_name(&quot;field&quot;)));
@end
</div><p id="-n8lvq_275">Objective-C attributes in this code help use the framework from both Swift and Objective-C languages. <code class="code" id="-n8lvq_283">DemoInterface</code>, <code class="code" id="-n8lvq_284">DemoClazz</code>, and <code class="code" id="-n8lvq_285">DemoObject</code> are created for <code class="code" id="-n8lvq_286">Interface</code>, <code class="code" id="-n8lvq_287">Clazz</code>, and <code class="code" id="-n8lvq_288">Object</code>, respectively.</p><p id="-n8lvq_276">The <code class="code" id="-n8lvq_289">Interface</code> is turned into <code class="code" id="-n8lvq_290">@protocol</code>, while both a <code class="code" id="-n8lvq_291">class</code> and an <code class="code" id="-n8lvq_292">object</code> are represented as <code class="code" id="-n8lvq_293">@interface</code>. The <code class="code" id="-n8lvq_294">Demo</code> prefix comes from the framework name. The nullable return type <code class="code" id="-n8lvq_295">ULong?</code> is turned into <code class="code" id="-n8lvq_296">DemoULong</code> in Objective-C.</p></section><section class="chapter"><h3 id="global-declarations-from-kotlin" data-toc="global-declarations-from-kotlin">Global declarations from Kotlin</h3><p id="-n8lvq_297">All global functions from Kotlin are turned into <code class="code" id="-n8lvq_301">DemoLibKt</code> in Objective-C and into <code class="code" id="-n8lvq_302">LibKt</code> in Swift, where <code class="code" id="-n8lvq_303">Demo</code> is the framework name set by the <code class="code" id="-n8lvq_304">-output</code> parameter of <code class="code" id="-n8lvq_305">kotlinc-native</code>:</p><div class="code-block" data-lang="objectivec">
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name(&quot;LibKt&quot;)))
@interface DemoLibKt : DemoBase
+ (NSString * _Nullable)acceptFunF:(NSString * _Nullable (^)(NSString *))f __attribute__((swift_name(&quot;acceptFun(f:)&quot;)));
+ (void)forFloatsF:(float)f d:(DemoDouble * _Nullable)d __attribute__((swift_name(&quot;forFloats(f:d:)&quot;)));
+ (void)forIntegersB:(int8_t)b s:(uint16_t)s i:(int32_t)i l:(DemoULong * _Nullable)l __attribute__((swift_name(&quot;forIntegers(b:s:i:l:)&quot;)));
+ (NSString *)stringsStr:(NSString * _Nullable)str __attribute__((swift_name(&quot;strings(str:)&quot;)));
+ (NSString * _Nullable (^)(NSString *))supplyFun __attribute__((swift_name(&quot;supplyFun()&quot;)));
@end
</div><p id="-n8lvq_299">Kotlin <code class="code" id="-n8lvq_306">String</code> and Objective-C <code class="code" id="-n8lvq_307">NSString*</code> are mapped transparently. Similarly, <code class="code" id="-n8lvq_308">Unit</code> type from Kotlin is mapped to <code class="code" id="-n8lvq_309">void</code>. The primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped to <code class="code" id="-n8lvq_310">Kotlin&lt;TYPE&gt;*</code> types, as shown in the <a href="#kotlin-numbers-and-nsnumber" id="-n8lvq_311" data-tooltip="The next part of the Demo.h file contains type mappings between Kotlin/Native number types and NSNumber. The base class is called DemoNumber in Objective-C and KotlinNumber in Swift. It extends NSNumber.">table</a>. Both higher-order functions <code class="code" id="-n8lvq_312">acceptFunF</code> and <code class="code" id="-n8lvq_313">supplyFun</code> are included and accept Objective-C blocks.</p><p id="-n8lvq_300">You can find more information about type mapping in <a href="native-objc-interop.html#mappings" id="-n8lvq_314" data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.">Interoperability with Swift/Objective-C</a>.</p></section></section><section class="chapter"><h2 id="garbage-collection-and-reference-counting" data-toc="garbage-collection-and-reference-counting">Garbage collection and reference counting</h2><p id="-n8lvq_315">Swift and Objective-C use automatic reference counting (ARC). Kotlin/Native has its own <a href="native-memory-manager.html#garbage-collector" id="-n8lvq_317" data-tooltip="Kotlin/Native's garbage collector (GC) algorithm is constantly evolving. Currently, it functions as a stop-the-world mark and concurrent sweep collector that does not separate the heap into generations.">garbage collector</a>, which is also <a href="native-arc-integration.html" id="-n8lvq_318" data-tooltip="Kotlin and Objective-C use different memory management strategies. Kotlin has a tracing garbage collector, while Objective-C relies on automatic reference counting (ARC).">integrated with Swift/Objective-C ARC</a>.</p><p id="-n8lvq_316">Unused Kotlin objects are automatically removed. You don't need to take additional steps to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</p></section><section class="chapter"><h2 id="use-code-from-objective-c" data-toc="use-code-from-objective-c">Use code from Objective-C</h2><p id="-n8lvq_319">Let's call the framework from Objective-C. In the framework directory, create the <code class="code" id="-n8lvq_325">main.m</code> file with the following code:</p><div class="code-block" data-lang="objectivec">
#import &lt;Foundation/Foundation.h&gt;
#import &lt;Demo/Demo.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [DemoObject.shared field];
        
        DemoClazz* clazz = [[ DemoClazz alloc] init];
        [clazz memberP:42];
        
        [DemoLibKt forIntegersB:1 s:1 i:3 l:[DemoULong numberWithUnsignedLongLong:4]];
        [DemoLibKt forIntegersB:1 s:1 i:3 l:nil];
        
        [DemoLibKt forFloatsF:2.71 d:[DemoDouble numberWithDouble:2.71]];
        [DemoLibKt forFloatsF:2.71 d:nil];
        
        NSString* ret = [DemoLibKt acceptFunF:^NSString * _Nullable(NSString * it) {
            return [it stringByAppendingString:@&quot; Kotlin is fun&quot;];
        }];
        
        NSLog(@&quot;%@&quot;, ret);
        return 0;
    }
}
</div><p id="-n8lvq_321">Here, you call Kotlin classes directly from Objective-C code. A Kotlin object uses the <code class="code" id="-n8lvq_326">&lt;object name&gt;.shared</code> class property, which allows you to get the object's only instance and call object methods on it.</p><p id="-n8lvq_322">The widespread pattern is used to create an instance of the <code class="code" id="-n8lvq_327">Clazz</code> class. You call the <code class="code" id="-n8lvq_328">[[ DemoClazz alloc] init]</code> on Objective-C. You can also use <code class="code" id="-n8lvq_329">[DemoClazz new]</code> for constructors without parameters.</p><p id="-n8lvq_323">Global declarations from the Kotlin sources are scoped under the <code class="code" id="-n8lvq_330">DemoLibKt</code> class in Objective-C. All Kotlin functions are turned into class methods of that class.</p><p id="-n8lvq_324">The <code class="code" id="-n8lvq_331">strings</code> function is turned into <code class="code" id="-n8lvq_332">DemoLibKt.stringsStr</code> function in Objective-C, so you can pass <code class="code" id="-n8lvq_333">NSString</code> directly to it. The return value is visible as <code class="code" id="-n8lvq_334">NSString</code> too.</p></section><section class="chapter"><h2 id="use-code-from-swift" data-toc="use-code-from-swift">Use code from Swift</h2><p id="-n8lvq_335">The framework you generated has helper attributes to make it easier to use with Swift. Let's convert the <a href="#use-code-from-objective-c" id="-n8lvq_341" data-tooltip="Let's call the framework from Objective-C. In the framework directory, create the main.m file with the following code:">previous Objective-C example</a> into Swift.</p><p id="-n8lvq_336">In the framework directory, create the <code class="code" id="-n8lvq_342">main.swift</code> file with the following code:</p><div class="code-block" data-lang="swift">
import Foundation
import Demo

let kotlinObject = Object.shared

let field = Object.shared.field

let clazz = Clazz()
clazz.member(p: 42)

LibKt.forIntegers(b: 1, s: 2, i: 3, l: 4)
LibKt.forFloats(f: 2.71, d: nil)

let ret = LibKt.acceptFun { &quot;\($0) Kotlin is fun&quot; }
if (ret != nil) {
    print(ret!)
}
</div><p id="-n8lvq_338">There are some small differences between the original Kotlin code and its Swift version. In Kotlin, any object declaration has only one instance. The <code class="code" id="-n8lvq_343">Object.shared</code> syntax is used to access this single instance.</p><p id="-n8lvq_339">Kotlin function and property names are translated as is. Kotlin's <code class="code" id="-n8lvq_344">String</code> is turned into Swift's <code class="code" id="-n8lvq_345">String</code>. Swift hides <code class="code" id="-n8lvq_346">NSNumber*</code> boxing too. You can also pass a Swift closure to Kotlin and call a Kotlin lambda function from Swift.</p><p id="-n8lvq_340">You can find more information about type mapping in <a href="native-objc-interop.html#mappings" id="-n8lvq_347" data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.">Interoperability with Swift/Objective-C</a>.</p></section><section class="chapter"><h2 id="connect-the-framework-to-your-ios-project" data-toc="connect-the-framework-to-your-ios-project">Connect the framework to your iOS project</h2><p id="-n8lvq_348">Now you can connect the generated framework to your iOS project as a dependency. There are multiple ways to set it up and automate the process, choose the method that suits you best:</p><p id="-n8lvq_349"><a href="multiplatform-ios-integration-overview.html" id="-n8lvq_350" data-tooltip="You can integrate a Kotlin Multiplatform shared module into your iOS app. For that, you generate an iOS framework from the shared module and then add it as a dependency to the iOS project:"><figure id="-n8lvq_351"><img alt="Choose iOS integration method" src="images/choose-ios-integration.svg" title="Choose iOS integration method" width="700" height="52"></figure></a></p></section><section class="chapter"><h2 id="what-s-next" data-toc="what-s-next">What's next</h2><ul class="list _bullet" id="-n8lvq_352"><li class="list__item" id="-n8lvq_353"><p id="-n8lvq_356"><a href="native-objc-interop.html" id="-n8lvq_357" data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation.">Learn more about interoperability with Objective-C</a></p></li><li class="list__item" id="-n8lvq_354"><p id="-n8lvq_358"><a href="native-c-interop.html" id="-n8lvq_359" data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation.">See how interoperability with C is implemented in Kotlin</a></p></li><li class="list__item" id="-n8lvq_355"><p id="-n8lvq_360"><a href="native-dynamic-libraries.html" id="-n8lvq_361" data-tooltip="You can create dynamic libraries to use Kotlin code from existing programs. This enables code sharing across many platforms or languages, including JVM, Python, Android, and others.">Check out the Kotlin/Native as a dynamic library tutorial</a></p></li></ul></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="native-objc-interop.html" class="navigation-links__prev">Interoperability with Swift/Objective-C</a><a href="native-libraries.html" class="navigation-links__next">Kotlin/Native libraries</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>