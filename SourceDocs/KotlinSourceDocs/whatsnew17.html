<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T12:59:59.922379272"><title>What's new in Kotlin 1.7.0 | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"new-kotlin-k2-compiler-for-the-jvm-in-alpha","level":0,"title":"New Kotlin K2 compiler for the JVM in Alpha","anchor":"#new-kotlin-k2-compiler-for-the-jvm-in-alpha"},{"id":"language","level":0,"title":"Language","anchor":"#language"},{"id":"allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class","level":1,"title":"Allow implementation by delegation to an inlined value of an inline class","anchor":"#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class"},{"id":"underscore-operator-for-type-arguments","level":1,"title":"Underscore operator for type arguments","anchor":"#underscore-operator-for-type-arguments"},{"id":"stable-builder-inference","level":1,"title":"Stable builder inference","anchor":"#stable-builder-inference"},{"id":"stable-opt-in-requirements","level":1,"title":"Stable opt-in requirements","anchor":"#stable-opt-in-requirements"},{"id":"stable-definitely-non-nullable-types","level":1,"title":"Stable definitely non-nullable types","anchor":"#stable-definitely-non-nullable-types"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"compiler-performance-optimizations","level":1,"title":"Compiler performance optimizations","anchor":"#compiler-performance-optimizations"},{"id":"new-compiler-option-xjdk-release","level":1,"title":"New compiler option: -Xjdk-release","anchor":"#new-compiler-option-xjdk-release"},{"id":"stable-callable-references-to-functional-interface-constructors","level":1,"title":"Stable callable references to functional interface constructors","anchor":"#stable-callable-references-to-functional-interface-constructors"},{"id":"removed-jvm-target-version-1-6","level":1,"title":"Removed JVM target version 1.6","anchor":"#removed-jvm-target-version-1-6"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"performance-improvements-for-the-new-memory-manager","level":1,"title":"Performance improvements for the new memory manager","anchor":"#performance-improvements-for-the-new-memory-manager"},{"id":"unified-compiler-plugin-abi-with-jvm-and-js-ir-backends","level":1,"title":"Unified compiler plugin ABI with JVM and JS IR backends","anchor":"#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends"},{"id":"support-for-standalone-android-executables","level":1,"title":"Support for standalone Android executables","anchor":"#support-for-standalone-android-executables"},{"id":"interop-with-swift-async-await-returning-void-instead-of-kotlinunit","level":1,"title":"Interop with Swift async/await: returning Void instead of KotlinUnit","anchor":"#interop-with-swift-async-await-returning-void-instead-of-kotlinunit"},{"id":"prohibited-undeclared-exceptions-through-objective-c-bridges","level":1,"title":"Prohibited undeclared exceptions through Objective-C bridges","anchor":"#prohibited-undeclared-exceptions-through-objective-c-bridges"},{"id":"improved-cocoapods-integration","level":1,"title":"Improved CocoaPods integration","anchor":"#improved-cocoapods-integration"},{"id":"overriding-the-kotlin-native-compiler-download-url","level":1,"title":"Overriding the Kotlin/Native compiler download URL","anchor":"#overriding-the-kotlin-native-compiler-download-url"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"performance-improvements-for-the-new-ir-backend","level":1,"title":"Performance improvements for the new IR backend","anchor":"#performance-improvements-for-the-new-ir-backend"},{"id":"minification-for-member-names-when-using-ir","level":1,"title":"Minification for member names when using IR","anchor":"#minification-for-member-names-when-using-ir"},{"id":"support-for-older-browsers-via-polyfills-in-the-ir-backend","level":1,"title":"Support for older browsers via polyfills in the IR backend","anchor":"#support-for-older-browsers-via-polyfills-in-the-ir-backend"},{"id":"dynamically-load-javascript-modules-from-js-expressions","level":1,"title":"Dynamically load JavaScript modules from js expressions","anchor":"#dynamically-load-javascript-modules-from-js-expressions"},{"id":"specify-environment-variables-for-javascript-test-runners","level":1,"title":"Specify environment variables for JavaScript test runners","anchor":"#specify-environment-variables-for-javascript-test-runners"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"min-and-max-collection-functions-return-as-non-nullable","level":1,"title":"min() and max() collection functions return as non-nullable","anchor":"#min-and-max-collection-functions-return-as-non-nullable"},{"id":"regular-expression-matching-at-specific-indices","level":1,"title":"Regular expression matching at specific indices","anchor":"#regular-expression-matching-at-specific-indices"},{"id":"extended-support-for-previous-language-and-api-versions","level":1,"title":"Extended support for previous language and API versions","anchor":"#extended-support-for-previous-language-and-api-versions"},{"id":"access-to-annotations-via-reflection","level":1,"title":"Access to annotations via reflection","anchor":"#access-to-annotations-via-reflection"},{"id":"stable-deep-recursive-functions","level":1,"title":"Stable deep recursive functions","anchor":"#stable-deep-recursive-functions"},{"id":"time-marks-based-on-inline-classes-for-default-time-source","level":1,"title":"Time marks based on inline classes for default time source","anchor":"#time-marks-based-on-inline-classes-for-default-time-source"},{"id":"new-experimental-extension-functions-for-java-optionals","level":1,"title":"New experimental extension functions for Java Optionals","anchor":"#new-experimental-extension-functions-for-java-optionals"},{"id":"support-for-named-capturing-groups-in-js-and-native","level":1,"title":"Support for named capturing groups in JS and Native","anchor":"#support-for-named-capturing-groups-in-js-and-native"},{"id":"gradle","level":0,"title":"Gradle","anchor":"#gradle"},{"id":"a-new-approach-to-incremental-compilation","level":1,"title":"A new approach to incremental compilation","anchor":"#a-new-approach-to-incremental-compilation"},{"id":"build-reports-for-kotlin-compiler-tasks","level":1,"title":"Build reports for Kotlin compiler tasks","anchor":"#build-reports-for-kotlin-compiler-tasks"},{"id":"bumping-minimum-supported-versions","level":1,"title":"Bumping minimum supported versions","anchor":"#bumping-minimum-supported-versions"},{"id":"support-for-gradle-plugin-variants","level":1,"title":"Support for Gradle plugin variants","anchor":"#support-for-gradle-plugin-variants"},{"id":"updates-in-the-kotlin-gradle-plugin-api","level":1,"title":"Updates in the Kotlin Gradle plugin API","anchor":"#updates-in-the-kotlin-gradle-plugin-api"},{"id":"the-sam-with-receiver-plugin-is-available-via-the-plugins-api","level":1,"title":"The sam-with-receiver plugin is available via the plugins API","anchor":"#the-sam-with-receiver-plugin-is-available-via-the-plugins-api"},{"id":"changes-in-compile-tasks","level":1,"title":"Changes in compile tasks","anchor":"#changes-in-compile-tasks"},{"id":"statistics-of-generated-files-by-each-annotation-processor-in-kapt","level":1,"title":"Statistics of generated files by each annotation processor in kapt","anchor":"#statistics-of-generated-files-by-each-annotation-processor-in-kapt"},{"id":"deprecation-of-the-kotlin-compiler-execution-strategy-system-property","level":1,"title":"Deprecation of the kotlin.compiler.execution.strategy system property","anchor":"#deprecation-of-the-kotlin-compiler-execution-strategy-system-property"},{"id":"removal-of-deprecated-options-methods-and-plugins","level":1,"title":"Removal of deprecated options, methods, and plugins","anchor":"#removal-of-deprecated-options-methods-and-plugins"},{"id":"migrating-to-kotlin-1-7-0","level":0,"title":"Migrating to Kotlin 1.7.0","anchor":"#migrating-to-kotlin-1-7-0"},{"id":"install-kotlin-1-7-0","level":1,"title":"Install Kotlin 1.7.0","anchor":"#install-kotlin-1-7-0"},{"id":"migrate-existing-or-start-a-new-project-with-kotlin-1-7-0","level":1,"title":"Migrate existing or start a new project with Kotlin 1.7.0","anchor":"#migrate-existing-or-start-a-new-project-with-kotlin-1-7-0"},{"id":"compatibility-guide-for-kotlin-1-7-0","level":1,"title":"Compatibility guide for Kotlin 1.7.0","anchor":"#compatibility-guide-for-kotlin-1-7-0"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.7.0 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/whatsnew17.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="What's new in Kotlin 1.7.0 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/whatsnew17.html#webpage",
    "url": "writerside-documentation/whatsnew17.html",
    "name": "What's new in Kotlin 1.7.0 | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="whatsnew17" data-main-title="What's new in Kotlin 1.7.0" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew17" id="whatsnew17.md">What's new in Kotlin 1.7.0</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-t8qh4i_17\&quot;\u003eThe IDE support for Kotlin 1.7.0 is available for IntelliJ IDEA 2021.2, 2021.3, and 2022.1.\u003c/p\u003e&quot;]}"></div><p id="-t8qh4i_3"><span class="emphasis" id="-t8qh4i_18"><a href="releases.html#release-details" id="-t8qh4i_19" data-tooltip="The following table lists details of the latest Kotlin releases:">Released: 9 June 2022</a></span></p><p id="-t8qh4i_4">Kotlin 1.7.0 has been released. It unveils the Alpha version of the new Kotlin/JVM K2 compiler, stabilizes language features, and brings performance improvements for the JVM, JS, and Native platforms.</p><p id="-t8qh4i_5">Here is a list of the major updates in this version:</p><ul class="list _bullet" id="-t8qh4i_6"><li class="list__item" id="-t8qh4i_20"><p id="-t8qh4i_25"><a href="#new-kotlin-k2-compiler-for-the-jvm-in-alpha" id="-t8qh4i_26" data-tooltip="This Kotlin release introduces the Alpha version of the new Kotlin K2 compiler. The new compiler aims to speed up the development of new language features, unify all of the platforms Kotlin supports, bring performance improvements, and provide an API for compiler extensions.">The new Kotlin K2 compiler is in Alpha now</a>, and it offers serious performance improvements. It is available only for the JVM, and none of the compiler plugins, including kapt, work with it.</p></li><li class="list__item" id="-t8qh4i_21"><p id="-t8qh4i_27"><a href="#a-new-approach-to-incremental-compilation" id="-t8qh4i_28" data-tooltip="The new approach to incremental compilation is Experimental. It may be dropped or changed at any time. Opt-in is required (see the details below). We encourage you to use it only for evaluation purposes, and we would appreciate your feedback in YouTrack.">A new approach to the incremental compilation in Gradle</a>. Incremental compilation is now also supported for changes made inside dependent non-Kotlin modules and is compatible with Gradle.</p></li><li class="list__item" id="-t8qh4i_22"><p id="-t8qh4i_29">We've stabilized <a href="#stable-opt-in-requirements" id="-t8qh4i_30" data-tooltip="Opt-in requirements are now Stable and do not require additional compiler configuration.">opt-in requirement annotations</a>, <a href="#stable-definitely-non-nullable-types" id="-t8qh4i_31" data-tooltip="In Kotlin 1.7.0, definitely non-nullable types have been promoted to Stable. They provide better interoperability when extending generic Java classes and interfaces.">definitely non-nullable types</a>, and <a href="#stable-builder-inference" id="-t8qh4i_32" data-tooltip="Builder inference is a special kind of type inference that is useful when calling generic builder functions. It helps the compiler infer the type arguments of a call using the type information about other calls inside its lambda argument.">builder inference</a>.</p></li><li class="list__item" id="-t8qh4i_23"><p id="-t8qh4i_33"><a href="#underscore-operator-for-type-arguments" id="-t8qh4i_34" data-tooltip="Kotlin 1.7.0 introduces an underscore operator, _, for type arguments. You can use it to automatically infer a type argument when other types are specified:">There's now an underscore operator for type args</a>. You can use it to automatically infer a type of argument when other types are specified.</p></li><li class="list__item" id="-t8qh4i_24"><p id="-t8qh4i_35"><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" id="-t8qh4i_36" data-tooltip="If you want to create a lightweight wrapper for a value or class instance, it's necessary to implement all interface methods by hand. Implementation by delegation solves this issue, but it did not work with inline classes before 1.7.0. This restriction has been removed, so you can…">This release allows implementation by delegation to an inlined value of an inline class</a>. You can now create lightweight wrappers that do not allocate memory in most cases.</p></li></ul><p id="-t8qh4i_7">You can also find a short overview of the changes in this video:</p><div class="video-player" id="-t8qh4i_8"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/54WEfLKtCGk?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><section class="chapter"><h2 id="new-kotlin-k2-compiler-for-the-jvm-in-alpha" data-toc="new-kotlin-k2-compiler-for-the-jvm-in-alpha">New Kotlin K2 compiler for the JVM in Alpha</h2><p id="-t8qh4i_37">This Kotlin release introduces the <span class="control" id="-t8qh4i_49">Alpha</span> version of the new Kotlin K2 compiler. The new compiler aims to speed up the development of new language features, unify all of the platforms Kotlin supports, bring performance improvements, and provide an API for compiler extensions.</p><p id="-t8qh4i_38">We've already published some detailed explanations of our new compiler and its benefits:</p><ul class="list _bullet" id="-t8qh4i_39"><li class="list__item" id="-t8qh4i_50"><p id="-t8qh4i_52"><a href="https://www.youtube.com/watch?v=iTdJJq_LyoY" id="-t8qh4i_53" data-external="true" rel="noopener noreferrer" target="_blank">The Road to the New Kotlin Compiler</a></p></li><li class="list__item" id="-t8qh4i_51"><p id="-t8qh4i_54"><a href="https://www.youtube.com/watch?v=db19VFLZqJM" id="-t8qh4i_55" data-external="true" rel="noopener noreferrer" target="_blank">K2 Compiler: a Top-Down View</a></p></li></ul><p id="-t8qh4i_40">It's important to point out that with the Alpha version of the new K2 compiler we were primarily focused on performance improvements, and it only works with JVM projects. It doesn't support Kotlin/JS, Kotlin/Native, or other multi-platform projects, and none of compiler plugins, including <a href="kapt.html" id="-t8qh4i_56" data-tooltip="kapt is in maintenance mode. We are keeping it up-to-date with recent Kotlin and Java releases but have no plans to implement new features. Please use the Kotlin Symbol Processing API (KSP) for annotation processing. See the list of libraries supported by KSP.">kapt</a>, work with it.</p><p id="-t8qh4i_41">Our benchmarks show some outstanding results on our internal projects:</p><div class="table-wrapper"><table class="wide" id="-t8qh4i_42"><thead><tr class="ijRowHead" id="-t8qh4i_57"><th id="-t8qh4i_62"><p>Project</p></th><th id="-t8qh4i_63"><p>Current Kotlin compiler performance</p></th><th id="-t8qh4i_64"><p>New K2 Kotlin compiler performance</p></th><th id="-t8qh4i_65"><p>Performance boost</p></th></tr></thead><tbody><tr id="-t8qh4i_58"><td id="-t8qh4i_66"><p>Kotlin</p></td><td id="-t8qh4i_67"><p>2.2 KLOC/s</p></td><td id="-t8qh4i_68"><p>4.8 KLOC/s</p></td><td id="-t8qh4i_69"><p>~ x2.2</p></td></tr><tr id="-t8qh4i_59"><td id="-t8qh4i_70"><p>YouTrack</p></td><td id="-t8qh4i_71"><p>1.8 KLOC/s</p></td><td id="-t8qh4i_72"><p>4.2 KLOC/s</p></td><td id="-t8qh4i_73"><p>~ x2.3</p></td></tr><tr id="-t8qh4i_60"><td id="-t8qh4i_74"><p>IntelliJ IDEA</p></td><td id="-t8qh4i_75"><p>1.8 KLOC/s</p></td><td id="-t8qh4i_76"><p>3.9 KLOC/s</p></td><td id="-t8qh4i_77"><p>~ x2.2</p></td></tr><tr id="-t8qh4i_61"><td id="-t8qh4i_78"><p>Space</p></td><td id="-t8qh4i_79"><p>1.2 KLOC/s</p></td><td id="-t8qh4i_80"><p>2.8 KLOC/s</p></td><td id="-t8qh4i_81"><p>~ x2.3</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-t8qh4i_43"><p id="-t8qh4i_82">The KLOC/s performance numbers stand for the number of thousands of lines of code that the compiler processes per second.</p></aside><p id="-t8qh4i_44">You can check out the performance boost on your JVM projects and compare it with the results of the old compiler. To enable the Kotlin K2 compiler, use the following compiler option:</p><div class="code-block" data-lang="bash">
-Xuse-k2
</div><p id="-t8qh4i_46">Also, the K2 compiler <a href="https://youtrack.jetbrains.com/issues/KT?q=tag:%20FIR-preview-qa%20%23Resolved" id="-t8qh4i_83" data-external="true" rel="noopener noreferrer" target="_blank">includes a number of bugfixes</a>. Please note that even issues with <span class="control" id="-t8qh4i_84">State: Open</span> from this list are in fact fixed in K2.</p><p id="-t8qh4i_47">The next Kotlin releases will improve the stability of the K2 compiler and provide more features, so stay tuned!</p><p id="-t8qh4i_48">If you face any performance issues with the Kotlin K2 compiler, please <a href="https://kotl.in/issue" id="-t8qh4i_85" data-external="true" rel="noopener noreferrer" target="_blank">report them to our issue tracker</a>.</p></section><section class="chapter"><h2 id="language" data-toc="language">Language</h2><p id="-t8qh4i_86">Kotlin 1.7.0 introduces support for implementation by delegation and a new underscore operator for type arguments. It also stabilizes several language features introduced as previews in previous releases:</p><ul class="list _bullet" id="-t8qh4i_87"><li class="list__item" id="-t8qh4i_93"><p id="-t8qh4i_98"><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" id="-t8qh4i_99" data-tooltip="If you want to create a lightweight wrapper for a value or class instance, it's necessary to implement all interface methods by hand. Implementation by delegation solves this issue, but it did not work with inline classes before 1.7.0. This restriction has been removed, so you can…">Implementation by delegation to inlined value of inline class</a></p></li><li class="list__item" id="-t8qh4i_94"><p id="-t8qh4i_100"><a href="#underscore-operator-for-type-arguments" id="-t8qh4i_101" data-tooltip="Kotlin 1.7.0 introduces an underscore operator, _, for type arguments. You can use it to automatically infer a type argument when other types are specified:">Underscore operator for type arguments</a></p></li><li class="list__item" id="-t8qh4i_95"><p id="-t8qh4i_102"><a href="#stable-builder-inference" id="-t8qh4i_103" data-tooltip="Builder inference is a special kind of type inference that is useful when calling generic builder functions. It helps the compiler infer the type arguments of a call using the type information about other calls inside its lambda argument.">Stable builder inference</a></p></li><li class="list__item" id="-t8qh4i_96"><p id="-t8qh4i_104"><a href="#stable-opt-in-requirements" id="-t8qh4i_105" data-tooltip="Opt-in requirements are now Stable and do not require additional compiler configuration.">Stable opt-in requirements</a></p></li><li class="list__item" id="-t8qh4i_97"><p id="-t8qh4i_106"><a href="#stable-definitely-non-nullable-types" id="-t8qh4i_107" data-tooltip="In Kotlin 1.7.0, definitely non-nullable types have been promoted to Stable. They provide better interoperability when extending generic Java classes and interfaces.">Stable definitely non-nullable types</a></p></li></ul><section class="chapter"><h3 id="allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" data-toc="allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class">Allow implementation by delegation to an inlined value of an inline class</h3><p id="-t8qh4i_108">If you want to create a lightweight wrapper for a value or class instance, it's necessary to implement all interface methods by hand. Implementation by delegation solves this issue, but it did not work with inline classes before 1.7.0. This restriction has been removed, so you can now create lightweight wrappers that do not allocate memory in most cases.</p><div class="code-block" data-lang="kotlin">
interface Bar {
    fun foo() = &quot;foo&quot;
}

@JvmInline
value class BarWrapper(val bar: Bar): Bar by bar

fun main() {
    val bw = BarWrapper(object: Bar {})
    println(bw.foo())
}
</div></section><section class="chapter"><h3 id="underscore-operator-for-type-arguments" data-toc="underscore-operator-for-type-arguments">Underscore operator for type arguments</h3><p id="-t8qh4i_110">Kotlin 1.7.0 introduces an underscore operator, <code class="code" id="-t8qh4i_113">_</code>, for type arguments. You can use it to automatically infer a type argument when other types are specified:</p><div class="code-block" data-lang="kotlin">
abstract class SomeClass&lt;T&gt; {
    abstract fun execute(): T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = &quot;Test&quot;
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run(): T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == &quot;Test&quot;)

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</div><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_112"><p id="-t8qh4i_114">You can use the underscore operator in any position in the variables list to infer a type argument.</p></aside></section><section class="chapter"><h3 id="stable-builder-inference" data-toc="stable-builder-inference">Stable builder inference</h3><p id="-t8qh4i_115">Builder inference is a special kind of type inference that is useful when calling generic builder functions. It helps the compiler infer the type arguments of a call using the type information about other calls inside its lambda argument.</p><p id="-t8qh4i_116">Starting with 1.7.0, builder inference is automatically activated if a regular type inference cannot get enough information about a type without specifying the <code class="code" id="-t8qh4i_118">-Xenable-builder-inference</code> compiler option, which was <a href="whatsnew16.html#changes-to-builder-inference" id="-t8qh4i_119" data-tooltip="Builder inference is a type inference flavor which is useful when calling generic builder functions. It can infer the type arguments of a call with the help of type information from calls inside its lambda argument.">introduced in 1.6.0</a>.</p><p id="-t8qh4i_117"><a href="using-builders-with-builder-inference.html" id="-t8qh4i_120" data-tooltip="Kotlin supports builder type inference (or builder inference), which can come in useful when you are working with generic builders. It helps the compiler infer the type arguments of a builder call based on the type information about other calls inside its lambda argument.">Learn how to write custom generic builders</a>.</p></section><section class="chapter"><h3 id="stable-opt-in-requirements" data-toc="stable-opt-in-requirements">Stable opt-in requirements</h3><p id="-t8qh4i_121"><a href="opt-in-requirements.html" id="-t8qh4i_123" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">Opt-in requirements</a> are now <a href="components-stability.html" id="-t8qh4i_124" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a> and do not require additional compiler configuration.</p><p id="-t8qh4i_122">Before 1.7.0, the opt-in feature itself required the argument <code class="code" id="-t8qh4i_125">-opt-in=kotlin.RequiresOptIn</code> to avoid a warning. It no longer requires this; however, you can still use the compiler argument <code class="code" id="-t8qh4i_126">-opt-in</code> to opt-in for other annotations, <a href="opt-in-requirements.html#opt-in-a-module" id="-t8qh4i_127" data-tooltip="The -opt-in compiler option is available since Kotlin 1.6.0. For earlier Kotlin versions, use -Xopt-in.">a module</a>.</p></section><section class="chapter"><h3 id="stable-definitely-non-nullable-types" data-toc="stable-definitely-non-nullable-types">Stable definitely non-nullable types</h3><p id="-t8qh4i_128">In Kotlin 1.7.0, definitely non-nullable types have been promoted to <a href="components-stability.html" id="-t8qh4i_132" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a>. They provide better interoperability when extending generic Java classes and interfaces.</p><p id="-t8qh4i_129">You can mark a generic type parameter as definitely non-nullable at the use site with the new syntax <code class="code" id="-t8qh4i_133">T &amp; Any</code>. The syntactic form comes from the notation for <a href="https://en.wikipedia.org/wiki/Intersection_type" id="-t8qh4i_134" data-external="true" rel="noopener noreferrer" target="_blank">intersection types</a> and is now limited to a type parameter with nullable upper bounds on the left side of <code class="code" id="-t8qh4i_135">&amp;</code> and a non-nullable <code class="code" id="-t8qh4i_136">Any</code> on the right side:</p><div class="code-block" data-lang="kotlin">
fun &lt;T&gt; elvisLike(x: T, y: T &amp; Any): T &amp; Any = x ?: y

fun main() {
    // OK
    elvisLike&lt;String&gt;(&quot;&quot;, &quot;&quot;).length
    // Error: 'null' cannot be a value of a non-null type
    elvisLike&lt;String&gt;(&quot;&quot;, null).length

    // OK
    elvisLike&lt;String?&gt;(null, &quot;&quot;).length
    // Error: 'null' cannot be a value of a non-null type
    elvisLike&lt;String?&gt;(null, null).length
}
</div><p id="-t8qh4i_131">Learn more about definitely non-nullable types in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/definitely-non-nullable-types.md" id="-t8qh4i_137" data-external="true" rel="noopener noreferrer" target="_blank">this KEEP</a>.</p></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="-t8qh4i_138">This release brings performance improvements for the Kotlin/JVM compiler and a new compiler option. Additionally, callable references to functional interface constructors have become Stable. Note that since 1.7.0, the default target version for Kotlin/JVM compilations is <code class="code" id="-t8qh4i_144">1.8</code>.</p><ul class="list _bullet" id="-t8qh4i_139"><li class="list__item" id="-t8qh4i_145"><p id="-t8qh4i_149"><a href="#compiler-performance-optimizations" id="-t8qh4i_150" data-tooltip="Kotlin 1.7.0 introduces performance improvements for the Kotlin/JVM compiler. According to our benchmarks, compilation time has been reduced by 10% on average compared to Kotlin 1.6.0. Projects with lots of usages of inline functions, for example, projects using kotlinx.html, will…">Compiler performance optimizations</a></p></li><li class="list__item" id="-t8qh4i_146"><p id="-t8qh4i_151"><a href="#new-compiler-option-xjdk-release" id="-t8qh4i_152" data-tooltip="Kotlin 1.7.0 presents a new compiler option, -Xjdk-release. This option is similar to the javac's command-line --release option. The -Xjdk-release option controls the target bytecode version and limits the API of the JDK in the classpath to the specified Java version. For example,…">New compiler option <code class="code" id="-t8qh4i_153">-Xjdk-release</code></a></p></li><li class="list__item" id="-t8qh4i_147"><p id="-t8qh4i_154"><a href="#stable-callable-references-to-functional-interface-constructors" id="-t8qh4i_155" data-tooltip="Callable references to functional interface constructors are now Stable. Learn how to migrate from an interface with a constructor function to a functional interface using callable references.">Stable callable references to functional interface constructors</a></p></li><li class="list__item" id="-t8qh4i_148"><p id="-t8qh4i_156"><a href="#removed-jvm-target-version-1-6" id="-t8qh4i_157" data-tooltip="The default target version for Kotlin/JVM compilations is 1.8. The 1.6 target has been removed.">Removed the JVM target version 1.6</a></p></li></ul><section class="chapter"><h3 id="compiler-performance-optimizations" data-toc="compiler-performance-optimizations">Compiler performance optimizations</h3><p id="-t8qh4i_158">Kotlin 1.7.0 introduces performance improvements for the Kotlin/JVM compiler. According to our benchmarks, compilation time has been <a href="https://youtrack.jetbrains.com/issue/KT-48233/Switching-to-JVM-IR-backend-increases-compilation-time-by-more-t#focus=Comments-27-6114542.0-0" id="-t8qh4i_159" data-external="true" rel="noopener noreferrer" target="_blank">reduced by 10% on average</a> compared to Kotlin 1.6.0. Projects with lots of usages of inline functions, for example, <a href="https://youtrack.jetbrains.com/issue/KT-51416/Compilation-of-kotlinx-html-DSL-should-still-be-faster" id="-t8qh4i_160" data-external="true" rel="noopener noreferrer" target="_blank">projects using <code class="code" id="-t8qh4i_161">kotlinx.html</code></a>, will compile faster thanks to the improvements to the bytecode postprocessing.</p></section><section class="chapter"><h3 id="new-compiler-option-xjdk-release" data-toc="new-compiler-option-xjdk-release">New compiler option: -Xjdk-release</h3><p id="-t8qh4i_162">Kotlin 1.7.0 presents a new compiler option, <code class="code" id="-t8qh4i_165">-Xjdk-release</code>. This option is similar to the <a href="http://openjdk.java.net/jeps/247" id="-t8qh4i_166" data-external="true" rel="noopener noreferrer" target="_blank">javac's command-line <code class="code" id="-t8qh4i_170">--release</code> option</a>. The <code class="code" id="-t8qh4i_167">-Xjdk-release</code> option controls the target bytecode version and limits the API of the JDK in the classpath to the specified Java version. For example, <code class="code" id="-t8qh4i_168">kotlinc -Xjdk-release=1.8</code> won't allow referencing <code class="code" id="-t8qh4i_169">java.lang.Module</code> even if the JDK in the dependencies is version 9 or higher.</p><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_163"><p id="-t8qh4i_171">This option is <a href="https://youtrack.jetbrains.com/issue/KT-29974" id="-t8qh4i_172" data-external="true" rel="noopener noreferrer" target="_blank">not guaranteed</a> to be effective for each JDK distribution.</p></aside><p id="-t8qh4i_164">Please leave your feedback on <a href="https://youtrack.jetbrains.com/issue/KT-29974/Add-a-compiler-option-Xjdk-release-similar-to-javac-s-release-to" id="-t8qh4i_173" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="stable-callable-references-to-functional-interface-constructors" data-toc="stable-callable-references-to-functional-interface-constructors">Stable callable references to functional interface constructors</h3><p id="-t8qh4i_174"><a href="reflection.html#callable-references" id="-t8qh4i_176" data-tooltip="References to functions, properties, and constructors can also be called or used as instances of function types.">Callable references</a> to functional interface constructors are now <a href="components-stability.html" id="-t8qh4i_177" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a>. Learn how to <a href="fun-interfaces.html#migration-from-an-interface-with-constructor-function-to-a-functional-interface" id="-t8qh4i_178" data-tooltip="Starting from 1.6.20, Kotlin supports callable references to functional interface constructors, which adds a source-compatible way to migrate from an interface with a constructor function to a functional interface. Consider the following code:">migrate</a> from an interface with a constructor function to a functional interface using callable references.</p><p id="-t8qh4i_175">Please report any issues you find in <a href="https://youtrack.jetbrains.com/newissue?project=kt" id="-t8qh4i_179" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="removed-jvm-target-version-1-6" data-toc="removed-jvm-target-version-1-6">Removed JVM target version 1.6</h3><p id="-t8qh4i_180">The default target version for Kotlin/JVM compilations is <code class="code" id="-t8qh4i_183">1.8</code>. The <code class="code" id="-t8qh4i_184">1.6</code> target has been removed.</p><p id="-t8qh4i_181">Please migrate to JVM target 1.8 or above. Learn how to update the JVM target version for:</p><ul class="list _bullet" id="-t8qh4i_182"><li class="list__item" id="-t8qh4i_185"><p id="-t8qh4i_188"><a href="gradle-compiler-options.html#attributes-specific-to-jvm" id="-t8qh4i_189" data-tooltip="NameDescriptionPossible valuesDefault value javaParametersGenerate metadata for Java 1.8 reflection on method parameters false jvmTargetTarget version of the generated JVM bytecode&quot;1.8&quot;, &quot;9&quot;, &quot;10&quot;, ..., &quot;22&quot;, &quot;23&quot;. Also, see Types…">Gradle</a></p></li><li class="list__item" id="-t8qh4i_186"><p id="-t8qh4i_190"><a href="maven.html#attributes-specific-to-jvm" id="-t8qh4i_191" data-tooltip="NameProperty nameDescriptionPossible valuesDefault value nowarn Generate no warningstrue, falsefalse languageVersionkotlin.compiler.languageVersionProvide source compatibility with the specified version of Kotlin&quot;1.8&quot;, &quot;1.9&quot;, &quot;2.0&quot;, &quot;2.1&quot;,…">Maven</a></p></li><li class="list__item" id="-t8qh4i_187"><p id="-t8qh4i_192"><a href="compiler-reference.html#jvm-target-version" id="-t8qh4i_193" data-tooltip="Specify the target version of the generated JVM bytecode. Possible values are 1.8, 9, 10, ..., 21. The default value is 1.8.">The command-line compiler</a></p></li></ul></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="-t8qh4i_194">Kotlin 1.7.0 includes changes to Objective-C and Swift interoperability and stabilizes features that were introduced in previous releases. It also brings performance improvements for the new memory manager along with other updates:</p><ul class="list _bullet" id="-t8qh4i_195"><li class="list__item" id="-t8qh4i_203"><p id="-t8qh4i_210"><a href="#performance-improvements-for-the-new-memory-manager" id="-t8qh4i_211" data-tooltip="The new Kotlin/Native memory manager is in Alpha. It may change incompatibly and require manual migration in the future. We would appreciate your feedback in YouTrack.">Performance improvements for the new memory manager</a></p></li><li class="list__item" id="-t8qh4i_204"><p id="-t8qh4i_212"><a href="#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" id="-t8qh4i_213" data-tooltip="Starting with Kotlin 1.7.0, the Kotlin Multiplatform Gradle plugin uses the embeddable compiler jar for Kotlin/Native by default. This feature was announced in 1.6.0 as Experimental, and now it's Stable and ready to use.">Unified compiler plugin ABI with JVM and JS IR backends</a></p></li><li class="list__item" id="-t8qh4i_205"><p id="-t8qh4i_214"><a href="#support-for-standalone-android-executables" id="-t8qh4i_215" data-tooltip="Kotlin 1.7.0 provides full support for generating standard executables for Android Native targets. It was introduced in 1.6.20, and now it's enabled by default.">Support for standalone Android executables</a></p></li><li class="list__item" id="-t8qh4i_206"><p id="-t8qh4i_216"><a href="#interop-with-swift-async-await-returning-void-instead-of-kotlinunit" id="-t8qh4i_217" data-tooltip="Kotlin suspend functions now return the Void type instead of KotlinUnit in Swift. This is the result of the improved interop with Swift's async/await. This feature was introduced in 1.6.20, and this release enables this behavior by default.">Interop with Swift async/await: returning <code class="code" id="-t8qh4i_218">Void</code> instead of <code class="code" id="-t8qh4i_219">KotlinUnit</code></a></p></li><li class="list__item" id="-t8qh4i_207"><p id="-t8qh4i_220"><a href="#prohibited-undeclared-exceptions-through-objective-c-bridges" id="-t8qh4i_221" data-tooltip="When you call Kotlin code from Swift/Objective-C code (or vice versa) and this code throws an exception, it should be handled by the code where the exception occurred, unless you specifically allowed the forwarding of exceptions between languages with proper conversion (for example,…">Prohibited undeclared exceptions through Objective-C bridges</a></p></li><li class="list__item" id="-t8qh4i_208"><p id="-t8qh4i_222"><a href="#improved-cocoapods-integration" id="-t8qh4i_223" data-tooltip="Starting with Kotlin 1.7.0, you no longer need to install the cocoapods-generate plugin if you want to integrate CocoaPods in your projects.">Improved CocoaPods integration</a></p></li><li class="list__item" id="-t8qh4i_209"><p id="-t8qh4i_224"><a href="#overriding-the-kotlin-native-compiler-download-url" id="-t8qh4i_225" data-tooltip="Starting with Kotlin 1.7.0, you can customize the download URL for the Kotlin/Native compiler. This is useful when external links on the CI are forbidden.">Overriding of the Kotlin/Native compiler download URL</a></p></li></ul><section class="chapter"><h3 id="performance-improvements-for-the-new-memory-manager" data-toc="performance-improvements-for-the-new-memory-manager">Performance improvements for the new memory manager</h3><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_226"><p id="-t8qh4i_230">The new Kotlin/Native memory manager is in <a href="components-stability.html" id="-t8qh4i_231" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Alpha</a>. It may change incompatibly and require manual migration in the future. We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="-t8qh4i_232" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-t8qh4i_227">The new memory manager is still in Alpha, but it is on its way to becoming <a href="components-stability.html" id="-t8qh4i_233" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a>. This release delivers significant performance improvements for the new memory manager, especially in garbage collection (GC). In particular, concurrent implementation of the sweep phase, <a href="whatsnew1620.html" id="-t8qh4i_234" data-tooltip="Released: 4 April 2022">introduced in 1.6.20</a>, is now enabled by default. This helps reduce the time the application is paused for GC. The new GC scheduler is better at choosing the GC frequency, especially for larger heaps.</p><p id="-t8qh4i_228">Also, we've specifically optimized debug binaries, ensuring that the proper optimization level and link-time optimizations are used in the implementation code of the memory manager. This helped us improve execution time by roughly 30% for debug binaries on our benchmarks.</p><p id="-t8qh4i_229">Try using the new memory manager in your projects to see how it works, and share your feedback with us in <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="-t8qh4i_235" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" data-toc="unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">Unified compiler plugin ABI with JVM and JS IR backends</h3><p id="-t8qh4i_236">Starting with Kotlin 1.7.0, the Kotlin Multiplatform Gradle plugin uses the embeddable compiler jar for Kotlin/Native by default. This <a href="whatsnew16.html#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" id="-t8qh4i_239" data-tooltip="The option to use the common IR compiler plugin ABI for Kotlin/Native is Experimental. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">feature was announced in 1.6.0</a> as Experimental, and now it's Stable and ready to use.</p><p id="-t8qh4i_237">This improvement is very handy for library authors, as it improves the compiler plugin development experience. Before this release, you had to provide separate artifacts for Kotlin/Native, but now you can use the same compiler plugin artifacts for Native and other supported platforms.</p><aside class="prompt" data-type="warning" data-title="" id="-t8qh4i_238"><p id="-t8qh4i_240">This feature might require plugin developers to take migration steps for their existing plugins.</p><p id="-t8qh4i_241">Learn how to prepare your plugin for the update in this <a href="https://youtrack.jetbrains.com/issue/KT-48595" id="-t8qh4i_242" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a>.</p></aside></section><section class="chapter"><h3 id="support-for-standalone-android-executables" data-toc="support-for-standalone-android-executables">Support for standalone Android executables</h3><p id="-t8qh4i_243">Kotlin 1.7.0 provides full support for generating standard executables for Android Native targets. It was <a href="whatsnew1620.html#support-for-standalone-android-executables" id="-t8qh4i_246" data-tooltip="Previously, Android Native executables in Kotlin/Native were not actually executables but shared libraries that you could use as a NativeActivity. Now there's an option to generate standard executables for Android Native targets.">introduced in 1.6.20</a>, and now it's enabled by default.</p><p id="-t8qh4i_244">If you want to roll back to the previous behavior when Kotlin/Native generated shared libraries, use the following setting:</p><div class="code-block" data-lang="kotlin">
binaryOptions[&quot;androidProgramType&quot;] = &quot;nativeActivity&quot;
</div></section><section class="chapter"><h3 id="interop-with-swift-async-await-returning-void-instead-of-kotlinunit" data-toc="interop-with-swift-async-await-returning-void-instead-of-kotlinunit">Interop with Swift async/await: returning Void instead of KotlinUnit</h3><p id="-t8qh4i_247">Kotlin <code class="code" id="-t8qh4i_249">suspend</code> functions now return the <code class="code" id="-t8qh4i_250">Void</code> type instead of <code class="code" id="-t8qh4i_251">KotlinUnit</code> in Swift. This is the result of the improved interop with Swift's <code class="code" id="-t8qh4i_252">async</code>/<code class="code" id="-t8qh4i_253">await</code>. This feature was <a href="whatsnew1620.html#interop-with-swift-async-await-returning-void-instead-of-kotlinunit" id="-t8qh4i_254" data-tooltip="Concurrency interoperability with Swift async/await is Experimental. It may be dropped or changed at any time. You should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">introduced in 1.6.20</a>, and this release enables this behavior by default.</p><p id="-t8qh4i_248">You don't need to use the <code class="code" id="-t8qh4i_255">kotlin.native.binary.unitSuspendFunctionObjCExport=proper</code> property anymore to return the proper type for such functions.</p></section><section class="chapter"><h3 id="prohibited-undeclared-exceptions-through-objective-c-bridges" data-toc="prohibited-undeclared-exceptions-through-objective-c-bridges">Prohibited undeclared exceptions through Objective-C bridges</h3><p id="-t8qh4i_256">When you call Kotlin code from Swift/Objective-C code (or vice versa) and this code throws an exception, it should be handled by the code where the exception occurred, unless you specifically allowed the forwarding of exceptions between languages with proper conversion (for example, using the <code class="code" id="-t8qh4i_260">@Throws</code> annotation).</p><p id="-t8qh4i_257">Previously, Kotlin had another unintended behavior where undeclared exceptions could &quot;leak&quot; from one language to another in some cases. Kotlin 1.7.0 fixes that issue, and now such cases lead to program termination.</p><p id="-t8qh4i_258">So, for example, if you have a <code class="code" id="-t8qh4i_261">{ throw Exception() }</code> lambda in Kotlin and call it from Swift, in Kotlin 1.7.0 it will terminate as soon as the exception reaches the Swift code. In previous Kotlin versions, such an exception could leak to the Swift code.</p><p id="-t8qh4i_259">The <code class="code" id="-t8qh4i_262">@Throws</code> annotation continues to work as before.</p></section><section class="chapter"><h3 id="improved-cocoapods-integration" data-toc="improved-cocoapods-integration">Improved CocoaPods integration</h3><p id="-t8qh4i_263">Starting with Kotlin 1.7.0, you no longer need to install the <code class="code" id="-t8qh4i_267">cocoapods-generate</code> plugin if you want to integrate CocoaPods in your projects.</p><p id="-t8qh4i_264">Previously, you needed to install both the CocoaPods dependency manager and the <code class="code" id="-t8qh4i_268">cocoapods-generate</code> plugin to use CocoaPods, for example, to handle <a href="multiplatform-ios-dependencies.html#with-cocoapods" id="-t8qh4i_269" data-tooltip="Perform initial CocoaPods integration setup.">iOS dependencies</a> in Kotlin Multiplatform Mobile projects.</p><p id="-t8qh4i_265">Now setting up the CocoaPods integration is easier, and we've resolved the issue when <code class="code" id="-t8qh4i_270">cocoapods-generate</code> couldn't be installed on Ruby 3 and later. Now the newest Ruby versions that work better on Apple M1 are also supported.</p><p id="-t8qh4i_266">See how to set up the <a href="native-cocoapods.html#set-up-an-environment-to-work-with-cocoapods" id="-t8qh4i_271" data-tooltip="Install the CocoaPods dependency manager using the installation tool of your choice:">initial CocoaPods integration</a>.</p></section><section class="chapter"><h3 id="overriding-the-kotlin-native-compiler-download-url" data-toc="overriding-the-kotlin-native-compiler-download-url">Overriding the Kotlin/Native compiler download URL</h3><p id="-t8qh4i_272">Starting with Kotlin 1.7.0, you can customize the download URL for the Kotlin/Native compiler. This is useful when external links on the CI are forbidden.</p><p id="-t8qh4i_273">To override the default base URL <code class="code" id="-t8qh4i_276">https://download.jetbrains.com/kotlin/native/builds</code>, use the following Gradle property:</p><div class="code-block" data-lang="none">
kotlin.native.distribution.baseDownloadUrl=https://example.com
</div><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_275"><p id="-t8qh4i_277">The downloader will append the native version and target OS to this base URL to ensure it downloads the actual compiler distribution.</p></aside></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="-t8qh4i_278">Kotlin/JS is receiving further improvements to the <a href="js-ir-compiler.html" id="-t8qh4i_285" data-tooltip="The Kotlin/JS IR compiler backend is the main focus of innovation around Kotlin/JS, and paves the way forward for the technology.">JS IR compiler backend</a> along with other updates that can make your development experience better:</p><ul class="list _bullet" id="-t8qh4i_279"><li class="list__item" id="-t8qh4i_286"><p id="-t8qh4i_291"><a href="#performance-improvements-for-the-new-ir-backend" id="-t8qh4i_292" data-tooltip="This release has some major updates that should improve your development experience:">Performance improvements for the new IR backend</a></p></li><li class="list__item" id="-t8qh4i_287"><p id="-t8qh4i_293"><a href="#minification-for-member-names-when-using-ir" id="-t8qh4i_294" data-tooltip="The Kotlin/JS IR compiler now uses its internal information about the relationships of your Kotlin classes and functions to apply more efficient minification, shortening the names of functions, properties, and classes. This shrinks the resulting bundled applications.">Minification for member names when using IR</a></p></li><li class="list__item" id="-t8qh4i_288"><p id="-t8qh4i_295"><a href="#support-for-older-browsers-via-polyfills-in-the-ir-backend" id="-t8qh4i_296" data-tooltip="The IR compiler backend for Kotlin/JS now includes the same polyfills as the legacy backend. This allows code compiled with the new compiler to run in older browsers that do not support all the methods from ES2015 used by the Kotlin standard library. Only those polyfills actually…">Support for older browsers via polyfills in the IR backend</a></p></li><li class="list__item" id="-t8qh4i_289"><p id="-t8qh4i_297"><a href="#dynamically-load-javascript-modules-from-js-expressions" id="-t8qh4i_298" data-tooltip="When working with the JavaScript modules, most applications use static imports, whose use is covered with the JavaScript module integration. However, Kotlin/JS was missing a mechanism to load JavaScript modules dynamically at runtime in your applications.">Dynamically load JavaScript modules from js expressions</a></p></li><li class="list__item" id="-t8qh4i_290"><p id="-t8qh4i_299"><a href="#specify-environment-variables-for-javascript-test-runners" id="-t8qh4i_300" data-tooltip="To tune Node.js package resolution or pass external information to Node.js tests, you can now specify environment variables used by the JavaScript test runners. To define an environment variable, use the environment() function with a key-value pair inside the testTask block in your…">Specify environment variables for JavaScript test runners</a></p></li></ul><section class="chapter"><h3 id="performance-improvements-for-the-new-ir-backend" data-toc="performance-improvements-for-the-new-ir-backend">Performance improvements for the new IR backend</h3><p id="-t8qh4i_301">This release has some major updates that should improve your development experience:</p><ul class="list _bullet" id="-t8qh4i_302"><li class="list__item" id="-t8qh4i_303"><p id="-t8qh4i_307">Incremental compilation performance of Kotlin/JS has been significantly improved. It takes less time to build your JS projects. Incremental rebuilds should now be roughly on par with the legacy backend in many cases now.</p></li><li class="list__item" id="-t8qh4i_304"><p id="-t8qh4i_308">The Kotlin/JS final bundle requires less space, as we have significantly reduced the size of the final artifacts. We've measured up to a 20% reduction in the production bundle size compared to the legacy backend for some large projects.</p></li><li class="list__item" id="-t8qh4i_305"><p id="-t8qh4i_309">Type checking for interfaces has been improved by orders of magnitude.</p></li><li class="list__item" id="-t8qh4i_306"><p id="-t8qh4i_310">Kotlin generates higher-quality JS code</p></li></ul></section><section class="chapter"><h3 id="minification-for-member-names-when-using-ir" data-toc="minification-for-member-names-when-using-ir">Minification for member names when using IR</h3><p id="-t8qh4i_311">The Kotlin/JS IR compiler now uses its internal information about the relationships of your Kotlin classes and functions to apply more efficient minification, shortening the names of functions, properties, and classes. This shrinks the resulting bundled applications.</p><p id="-t8qh4i_312">This type of minification is automatically applied when you build your Kotlin/JS application in production mode and is enabled by default. To disable member name minification, use the <code class="code" id="-t8qh4i_314">-Xir-minimized-member-names</code> compiler flag:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js(IR) {
        compilations.all {
            compileKotlinTask.kotlinOptions.freeCompilerArgs += listOf(&quot;-Xir-minimized-member-names=false&quot;)
        }
    }
}
</div></section><section class="chapter"><h3 id="support-for-older-browsers-via-polyfills-in-the-ir-backend" data-toc="support-for-older-browsers-via-polyfills-in-the-ir-backend">Support for older browsers via polyfills in the IR backend</h3><p id="-t8qh4i_315">The IR compiler backend for Kotlin/JS now includes the same polyfills as the legacy backend. This allows code compiled with the new compiler to run in older browsers that do not support all the methods from ES2015 used by the Kotlin standard library. Only those polyfills actually used by the project are included in the final bundle, which minimizes their potential impact on the bundle size.</p><p id="-t8qh4i_316">This feature is enabled by default when using the IR compiler, and you don't need to configure it.</p></section><section class="chapter"><h3 id="dynamically-load-javascript-modules-from-js-expressions" data-toc="dynamically-load-javascript-modules-from-js-expressions">Dynamically load JavaScript modules from js expressions</h3><p id="-t8qh4i_317">When working with the JavaScript modules, most applications use static imports, whose use is covered with the <a href="js-modules.html" id="-t8qh4i_320" data-tooltip="You can compile your Kotlin projects to JavaScript modules for various popular module systems. We currently support the following configurations for JavaScript modules:">JavaScript module integration</a>. However, Kotlin/JS was missing a mechanism to load JavaScript modules dynamically at runtime in your applications.</p><p id="-t8qh4i_318">Starting with Kotlin 1.7.0, the <code class="code" id="-t8qh4i_321">import</code> statement from JavaScript is supported in <code class="code" id="-t8qh4i_322">js</code> blocks, allowing you to dynamically bring packages into your application at runtime:</p><div class="code-block" data-lang="kotlin">
val myPackage = js(&quot;import('my-package')&quot;)
</div></section><section class="chapter"><h3 id="specify-environment-variables-for-javascript-test-runners" data-toc="specify-environment-variables-for-javascript-test-runners">Specify environment variables for JavaScript test runners</h3><p id="-t8qh4i_323">To tune Node.js package resolution or pass external information to Node.js tests, you can now specify environment variables used by the JavaScript test runners. To define an environment variable, use the <code class="code" id="-t8qh4i_325">environment()</code> function with a key-value pair inside the <code class="code" id="-t8qh4i_326">testTask</code> block in your build script:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js {
        nodejs {
            testTask {
                environment(&quot;key&quot;, &quot;value&quot;)
            }
        }
    }
}
</div></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><p id="-t8qh4i_327">In Kotlin 1.7.0, the standard library has received a range of changes and improvements. They introduce new features, stabilize experimental ones, and unify support for named capturing groups for Native, JS, and the JVM:</p><ul class="list _bullet" id="-t8qh4i_328"><li class="list__item" id="-t8qh4i_337"><p id="-t8qh4i_345"><a href="#min-and-max-collection-functions-return-as-non-nullable" id="-t8qh4i_346" data-tooltip="In Kotlin 1.4.0, we renamed the min() and max() collection functions to minOrNull() and maxOrNull(). These new names better reflect their behavior – returning null if the receiver collection is empty. It also helped align the functions' behavior with naming conventions used…">min() and max() collection functions return as non-nullable</a></p></li><li class="list__item" id="-t8qh4i_338"><p id="-t8qh4i_347"><a href="#regular-expression-matching-at-specific-indices" id="-t8qh4i_348" data-tooltip="The Regex.matchAt() and Regex.matchesAt() functions, introduced in 1.5.30, are now Stable. They provide a way to check whether a regular expression has an exact match at a particular position in a String or CharSequence.">Regular expression matching at specific indices</a></p></li><li class="list__item" id="-t8qh4i_339"><p id="-t8qh4i_349"><a href="#extended-support-for-previous-language-and-api-versions" id="-t8qh4i_350" data-tooltip="To support library authors developing libraries that are meant to be consumable in a wide range of previous Kotlin versions, and to address the increased frequency of major Kotlin releases, we have extended our support for previous language and API versions.">Extended support of previous language and API versions</a></p></li><li class="list__item" id="-t8qh4i_340"><p id="-t8qh4i_351"><a href="#access-to-annotations-via-reflection" id="-t8qh4i_352" data-tooltip="The KAnnotatedElement.findAnnotations() extension function, which was first introduced in 1.6.0, is now Stable. This reflection function returns all annotations of a given type on an element, including individually applied and repeated annotations.">Access to annotations via reflection</a></p></li><li class="list__item" id="-t8qh4i_341"><p id="-t8qh4i_353"><a href="#stable-deep-recursive-functions" id="-t8qh4i_354" data-tooltip="Deep recursive functions have been available as an experimental feature since Kotlin 1.4.0, and they are now Stable in Kotlin 1.7.0. Using DeepRecursiveFunction, you can define a function that keeps its stack on the heap instead of using the actual call stack. This allows you to run…">Stable deep recursive functions</a></p></li><li class="list__item" id="-t8qh4i_342"><p id="-t8qh4i_355"><a href="#time-marks-based-on-inline-classes-for-default-time-source" id="-t8qh4i_356" data-tooltip="Kotlin 1.7.0 improves the performance of time measurement functionality by changing the time marks returned by TimeSource.Monotonic into inline value classes. This means that calling functions like markNow(), elapsedNow() , measureTime(), and measureTimedValue() doesn't allocate…">Time marks based on inline classes for default time source</a></p></li><li class="list__item" id="-t8qh4i_343"><p id="-t8qh4i_357"><a href="#new-experimental-extension-functions-for-java-optionals" id="-t8qh4i_358" data-tooltip="Kotlin 1.7.0 comes with new convenience functions that simplify working with Optional classes in Java. These new functions can be used to unwrap and convert optional objects on the JVM and help make working with Java APIs more concise.">New experimental extension functions for Java Optionals</a></p></li><li class="list__item" id="-t8qh4i_344"><p id="-t8qh4i_359"><a href="#support-for-named-capturing-groups-in-js-and-native" id="-t8qh4i_360" data-tooltip="Starting with Kotlin 1.7.0, named capturing groups are supported not only on the JVM, but on the JS and Native platforms as well.">Support for named capturing groups in JS and Native</a></p></li></ul><section class="chapter"><h3 id="min-and-max-collection-functions-return-as-non-nullable" data-toc="min-and-max-collection-functions-return-as-non-nullable">min() and max() collection functions return as non-nullable</h3><p id="-t8qh4i_361">In <a href="whatsnew14.html" id="-t8qh4i_365" data-tooltip="Released: 17 August 2020">Kotlin 1.4.0</a>, we renamed the <code class="code" id="-t8qh4i_366">min()</code> and <code class="code" id="-t8qh4i_367">max()</code> collection functions to <code class="code" id="-t8qh4i_368">minOrNull()</code> and <code class="code" id="-t8qh4i_369">maxOrNull()</code>. These new names better reflect their behavior &ndash; returning null if the receiver collection is empty. It also helped align the functions' behavior with naming conventions used throughout the Kotlin collections API.</p><p id="-t8qh4i_362">The same was true of <code class="code" id="-t8qh4i_370">minBy()</code>, <code class="code" id="-t8qh4i_371">maxBy()</code>, <code class="code" id="-t8qh4i_372">minWith()</code>, and <code class="code" id="-t8qh4i_373">maxWith()</code>, which all got their *OrNull() synonyms in Kotlin 1.4.0. Older functions affected by this change were gradually deprecated.</p><p id="-t8qh4i_363">Kotlin 1.7.0 reintroduces the original function names, but with a non-nullable return type. The new <code class="code" id="-t8qh4i_374">min()</code>, <code class="code" id="-t8qh4i_375">max()</code>, <code class="code" id="-t8qh4i_376">minBy()</code>, <code class="code" id="-t8qh4i_377">maxBy()</code>, <code class="code" id="-t8qh4i_378">minWith()</code>, and <code class="code" id="-t8qh4i_379">maxWith()</code> functions now strictly return the collection element or throw an exception.</p><div class="code-block" data-lang="kotlin">
fun main() {
    val numbers = listOf&lt;Int&gt;()
    println(numbers.maxOrNull()) // &quot;null&quot;
    println(numbers.max()) // &quot;Exception in... Collection is empty.&quot;
}
</div></section><section class="chapter"><h3 id="regular-expression-matching-at-specific-indices" data-toc="regular-expression-matching-at-specific-indices">Regular expression matching at specific indices</h3><p id="-t8qh4i_380">The <code class="code" id="-t8qh4i_386">Regex.matchAt()</code> and <code class="code" id="-t8qh4i_387">Regex.matchesAt()</code> functions, <a href="whatsnew1530.html#matching-with-regex-at-a-particular-position" id="-t8qh4i_388" data-tooltip="Regex.matchAt() and Regex.matchesAt() functions are Experimental. They may be dropped or changed at any time. Use them only for evaluation purposes. We would appreciate hearing your feedback on them in YouTrack.">introduced in 1.5.30</a>, are now Stable. They provide a way to check whether a regular expression has an exact match at a particular position in a <code class="code" id="-t8qh4i_389">String</code> or <code class="code" id="-t8qh4i_390">CharSequence</code>.</p><p id="-t8qh4i_381"><code class="code" id="-t8qh4i_391">matchesAt()</code> checks for a match and returns a boolean result:</p><div class="code-block" data-lang="kotlin">
fun main() {
    val releaseText = &quot;Kotlin 1.7.0 is on its way!&quot;
    // regular expression: one digit, dot, one digit, dot, one or more digits
    val versionRegex = &quot;\\d[.]\\d[.]\\d+&quot;.toRegex()

    println(versionRegex.matchesAt(releaseText, 0)) // &quot;false&quot;
    println(versionRegex.matchesAt(releaseText, 7)) // &quot;true&quot;
}
</div><p id="-t8qh4i_383"><code class="code" id="-t8qh4i_392">matchAt()</code> returns the match if it's found, or <code class="code" id="-t8qh4i_393">null</code> if it isn't:</p><div class="code-block" data-lang="kotlin">
fun main() {
    val releaseText = &quot;Kotlin 1.7.0 is on its way!&quot;
    val versionRegex = &quot;\\d[.]\\d[.]\\d+&quot;.toRegex()

    println(versionRegex.matchAt(releaseText, 0)) // &quot;null&quot;
    println(versionRegex.matchAt(releaseText, 7)?.value) // &quot;1.7.0&quot;
}
</div><p id="-t8qh4i_385">We'd be grateful for your feedback on this <a href="https://youtrack.jetbrains.com/issue/KT-34021" id="-t8qh4i_394" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a>.</p></section><section class="chapter"><h3 id="extended-support-for-previous-language-and-api-versions" data-toc="extended-support-for-previous-language-and-api-versions">Extended support for previous language and API versions</h3><p id="-t8qh4i_395">To support library authors developing libraries that are meant to be consumable in a wide range of previous Kotlin versions, and to address the increased frequency of major Kotlin releases, we have extended our support for previous language and API versions.</p><p id="-t8qh4i_396">With Kotlin 1.7.0, we're supporting three previous language and API versions rather than two. This means Kotlin 1.7.0 supports the development of libraries targeting Kotlin versions down to 1.4.0. For more information on backward compatibility, see <a href="compatibility-modes.html" id="-t8qh4i_397" data-tooltip="When a big team is migrating onto a new version, it may appear in an &quot;inconsistent state&quot; at some point, when some developers have already updated but others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide…">Compatibility modes</a>.</p></section><section class="chapter"><h3 id="access-to-annotations-via-reflection" data-toc="access-to-annotations-via-reflection">Access to annotations via reflection</h3><p id="-t8qh4i_398">The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations.html" id="-t8qh4i_400" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_404">KAnnotatedElement.findAnnotations()</code></a> extension function, which was first <a href="whatsnew16.html#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target" id="-t8qh4i_401" data-tooltip="Java 8 introduced repeatable annotations, which can be applied multiple times to a single code element. The feature requires two declarations to be present in the Java code: the repeatable annotation itself marked with @java.lang.annotation.Repeatable and the containing annotation…">introduced in 1.6.0</a>, is now <a href="components-stability.html" id="-t8qh4i_402" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a>. This <a href="reflection.html" id="-t8qh4i_403" data-tooltip="Reflection is a set of language and library features that allows you to introspect the structure of your program at runtime. Functions and properties are first-class citizens in Kotlin, and the ability to introspect them (for example, learning the name or the type of a property or…">reflection</a> function returns all annotations of a given type on an element, including individually applied and repeated annotations.</p><div class="code-block" data-lang="kotlin">
@Repeatable
annotation class Tag(val name: String)

@Tag(&quot;First Tag&quot;)
@Tag(&quot;Second Tag&quot;)
fun taggedFunction() {
    println(&quot;I'm a tagged function!&quot;)
}

fun main() {
    val x = ::taggedFunction
    val foo = x as KAnnotatedElement
    println(foo.findAnnotations&lt;Tag&gt;()) // [@Tag(name=First Tag), @Tag(name=Second Tag)]
}
</div></section><section class="chapter"><h3 id="stable-deep-recursive-functions" data-toc="stable-deep-recursive-functions">Stable deep recursive functions</h3><p id="-t8qh4i_405">Deep recursive functions have been available as an experimental feature since <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/#Defining_deep_recursive_functions_using_coroutines" id="-t8qh4i_409" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin 1.4.0</a>, and they are now <a href="components-stability.html" id="-t8qh4i_410" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Stable</a> in Kotlin 1.7.0. Using <code class="code" id="-t8qh4i_411">DeepRecursiveFunction</code>, you can define a function that keeps its stack on the heap instead of using the actual call stack. This allows you to run very deep recursive computations. To call a deep recursive function, <code class="code" id="-t8qh4i_412">invoke</code> it.</p><p id="-t8qh4i_406">In this example, a deep recursive function is used to calculate the depth of a binary tree recursively. Even though this sample function calls itself recursively 100,000 times, no <code class="code" id="-t8qh4i_413">StackOverflowError</code> is thrown:</p><div class="code-block" data-lang="kotlin">
class Tree(val left: Tree?, val right: Tree?)

val calculateDepth = DeepRecursiveFunction&lt;Tree?, Int&gt; { t -&gt;
    if (t == null) 0 else maxOf(
        callRecursive(t.left),
        callRecursive(t.right)
    ) + 1
}

fun main() {
    // Generate a tree with a depth of 100_000
    val deepTree = generateSequence(Tree(null, null)) { prev -&gt;
        Tree(prev, null)
    }.take(100_000).last()

    println(calculateDepth(deepTree)) // 100000
}
</div><p id="-t8qh4i_408">Consider using deep recursive functions in your code where your recursion depth exceeds 1000 calls.</p></section><section class="chapter"><h3 id="time-marks-based-on-inline-classes-for-default-time-source" data-toc="time-marks-based-on-inline-classes-for-default-time-source">Time marks based on inline classes for default time source</h3><p id="-t8qh4i_414">Kotlin 1.7.0 improves the performance of time measurement functionality by changing the time marks returned by <code class="code" id="-t8qh4i_417">TimeSource.Monotonic</code> into inline value classes. This means that calling functions like <code class="code" id="-t8qh4i_418">markNow()</code>, <code class="code" id="-t8qh4i_419">elapsedNow()</code>, <code class="code" id="-t8qh4i_420">measureTime()</code>, and <code class="code" id="-t8qh4i_421">measureTimedValue()</code> doesn't allocate wrapper classes for their <code class="code" id="-t8qh4i_422">TimeMark</code> instances. Especially when measuring a piece of code that is part of a hot path, this can help minimize the performance impact of the measurement:</p><div class="code-block" data-lang="kotlin">
@OptIn(ExperimentalTime::class)
fun main() {
    val mark = TimeSource.Monotonic.markNow() // Returned `TimeMark` is inline class
    val elapsedDuration = mark.elapsedNow()
}
</div><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_416"><p id="-t8qh4i_423">This optimization is only available if the time source from which the <code class="code" id="-t8qh4i_424">TimeMark</code> is obtained is statically known to be <code class="code" id="-t8qh4i_425">TimeSource.Monotonic</code>.</p></aside></section><section class="chapter"><h3 id="new-experimental-extension-functions-for-java-optionals" data-toc="new-experimental-extension-functions-for-java-optionals">New experimental extension functions for Java Optionals</h3><p id="-t8qh4i_426">Kotlin 1.7.0 comes with new convenience functions that simplify working with <code class="code" id="-t8qh4i_432">Optional</code> classes in Java. These new functions can be used to unwrap and convert optional objects on the JVM and help make working with Java APIs more concise.</p><p id="-t8qh4i_427">The <code class="code" id="-t8qh4i_433">getOrNull()</code>, <code class="code" id="-t8qh4i_434">getOrDefault()</code>, and <code class="code" id="-t8qh4i_435">getOrElse()</code> extension functions allow you to get the value of an <code class="code" id="-t8qh4i_436">Optional</code> if it's present. Otherwise, you get <code class="code" id="-t8qh4i_437">null</code>, a default value, or a value returned by a function, respectively:</p><div class="code-block" data-lang="kotlin">
val presentOptional = Optional.of(&quot;I'm here!&quot;)

println(presentOptional.getOrNull())
// &quot;I'm here!&quot;

val absentOptional = Optional.empty&lt;String&gt;()

println(absentOptional.getOrNull())
// null
println(absentOptional.getOrDefault(&quot;Nobody here!&quot;))
// &quot;Nobody here!&quot;
println(absentOptional.getOrElse {
    println(&quot;Optional was absent!&quot;)
    &quot;Default value!&quot;
})
// &quot;Optional was absent!&quot;
// &quot;Default value!&quot;
</div><p id="-t8qh4i_429">The <code class="code" id="-t8qh4i_438">toList()</code>, <code class="code" id="-t8qh4i_439">toSet()</code>, and <code class="code" id="-t8qh4i_440">asSequence()</code> extension functions convert the value of a present <code class="code" id="-t8qh4i_441">Optional</code> to a list, set, or sequence, or return an empty collection otherwise. The <code class="code" id="-t8qh4i_442">toCollection()</code> extension function appends the <code class="code" id="-t8qh4i_443">Optional</code> value to an already existing destination collection:</p><div class="code-block" data-lang="kotlin">
val presentOptional = Optional.of(&quot;I'm here!&quot;)
val absentOptional = Optional.empty&lt;String&gt;()
println(presentOptional.toList() + &quot;,&quot; + absentOptional.toList())
// [&quot;I'm here!&quot;], []
println(presentOptional.toSet() + &quot;,&quot; + absentOptional.toSet())
// [&quot;I'm here!&quot;], []
val myCollection = mutableListOf&lt;String&gt;()
absentOptional.toCollection(myCollection)
println(myCollection)
// []
presentOptional.toCollection(myCollection)
println(myCollection)
// [&quot;I'm here!&quot;]
val list = listOf(presentOptional, absentOptional).flatMap { it.asSequence() }
println(list)
// [&quot;I'm here!&quot;]
</div><p id="-t8qh4i_431">These extension functions are being introduced as Experimental in Kotlin 1.7.0. You can learn more about <code class="code" id="-t8qh4i_444">Optional</code> extensions in <a href="https://github.com/Kotlin/KEEP/pull/291" id="-t8qh4i_445" data-external="true" rel="noopener noreferrer" target="_blank">this KEEP</a>. As always, we welcome your feedback in the <a href="https://kotl.in/issue" id="-t8qh4i_446" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin issue tracker</a>.</p></section><section class="chapter"><h3 id="support-for-named-capturing-groups-in-js-and-native" data-toc="support-for-named-capturing-groups-in-js-and-native">Support for named capturing groups in JS and Native</h3><p id="-t8qh4i_447">Starting with Kotlin 1.7.0, named capturing groups are supported not only on the JVM, but on the JS and Native platforms as well.</p><p id="-t8qh4i_448">To give a name to a capturing group, use the (<code class="code" id="-t8qh4i_452">?&lt;name&gt;group</code>) syntax in your regular expression. To get the text matched by a group, call the newly introduced <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/get.html" id="-t8qh4i_453" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_454">MatchGroupCollection.get()</code></a> function and pass the group name.</p><section class="chapter"><h4 id="retrieve-matched-group-value-by-name" data-toc="retrieve-matched-group-value-by-name">Retrieve matched group value by name</h4><p id="-t8qh4i_455">Consider this example for matching city coordinates. To get a collection of groups matched by the regular expression, use <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-match-result/groups.html" id="-t8qh4i_457" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_459">groups</code></a>. Compare retrieving a group's contents by its number (index) and by its name using <code class="code" id="-t8qh4i_458">value</code>:</p><div class="code-block" data-lang="kotlin">
fun main() {
    val regex = &quot;\\b(?&lt;city&gt;[A-Za-z\\s]+),\\s(?&lt;state&gt;[A-Z]{2}):\\s(?&lt;areaCode&gt;[0-9]{3})\\b&quot;.toRegex()
    val input = &quot;Coordinates: Austin, TX: 123&quot;
    val match = regex.find(input)!!
    println(match.groups[&quot;city&quot;]?.value) // &quot;Austin&quot; — by name
    println(match.groups[2]?.value) // &quot;TX&quot; — by number
}
</div></section><section class="chapter"><h4 id="named-backreferencing" data-toc="named-backreferencing">Named backreferencing</h4><p id="-t8qh4i_460">You can now also use group names when backreferencing groups. Backreferences match the same text that was previously matched by a capturing group. For this, use the <code class="code" id="-t8qh4i_462">\k&lt;name&gt;</code> syntax in your regular expression:</p><div class="code-block" data-lang="kotlin">
fun backRef() {
    val regex = &quot;(?&lt;title&gt;\\w+), yes \\k&lt;title&gt;&quot;.toRegex()
    val match = regex.find(&quot;Do you copy? Sir, yes Sir!&quot;)!!
    println(match.value) // &quot;Sir, yes Sir&quot;
    println(match.groups[&quot;title&quot;]?.value) // &quot;Sir&quot;
}
</div></section><section class="chapter"><h4 id="named-groups-in-replacement-expressions" data-toc="named-groups-in-replacement-expressions">Named groups in replacement expressions</h4><p id="-t8qh4i_463">Named group references can be used with replacement expressions. Consider the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace.html" id="-t8qh4i_466" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_468">replace()</code></a> function that substitutes all occurrences of the specified regular expression in the input with a replacement expression, and the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/replace-first.html" id="-t8qh4i_467" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_469">replaceFirst()</code></a> function that swaps the first match only.</p><p id="-t8qh4i_464">Occurrences of <code class="code" id="-t8qh4i_470">${name}</code> in the replacement string are substituted with the subsequences corresponding to the captured groups with the specified name. You can compare replacements in group references by name and index:</p><div class="code-block" data-lang="kotlin">
fun dateReplace() {
    val dateRegex = Regex(&quot;(?&lt;dd&gt;\\d{2})-(?&lt;mm&gt;\\d{2})-(?&lt;yyyy&gt;\\d{4})&quot;)
    val input = &quot;Date of birth: 27-04-2022&quot;
    println(dateRegex.replace(input, &quot;\${yyyy}-\${mm}-\${dd}&quot;)) // &quot;Date of birth: 2022-04-27&quot; — by name
    println(dateRegex.replace(input, &quot;\$3-\$2-\$1&quot;)) // &quot;Date of birth: 2022-04-27&quot; — by number
}
</div></section></section></section><section class="chapter"><h2 id="gradle" data-toc="gradle">Gradle</h2><p id="-t8qh4i_471">This release introduces new build reports, support for Gradle plugin variants, new statistics in kapt, and a lot more:</p><ul class="list _bullet" id="-t8qh4i_472"><li class="list__item" id="-t8qh4i_483"><p id="-t8qh4i_493"><a href="#a-new-approach-to-incremental-compilation" id="-t8qh4i_494" data-tooltip="The new approach to incremental compilation is Experimental. It may be dropped or changed at any time. Opt-in is required (see the details below). We encourage you to use it only for evaluation purposes, and we would appreciate your feedback in YouTrack.">A new approach to incremental compilation</a></p></li><li class="list__item" id="-t8qh4i_484"><p id="-t8qh4i_495"><a href="#build-reports-for-kotlin-compiler-tasks" id="-t8qh4i_496" data-tooltip="Kotlin build reports are Experimental. They may be dropped or changed at any time. Opt-in is required (see details below). Use them only for evaluation purposes. We appreciate your feedback on them in YouTrack.">New build reports for tracking compiler performance</a></p></li><li class="list__item" id="-t8qh4i_485"><p id="-t8qh4i_497"><a href="#bumping-minimum-supported-versions" id="-t8qh4i_498" data-tooltip="Starting with Kotlin 1.7.0, the minimum supported Gradle version is 6.7.1. We had to raise the version to support Gradle plugin variants and the new Gradle API. In the future, we should not have to raise the minimum supported version as often, thanks to the Gradle plugin variants…">Changes to the minimum supported versions of Gradle and the Android Gradle plugin</a></p></li><li class="list__item" id="-t8qh4i_486"><p id="-t8qh4i_499"><a href="#support-for-gradle-plugin-variants" id="-t8qh4i_500" data-tooltip="Gradle 7.0 introduced a new feature for Gradle plugin authors — plugins with variants. This feature makes it easier to add support for new Gradle features while maintaining compatibility for Gradle versions below 7.1. Learn more about variant selection in Gradle.">Support for Gradle plugin variants</a></p></li><li class="list__item" id="-t8qh4i_487"><p id="-t8qh4i_501"><a href="#updates-in-the-kotlin-gradle-plugin-api" id="-t8qh4i_502" data-tooltip="The Kotlin Gradle plugin API artifact has received several improvements:">Updates in the Kotlin Gradle plugin API</a></p></li><li class="list__item" id="-t8qh4i_488"><p id="-t8qh4i_503"><a href="#the-sam-with-receiver-plugin-is-available-via-the-plugins-api" id="-t8qh4i_504" data-tooltip="The sam-with-receiver compiler plugin is now available via the Gradle plugins DSL:">Availability of the sam-with-receiver plugin via the plugins API</a></p></li><li class="list__item" id="-t8qh4i_489"><p id="-t8qh4i_505"><a href="#changes-in-compile-tasks" id="-t8qh4i_506" data-tooltip="Compile tasks have received lots of changes in this release:">Changes in compile tasks</a></p></li><li class="list__item" id="-t8qh4i_490"><p id="-t8qh4i_507"><a href="#statistics-of-generated-files-by-each-annotation-processor-in-kapt" id="-t8qh4i_508" data-tooltip="The kotlin-kapt Gradle plugin already reports performance statistics for each processor. Starting with Kotlin 1.7.0, it can also report statistics on the number of generated files for each annotation processor.">New statistics of generated files by each annotation processor in kapt</a></p></li><li class="list__item" id="-t8qh4i_491"><p id="-t8qh4i_509"><a href="#deprecation-of-the-kotlin-compiler-execution-strategy-system-property" id="-t8qh4i_510" data-tooltip="Kotlin 1.6.20 introduced new properties for defining a Kotlin compiler execution strategy. In Kotlin 1.7.0, a deprecation cycle has started for the old system property kotlin.compiler.execution.strategy in favor of the new properties.">Deprecation of the kotlin.compiler.execution.strategy system property</a></p></li><li class="list__item" id="-t8qh4i_492"><p id="-t8qh4i_511"><a href="#removal-of-deprecated-options-methods-and-plugins" id="-t8qh4i_512" data-tooltip="In Kotlin 1.7.0, we completed the deprecation cycle for the useExperimentalAnnotation Gradle method. Use optIn() instead to opt in to using an API in a module.">Removal of deprecated options, methods, and plugins</a></p></li></ul><section class="chapter"><h3 id="a-new-approach-to-incremental-compilation" data-toc="a-new-approach-to-incremental-compilation">A new approach to incremental compilation</h3><aside class="prompt" data-type="warning" data-title="" id="-t8qh4i_513"><p id="-t8qh4i_522">The new approach to incremental compilation is <a href="components-stability.html" id="-t8qh4i_523" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below). We encourage you to use it only for evaluation purposes, and we would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issues/KT" id="-t8qh4i_524" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-t8qh4i_514">In Kotlin 1.7.0, we've reworked incremental compilation for cross-module changes. Now incremental compilation is also supported for changes made inside dependent non-Kotlin modules, and it is compatible with the <a href="https://docs.gradle.org/current/userguide/build_cache.html" id="-t8qh4i_525" data-external="true" rel="noopener noreferrer" target="_blank">Gradle build cache</a>. Support for compilation avoidance has also been improved.</p><p id="-t8qh4i_515">We expect you'll see the most significant benefit of the new approach if you use the build cache or frequently make changes in non-Kotlin Gradle modules. Our tests for the Kotlin project on the <code class="code" id="-t8qh4i_526">kotlin-gradle-plugin</code> module show an improvement of greater than 80% for the changes after the cache hit.</p><p id="-t8qh4i_516">To try this new approach, set the following option in your <code class="code" id="-t8qh4i_527">gradle.properties</code>:</p><div class="code-block" data-lang="none">
kotlin.incremental.useClasspathSnapshot=true
</div><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_518"><p id="-t8qh4i_528">The new approach to incremental compilation is currently available for the JVM backend in the Gradle build system only.</p></aside><p id="-t8qh4i_519">Learn how the new approach to incremental compilation is implemented under the hood in <a href="https://blog.jetbrains.com/kotlin/2022/07/a-new-approach-to-incremental-compilation-in-kotlin/" id="-t8qh4i_529" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a>.</p><p id="-t8qh4i_520">Our plan is to stabilize this technology and add support for other backends (JS, for instance) and build systems. We'd appreciate your reports in <a href="https://youtrack.jetbrains.com/issues/KT" id="-t8qh4i_530" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a> about any issues or strange behavior you encounter in this compilation scheme. Thank you!</p><p id="-t8qh4i_521">The Kotlin team is very grateful to <a href="https://github.com/gavra0" id="-t8qh4i_531" data-external="true" rel="noopener noreferrer" target="_blank">Ivan Gavrilovic</a>, <a href="https://github.com/hungvietnguyen" id="-t8qh4i_532" data-external="true" rel="noopener noreferrer" target="_blank">Hung Nguyen</a>, <a href="https://github.com/melix" id="-t8qh4i_533" data-external="true" rel="noopener noreferrer" target="_blank">C&eacute;dric Champeau</a>, and other external contributors for their help.</p></section><section class="chapter"><h3 id="build-reports-for-kotlin-compiler-tasks" data-toc="build-reports-for-kotlin-compiler-tasks">Build reports for Kotlin compiler tasks</h3><aside class="prompt" data-type="warning" data-title="" id="-t8qh4i_534"><p id="-t8qh4i_546">Kotlin build reports are <a href="components-stability.html" id="-t8qh4i_547" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. They may be dropped or changed at any time. Opt-in is required (see details below). Use them only for evaluation purposes. We appreciate your feedback on them in <a href="https://youtrack.jetbrains.com/issues/KT" id="-t8qh4i_548" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-t8qh4i_535">Kotlin 1.7.0 introduces build reports that help track compiler performance. Reports contain the durations of different compilation phases and reasons why compilation couldn't be incremental.</p><p id="-t8qh4i_536">Build reports come in handy when you want to investigate issues with compiler tasks, for example:</p><ul class="list _bullet" id="-t8qh4i_537"><li class="list__item" id="-t8qh4i_549"><p id="-t8qh4i_551">When the Gradle build takes too much time and you want to understand the root cause of the poor performance.</p></li><li class="list__item" id="-t8qh4i_550"><p id="-t8qh4i_552">When the compilation time for the same project differs, sometimes taking seconds, sometimes taking minutes.</p></li></ul><p id="-t8qh4i_538">To enable build reports, declare where to save the build report output in <code class="code" id="-t8qh4i_553">gradle.properties</code>:</p><div class="code-block" data-lang="none">
kotlin.build.report.output=file
</div><p id="-t8qh4i_540">The following values (and their combinations) are available:</p><ul class="list _bullet" id="-t8qh4i_541"><li class="list__item" id="-t8qh4i_554"><p id="-t8qh4i_557"><code class="code" id="-t8qh4i_558">file</code> saves build reports in a local file.</p></li><li class="list__item" id="-t8qh4i_555"><p id="-t8qh4i_559"><code class="code" id="-t8qh4i_562">build_scan</code> saves build reports in the <code class="code" id="-t8qh4i_563">custom values</code> section of the <a href="https://scans.gradle.com/" id="-t8qh4i_564" data-external="true" rel="noopener noreferrer" target="_blank">build scan</a>.</p><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_560"><p id="-t8qh4i_565">The Gradle Enterprise plugin limits the number of custom values and their length. In big projects, some values could be lost.</p></aside><p id="-t8qh4i_561"></p></li><li class="list__item" id="-t8qh4i_556"><p id="-t8qh4i_566"><code class="code" id="-t8qh4i_567">http</code> posts build reports using HTTP(S). The POST method sends metrics in the JSON format. Data may change from version to version. You can see the current version of the sent data in the <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/report/data/GradleCompileStatisticsData.kt" id="-t8qh4i_568" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin repository</a>.</p></li></ul><p id="-t8qh4i_542">There are two common cases that analyzing build reports for long-running compilations can help you resolve:</p><ul class="list _bullet" id="-t8qh4i_543"><li class="list__item" id="-t8qh4i_569"><p id="-t8qh4i_571">The build wasn't incremental. Analyze the reasons and fix underlying problems.</p></li><li class="list__item" id="-t8qh4i_570"><p id="-t8qh4i_572">The build was incremental, but took too much time. Try to reorganize source files &mdash; split big files, save separate classes in different files, refactor large classes, declare top-level functions in different files, and so on.</p></li></ul><p id="-t8qh4i_544">Learn more about new build reports in <a href="https://blog.jetbrains.com/kotlin/2022/06/introducing-kotlin-build-reports/" id="-t8qh4i_573" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a>.</p><p id="-t8qh4i_545">You are welcome to try using build reports in your infrastructure. If you have any feedback, encounter any issues, or want to suggest improvements, please don't hesitate to report them in our <a href="https://youtrack.jetbrains.com/newIssue" id="-t8qh4i_574" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>. Thank you!</p></section><section class="chapter"><h3 id="bumping-minimum-supported-versions" data-toc="bumping-minimum-supported-versions">Bumping minimum supported versions</h3><p id="-t8qh4i_575">Starting with Kotlin 1.7.0, the minimum supported Gradle version is 6.7.1. We had to <a href="https://youtrack.jetbrains.com/issue/KT-49733/Bump-minimal-supported-Gradle-version-to-6-7-1" id="-t8qh4i_577" data-external="true" rel="noopener noreferrer" target="_blank">raise the version</a> to support <a href="#support-for-gradle-plugin-variants" id="-t8qh4i_578" data-tooltip="Gradle 7.0 introduced a new feature for Gradle plugin authors — plugins with variants. This feature makes it easier to add support for new Gradle features while maintaining compatibility for Gradle versions below 7.1. Learn more about variant selection in Gradle.">Gradle plugin variants</a> and the new Gradle API. In the future, we should not have to raise the minimum supported version as often, thanks to the Gradle plugin variants feature.</p><p id="-t8qh4i_576">Also, the minimal supported Android Gradle plugin version is now 3.6.4.</p></section><section class="chapter"><h3 id="support-for-gradle-plugin-variants" data-toc="support-for-gradle-plugin-variants">Support for Gradle plugin variants</h3><p id="-t8qh4i_579">Gradle 7.0 introduced a new feature for Gradle plugin authors &mdash; <a href="https://docs.gradle.org/7.0/userguide/implementing_gradle_plugins.html#plugin-with-variants" id="-t8qh4i_587" data-external="true" rel="noopener noreferrer" target="_blank">plugins with variants</a>. This feature makes it easier to add support for new Gradle features while maintaining compatibility for Gradle versions below 7.1. Learn more about <a href="https://docs.gradle.org/current/userguide/variant_model.html" id="-t8qh4i_588" data-external="true" rel="noopener noreferrer" target="_blank">variant selection in Gradle</a>.</p><p id="-t8qh4i_580">With Gradle plugin variants, we can ship different Kotlin Gradle plugin variants for different Gradle versions. The goal is to support the base Kotlin compilation in the <code class="code" id="-t8qh4i_589">main</code> variant, which corresponds to the oldest supported versions of Gradle. Each variant will have implementations for Gradle features from a corresponding release. The latest variant will support the widest Gradle feature set. With this approach, we can extend support for older Gradle versions with limited functionality.</p><p id="-t8qh4i_581">Currently, there are only two variants of the Kotlin Gradle plugin:</p><ul class="list _bullet" id="-t8qh4i_582"><li class="list__item" id="-t8qh4i_590"><p id="-t8qh4i_592"><code class="code" id="-t8qh4i_593">main</code> for Gradle versions 6.7.1&ndash;6.9.3</p></li><li class="list__item" id="-t8qh4i_591"><p id="-t8qh4i_594"><code class="code" id="-t8qh4i_595">gradle70</code> for Gradle versions 7.0 and higher</p></li></ul><p id="-t8qh4i_583">In future Kotlin releases, we may add more.</p><p id="-t8qh4i_584">To check which variant your build uses, enable the <a href="https://docs.gradle.org/current/userguide/logging.html#sec:choosing_a_log_level" id="-t8qh4i_596" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-t8qh4i_599">--info</code> log level</a> and find a string in the output starting with <code class="code" id="-t8qh4i_597">Using Kotlin Gradle plugin</code>, for example, <code class="code" id="-t8qh4i_598">Using Kotlin Gradle plugin main variant</code>.</p><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_585"><p id="-t8qh4i_600">Here are workarounds for some known issues with variant selection in Gradle:</p><ul class="list _bullet" id="-t8qh4i_601"><li class="list__item" id="-t8qh4i_602"><p id="-t8qh4i_604"><a href="https://github.com/gradle/gradle/issues/20545" id="-t8qh4i_605" data-external="true" rel="noopener noreferrer" target="_blank">ResolutionStrategy in pluginManagement is not working for plugins with multivariants</a></p></li><li class="list__item" id="-t8qh4i_603"><p id="-t8qh4i_606"><a href="https://github.com/gradle/gradle/issues/20847" id="-t8qh4i_607" data-external="true" rel="noopener noreferrer" target="_blank">Plugin variants are ignored when a plugin is added as the <code class="code" id="-t8qh4i_608">buildSrc</code> common dependency</a></p></li></ul></aside><p id="-t8qh4i_586">Leave your feedback on <a href="https://youtrack.jetbrains.com/issue/KT-49227/Support-Gradle-plugins-variants" id="-t8qh4i_609" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="updates-in-the-kotlin-gradle-plugin-api" data-toc="updates-in-the-kotlin-gradle-plugin-api">Updates in the Kotlin Gradle plugin API</h3><p id="-t8qh4i_610">The Kotlin Gradle plugin API artifact has received several improvements:</p><ul class="list _bullet" id="-t8qh4i_611"><li class="list__item" id="-t8qh4i_612"><p id="-t8qh4i_615">There are new interfaces for Kotlin/JVM and Kotlin/kapt tasks with user-configurable inputs.</p></li><li class="list__item" id="-t8qh4i_613"><p id="-t8qh4i_616">There is a new <code class="code" id="-t8qh4i_619">KotlinBasePlugin</code> interface that all Kotlin plugins inherit from. Use this interface when you want to trigger some configuration action whenever any Kotlin Gradle plugin (JVM, JS, Multiplatform, Native, and other platforms) is applied:</p><div class="code-block" data-lang="kotlin">
project.plugins.withType&lt;org.jetbrains.kotlin.gradle.plugin.KotlinBasePlugin&gt;() {
    // Configure your action here
}
</div><p id="-t8qh4i_618">You can leave your feedback about the <code class="code" id="-t8qh4i_620">KotlinBasePlugin</code> in <a href="https://youtrack.jetbrains.com/issue/KT-48008/Consider-offering-a-KotlinBasePlugin" id="-t8qh4i_621" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></li><li class="list__item" id="-t8qh4i_614"><p id="-t8qh4i_622">We've laid the groundwork for the Android Gradle plugin to configure Kotlin compilation within itself, meaning you won't need to add the Kotlin Android Gradle plugin to your build. Follow <a href="https://developer.android.com/studio/releases/gradle-plugin" id="-t8qh4i_623" data-external="true" rel="noopener noreferrer" target="_blank">Android Gradle Plugin release announcements</a> to learn about the added support and try it out!</p></li></ul></section><section class="chapter"><h3 id="the-sam-with-receiver-plugin-is-available-via-the-plugins-api" data-toc="the-sam-with-receiver-plugin-is-available-via-the-plugins-api">The sam-with-receiver plugin is available via the plugins API</h3><p id="-t8qh4i_624">The <a href="sam-with-receiver-plugin.html" id="-t8qh4i_626" data-tooltip="The sam-with-receiver compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM…">sam-with-receiver compiler plugin</a> is now available via the <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" id="-t8qh4i_627" data-external="true" rel="noopener noreferrer" target="_blank">Gradle plugins DSL</a>:</p><div class="code-block" data-lang="kotlin">
plugins {
    id(&quot;org.jetbrains.kotlin.plugin.sam.with.receiver&quot;) version &quot;$kotlin_version&quot;
}
</div></section><section class="chapter"><h3 id="changes-in-compile-tasks" data-toc="changes-in-compile-tasks">Changes in compile tasks</h3><p id="-t8qh4i_628">Compile tasks have received lots of changes in this release:</p><ul class="list _bullet" id="-t8qh4i_629"><li class="list__item" id="-t8qh4i_631"><p id="-t8qh4i_638">Kotlin compile tasks no longer inherit the Gradle <code class="code" id="-t8qh4i_639">AbstractCompile</code> task. They inherit only the <code class="code" id="-t8qh4i_640">DefaultTask</code>.</p></li><li class="list__item" id="-t8qh4i_632"><p id="-t8qh4i_641">The <code class="code" id="-t8qh4i_642">AbstractCompile</code> task has the <code class="code" id="-t8qh4i_643">sourceCompatibility</code> and <code class="code" id="-t8qh4i_644">targetCompatibility</code> inputs. Since the <code class="code" id="-t8qh4i_645">AbstractCompile</code> task is no longer inherited, these inputs are no longer available in Kotlin users' scripts.</p></li><li class="list__item" id="-t8qh4i_633"><p id="-t8qh4i_646">The <code class="code" id="-t8qh4i_647">SourceTask.stableSources</code> input is no longer available, and you should use the <code class="code" id="-t8qh4i_648">sources</code> input. <code class="code" id="-t8qh4i_649">setSource(...)</code> methods are still available.</p></li><li class="list__item" id="-t8qh4i_634"><p id="-t8qh4i_650">All compile tasks now use the <code class="code" id="-t8qh4i_651">libraries</code> input for a list of libraries required for compilation. The <code class="code" id="-t8qh4i_652">KotlinCompile</code> task still has the deprecated Kotlin property <code class="code" id="-t8qh4i_653">classpath</code>, which will be removed in future releases.</p></li><li class="list__item" id="-t8qh4i_635"><p id="-t8qh4i_654">Compile tasks still implement the <code class="code" id="-t8qh4i_655">PatternFilterable</code> interface, which allows the filtering of Kotlin sources. The <code class="code" id="-t8qh4i_656">sourceFilesExtensions</code> input was removed in favor of using <code class="code" id="-t8qh4i_657">PatternFilterable</code> methods.</p></li><li class="list__item" id="-t8qh4i_636"><p id="-t8qh4i_658">The deprecated <code class="code" id="-t8qh4i_659">Gradle destinationDir: File</code> output was replaced with the <code class="code" id="-t8qh4i_660">destinationDirectory: DirectoryProperty</code> output.</p></li><li class="list__item" id="-t8qh4i_637"><p id="-t8qh4i_661">The Kotlin/Native <code class="code" id="-t8qh4i_662">AbstractNativeCompile</code> task now inherits the <code class="code" id="-t8qh4i_663">AbstractKotlinCompileTool</code> base class. This is an initial step toward integrating Kotlin/Native build tools into all the other tools.</p></li></ul><p id="-t8qh4i_630">Please leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-32805" id="-t8qh4i_664" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="statistics-of-generated-files-by-each-annotation-processor-in-kapt" data-toc="statistics-of-generated-files-by-each-annotation-processor-in-kapt">Statistics of generated files by each annotation processor in kapt</h3><p id="-t8qh4i_665">The <code class="code" id="-t8qh4i_673">kotlin-kapt</code> Gradle plugin already <a href="https://github.com/JetBrains/kotlin/pull/4280" id="-t8qh4i_674" data-external="true" rel="noopener noreferrer" target="_blank">reports performance statistics for each processor</a>. Starting with Kotlin 1.7.0, it can also report statistics on the number of generated files for each annotation processor.</p><p id="-t8qh4i_666">This is useful to track if there are unused annotation processors as a part of the build. You can use the generated report to find modules that trigger unnecessary annotation processors and update the modules to prevent that.</p><p id="-t8qh4i_667">Enable the statistics in two steps:</p><ul class="list _bullet" id="-t8qh4i_668"><li class="list__item" id="-t8qh4i_675"><p id="-t8qh4i_677">Set the <code class="code" id="-t8qh4i_679">showProcessorStats</code> flag to <code class="code" id="-t8qh4i_680">true</code> in your <code class="code" id="-t8qh4i_681">build.gradle.kts</code>:</p><div class="code-block" data-lang="kotlin">
kapt {
    showProcessorStats = true
}
</div></li><li class="list__item" id="-t8qh4i_676"><p id="-t8qh4i_682">Set the <code class="code" id="-t8qh4i_684">kapt.verbose</code> Gradle property to <code class="code" id="-t8qh4i_685">true</code> in your <code class="code" id="-t8qh4i_686">gradle.properties</code>:</p><div class="code-block" data-lang="none">
kapt.verbose=true
</div></li></ul><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_669"><p id="-t8qh4i_687">You can also enable verbose output via the <a href="kapt.html#use-in-cli" id="-t8qh4i_688" data-tooltip="kapt compiler plugin is available in the binary distribution of the Kotlin compiler.">command line option <code class="code" id="-t8qh4i_689">verbose</code></a>.</p></aside><p id="-t8qh4i_670">The statistics will appear in the logs with the <code class="code" id="-t8qh4i_690">info</code> level. You'll see the <code class="code" id="-t8qh4i_691">Annotation processor stats:</code> line followed by statistics on the execution time of each annotation processor. After these lines, there will be the <code class="code" id="-t8qh4i_692">Generated files report:</code> line followed by statistics on the number of generated files for each annotation processor. For example:</p><div class="code-block" data-lang="none">
[INFO] Annotation processor stats:
[INFO] org.mapstruct.ap.MappingProcessor: total: 290 ms, init: 1 ms, 3 round(s): 289 ms, 0 ms, 0 ms
[INFO] Generated files report:
[INFO] org.mapstruct.ap.MappingProcessor: total sources: 2, sources per round: 2, 0, 0
</div><p id="-t8qh4i_672">Please leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-51132/KAPT-Support-reporting-the-number-of-generated-files-by-each-ann" id="-t8qh4i_693" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="deprecation-of-the-kotlin-compiler-execution-strategy-system-property" data-toc="deprecation-of-the-kotlin-compiler-execution-strategy-system-property">Deprecation of the kotlin.compiler.execution.strategy system property</h3><p id="-t8qh4i_694">Kotlin 1.6.20 introduced <a href="whatsnew1620.html#properties-for-defining-kotlin-compiler-execution-strategy" id="-t8qh4i_698" data-tooltip="Before Kotlin 1.6.20, you used the system property -Dkotlin.compiler.execution.strategy to define a Kotlin compiler execution strategy. This property might have been inconvenient in some cases. Kotlin 1.6.20 introduces a Gradle property with the same name,…">new properties for defining a Kotlin compiler execution strategy</a>. In Kotlin 1.7.0, a deprecation cycle has started for the old system property <code class="code" id="-t8qh4i_699">kotlin.compiler.execution.strategy</code> in favor of the new properties.</p><p id="-t8qh4i_695">When using the <code class="code" id="-t8qh4i_700">kotlin.compiler.execution.strategy</code> system property, you'll receive a warning. This property will be deleted in future releases. To preserve the old behavior, replace the system property with the Gradle property of the same name. You can do this in <code class="code" id="-t8qh4i_701">gradle.properties</code>, for example:</p><div class="code-block" data-lang="none">
kotlin.compiler.execution.strategy=out-of-process
</div><p id="-t8qh4i_697">You can also use the compile task property <code class="code" id="-t8qh4i_702">compilerExecutionStrategy</code>. Learn more about this on the <a href="gradle-compilation-and-caches.html#defining-kotlin-compiler-execution-strategy" id="-t8qh4i_703" data-tooltip="Kotlin compiler execution strategy defines where the Kotlin compiler is executed and if incremental compilation is supported in each case.">Gradle page</a>.</p></section><section class="chapter"><h3 id="removal-of-deprecated-options-methods-and-plugins" data-toc="removal-of-deprecated-options-methods-and-plugins">Removal of deprecated options, methods, and plugins</h3><section class="chapter"><h4 id="removal-of-the-useexperimentalannotation-method" data-toc="removal-of-the-useexperimentalannotation-method">Removal of the useExperimentalAnnotation method</h4><p id="-t8qh4i_709">In Kotlin 1.7.0, we completed the deprecation cycle for the <code class="code" id="-t8qh4i_713">useExperimentalAnnotation</code> Gradle method. Use <code class="code" id="-t8qh4i_714">optIn()</code> instead to opt in to using an API in a module.</p><p id="-t8qh4i_710">For example, if your Gradle module is multiplatform:</p><div class="code-block" data-lang="kotlin">
sourceSets {
    all {
        languageSettings.optIn(&quot;org.mylibrary.OptInAnnotation&quot;)
    }
}
</div><p id="-t8qh4i_712">Learn more about <a href="opt-in-requirements.html" id="-t8qh4i_715" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">opt-in requirements</a> in Kotlin.</p></section><section class="chapter"><h4 id="removal-of-deprecated-compiler-options" data-toc="removal-of-deprecated-compiler-options">Removal of deprecated compiler options</h4><p id="-t8qh4i_716">We've completed the deprecation cycle for several compiler options:</p><ul class="list _bullet" id="-t8qh4i_717"><li class="list__item" id="-t8qh4i_719"><p id="-t8qh4i_721">The <code class="code" id="-t8qh4i_722">kotlinOptions.jdkHome</code> compiler option was deprecated in 1.5.30 and has been removed in the current release. Gradle builds now fail if they contain this option. We encourage you to use <a href="whatsnew1530.html#support-for-java-toolchains" id="-t8qh4i_723" data-tooltip="Gradle 6.7 introduced the &quot;Java toolchains support&quot; feature. Using this feature, you can:">Java toolchains</a>, which have been supported since Kotlin 1.5.30.</p></li><li class="list__item" id="-t8qh4i_720"><p id="-t8qh4i_724">The deprecated <code class="code" id="-t8qh4i_725">noStdlib</code> compiler option has also been removed. The Gradle plugin uses the <code class="code" id="-t8qh4i_726">kotlin.stdlib.default.dependency=true</code> property to control whether the Kotlin standard library is present.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_718"><p id="-t8qh4i_727">The compiler arguments <code class="code" id="-t8qh4i_728">-jdkHome</code> and <code class="code" id="-t8qh4i_729">-no-stdlib</code> are still available.</p></aside></section><section class="chapter"><h4 id="removal-of-deprecated-plugins" data-toc="removal-of-deprecated-plugins">Removal of deprecated plugins</h4><p id="-t8qh4i_730">In Kotlin 1.4.0, the <code class="code" id="-t8qh4i_733">kotlin2js</code> and <code class="code" id="-t8qh4i_734">kotlin-dce-plugin</code> plugins were deprecated, and they have been removed in this release. Instead of <code class="code" id="-t8qh4i_735">kotlin2js</code>, use the new <code class="code" id="-t8qh4i_736">org.jetbrains.kotlin.js</code> plugin. Dead code elimination (DCE) works when the Kotlin/JS Gradle plugin is <a href="javascript-dce.html" id="-t8qh4i_737" data-tooltip="The dead code elimination (DCE) tool is deprecated. The DCE tool was designed for the legacy JS backend, which is now obsolete. The current JS IR backend supports DCE out of the box, and the @JsExport annotation allows specifying which Kotlin functions and classes to retain during…">properly configured</a>.</p><p id="-t8qh4i_731">In Kotlin 1.6.0, we changed the deprecation level of the <code class="code" id="-t8qh4i_738">KotlinGradleSubplugin</code> class to <code class="code" id="-t8qh4i_739">ERROR</code>. Developers used this class for writing compiler plugins. In this release, <a href="https://youtrack.jetbrains.com/issue/KT-48831/" id="-t8qh4i_740" data-external="true" rel="noopener noreferrer" target="_blank">this class has been removed</a>. Use the <code class="code" id="-t8qh4i_741">KotlinCompilerPluginSupportPlugin</code> class instead.</p><aside class="prompt" data-type="tip" data-title="" id="-t8qh4i_732"><p id="-t8qh4i_742">The best practice is to use Kotlin plugins with versions 1.7.0 and higher throughout your project.</p></aside></section><section class="chapter"><h4 id="removal-of-the-deprecated-coroutines-dsl-option-and-property" data-toc="removal-of-the-deprecated-coroutines-dsl-option-and-property">Removal of the deprecated coroutines DSL option and property</h4><p id="-t8qh4i_743">We removed the deprecated <code class="code" id="-t8qh4i_745">kotlin.experimental.coroutines</code> Gradle DSL option and the <code class="code" id="-t8qh4i_746">kotlin.coroutines</code> property used in <code class="code" id="-t8qh4i_747">gradle.properties</code>. Now you can just use <span class="emphasis" id="-t8qh4i_748"><span id="-t8qh4i_750">suspending functions</span></span> or <a href="gradle-configure-project.html#set-a-dependency-on-a-kotlinx-library" id="-t8qh4i_749" data-tooltip="If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library's base artifact name, such as kotlinx-coroutines-core or ktor-client-core:">add the <code class="code" id="-t8qh4i_751">kotlinx.coroutines</code> dependency</a> to your build script.</p><p id="-t8qh4i_744">Learn more about coroutines in the <span id="-t8qh4i_752">Coroutines guide</span>.</p></section><section class="chapter"><h4 id="removal-of-the-type-cast-in-the-toolchain-extension-method" data-toc="removal-of-the-type-cast-in-the-toolchain-extension-method">Removal of the type cast in the toolchain extension method</h4><p id="-t8qh4i_753">Before Kotlin 1.7.0, you had to do the type cast into the <code class="code" id="-t8qh4i_757">JavaToolchainSpec</code> class when configuring the Gradle toolchain with Kotlin DSL:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvmToolchain {
        (this as JavaToolchainSpec).languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)
    }
}
</div><p id="-t8qh4i_755">Now, you can omit the <code class="code" id="-t8qh4i_758">(this as JavaToolchainSpec)</code> part:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)
    }
}
</div></section></section></section><section class="chapter"><h2 id="migrating-to-kotlin-1-7-0" data-toc="migrating-to-kotlin-1-7-0">Migrating to Kotlin 1.7.0</h2><section class="chapter"><h3 id="install-kotlin-1-7-0" data-toc="install-kotlin-1-7-0">Install Kotlin 1.7.0</h3><p id="-t8qh4i_762">IntelliJ IDEA 2022.1 and Android Studio Chipmunk (212) automatically suggest updating the Kotlin plugin to 1.7.0.</p><aside class="prompt" data-type="note" data-title="" id="-t8qh4i_763"><p id="-t8qh4i_765">For IntelliJ IDEA 2022.2, and Android Studio Dolphin (213) or Android Studio Electric Eel (221), the Kotlin plugin 1.7.0 will be delivered with upcoming IntelliJ IDEA and Android Studios updates.</p></aside><p id="-t8qh4i_764">The new command-line compiler is available for download on the <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.7.0" id="-t8qh4i_766" data-external="true" rel="noopener noreferrer" target="_blank">GitHub release page</a>.</p></section><section class="chapter"><h3 id="migrate-existing-or-start-a-new-project-with-kotlin-1-7-0" data-toc="migrate-existing-or-start-a-new-project-with-kotlin-1-7-0">Migrate existing or start a new project with Kotlin 1.7.0</h3><ul class="list _bullet" id="-t8qh4i_767"><li class="list__item" id="-t8qh4i_768"><p id="-t8qh4i_770">To migrate existing projects to Kotlin 1.7.0, change the Kotlin version to <code class="code" id="-t8qh4i_771">1.7.0</code> and reimport your Gradle or Maven project. <a href="releases.html#update-to-a-new-kotlin-version" id="-t8qh4i_772" data-tooltip="To upgrade your project to a new release, you need to update your build script file. For example, to update to Kotlin 2.1.20, change the version of the Kotlin Gradle plugin in your build.gradle(.kts) file:">Learn how to update to Kotlin 1.7.0</a>.</p></li><li class="list__item" id="-t8qh4i_769"><p id="-t8qh4i_773">To start a new project with Kotlin 1.7.0, update the Kotlin plugin and run the Project Wizard from <span class="control" id="-t8qh4i_774">File</span> | <span class="control" id="-t8qh4i_775">New</span> | <span class="control" id="-t8qh4i_776">Project</span>.</p></li></ul></section><section class="chapter"><h3 id="compatibility-guide-for-kotlin-1-7-0" data-toc="compatibility-guide-for-kotlin-1-7-0">Compatibility guide for Kotlin 1.7.0</h3><p id="-t8qh4i_777">Kotlin 1.7.0 is a <a href="kotlin-evolution-principles.html#language-and-tooling-releases" id="-t8qh4i_778" data-tooltip="Stable releases with versions, such as 2.0.0, are usually considered to be language releases bringing major changes in the language. Normally, we publish tooling releases, numbered x.x.20 in between language releases.">feature release</a> and can, therefore, bring changes that are incompatible with your code written for earlier versions of the language. Find the detailed list of such changes in the <a href="compatibility-guide-17.html" id="-t8qh4i_779" data-tooltip="Keeping the Language Modern and Comfortable Updates are among the fundamental principles in Kotlin Language Design. The former says that constructs which obstruct language evolution should be removed, and the latter says that this removal should be well-communicated beforehand to…">Compatibility guide for Kotlin 1.7.0</a>.</p></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew1720.html" class="navigation-links__prev">What's new in Kotlin 1.7.20</a><a href="whatsnew1620.html" class="navigation-links__next">What's new in Kotlin 1.6.20</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>