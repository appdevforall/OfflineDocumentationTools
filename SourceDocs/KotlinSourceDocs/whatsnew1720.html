<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:02.947385077"><title>What's new in Kotlin 1.7.20 | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"support-for-kotlin-k2-compiler-plugins","level":0,"title":"Support for Kotlin K2 compiler plugins","anchor":"#support-for-kotlin-k2-compiler-plugins"},{"id":"how-to-enable-the-kotlin-k2-compiler","level":1,"title":"How to enable the Kotlin K2 compiler","anchor":"#how-to-enable-the-kotlin-k2-compiler"},{"id":"leave-your-feedback-on-the-new-k2-compiler","level":1,"title":"Leave your feedback on the new K2 compiler","anchor":"#leave-your-feedback-on-the-new-k2-compiler"},{"id":"language","level":0,"title":"Language","anchor":"#language"},{"id":"preview-of-the-operator-for-creating-open-ended-ranges","level":1,"title":"Preview of the ..\u003c operator for creating open-ended ranges","anchor":"#preview-of-the-operator-for-creating-open-ended-ranges"},{"id":"improved-string-representations-for-singletons-and-sealed-class-hierarchies-with-data-objects","level":1,"title":"Improved string representations for singletons and sealed class hierarchies with data objects","anchor":"#improved-string-representations-for-singletons-and-sealed-class-hierarchies-with-data-objects"},{"id":"new-builder-type-inference-restrictions","level":1,"title":"New builder type inference restrictions","anchor":"#new-builder-type-inference-restrictions"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"generic-inline-classes","level":1,"title":"Generic inline classes","anchor":"#generic-inline-classes"},{"id":"more-optimized-cases-of-delegated-properties","level":1,"title":"More optimized cases of delegated properties","anchor":"#more-optimized-cases-of-delegated-properties"},{"id":"support-for-the-jvm-ir-backend-in-kapt-stub-generating-task","level":1,"title":"Support for the JVM IR backend in kapt stub generating task","anchor":"#support-for-the-jvm-ir-backend-in-kapt-stub-generating-task"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"the-new-kotlin-native-memory-manager-enabled-by-default","level":1,"title":"The new Kotlin/Native memory manager enabled by default","anchor":"#the-new-kotlin-native-memory-manager-enabled-by-default"},{"id":"customizing-the-info-plist-file","level":1,"title":"Customizing the Info.plist file","anchor":"#customizing-the-info-plist-file"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"gradle","level":0,"title":"Gradle","anchor":"#gradle"},{"id":"target-configuration","level":1,"title":"Target configuration","anchor":"#target-configuration"},{"id":"source-directories-configuration","level":1,"title":"Source directories configuration","anchor":"#source-directories-configuration"},{"id":"new-method-for-jvm-toolchain-configuration","level":1,"title":"New method for JVM toolchain configuration","anchor":"#new-method-for-jvm-toolchain-configuration"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"documentation-updates","level":0,"title":"Documentation updates","anchor":"#documentation-updates"},{"id":"revamped-and-improved-pages","level":1,"title":"Revamped and improved pages","anchor":"#revamped-and-improved-pages"},{"id":"new-articles-in-the-kotlin-multiplatform-journal","level":1,"title":"New articles in the Kotlin Multiplatform journal","anchor":"#new-articles-in-the-kotlin-multiplatform-journal"},{"id":"new-and-updated-tutorials","level":1,"title":"New and updated tutorials","anchor":"#new-and-updated-tutorials"},{"id":"changes-in-release-documentation","level":1,"title":"Changes in release documentation","anchor":"#changes-in-release-documentation"},{"id":"install-kotlin-1-7-20","level":0,"title":"Install Kotlin 1.7.20","anchor":"#install-kotlin-1-7-20"},{"id":"compatibility-guide-for-kotlin-1-7-20","level":1,"title":"Compatibility guide for Kotlin 1.7.20","anchor":"#compatibility-guide-for-kotlin-1-7-20"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.7.20 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/whatsnew1720.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="What's new in Kotlin 1.7.20 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/whatsnew1720.html#webpage",
    "url": "writerside-documentation/whatsnew1720.html",
    "name": "What's new in Kotlin 1.7.20 | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="whatsnew1720" data-main-title="What's new in Kotlin 1.7.20" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew1720" id="whatsnew1720.md">What's new in Kotlin 1.7.20</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;q2xrww_17\&quot;\u003eThe IDE support for Kotlin 1.7.20 is available for IntelliJ IDEA 2021.3, 2022.1, and 2022.2.\u003c/p\u003e&quot;]}"></div><p id="q2xrww_3"><span class="emphasis" id="q2xrww_18"><a href="releases.html#release-details" id="q2xrww_19" data-tooltip="The following table lists details of the latest Kotlin releases:">Released: 29 September 2022</a></span></p><p id="q2xrww_4">The Kotlin 1.7.20 release is out! Here are some highlights from this release:</p><ul class="list _bullet" id="q2xrww_5"><li class="list__item" id="q2xrww_20"><p id="q2xrww_24"><a href="#support-for-kotlin-k2-compiler-plugins" id="q2xrww_25" data-tooltip="The Kotlin team continues to stabilize the K2 compiler. K2 is still in Alpha (as announced in the Kotlin 1.7.0 release), but it now supports several compiler plugins. You can follow this YouTrack issue to get updates from the Kotlin team on the new compiler.">The new Kotlin K2 compiler supports <code class="code" id="q2xrww_26">all-open</code>, SAM with receiver, Lombok, and other compiler plugins</a></p></li><li class="list__item" id="q2xrww_21"><p id="q2xrww_27"><a href="#preview-of-the-operator-for-creating-open-ended-ranges" id="q2xrww_28" data-tooltip="The new operator is Experimental, and it has limited support in the IDE.">We introduced the preview of the <code class="code" id="q2xrww_29">..&lt;</code> operator for creating open-ended ranges</a></p></li><li class="list__item" id="q2xrww_22"><p id="q2xrww_30"><a href="#the-new-kotlin-native-memory-manager-enabled-by-default" id="q2xrww_31" data-tooltip="This release brings further stability and performance improvements to the new memory manager, allowing us to promote the new memory manager to Beta.">The new Kotlin/Native memory manager is now enabled by default</a></p></li><li class="list__item" id="q2xrww_23"><p id="q2xrww_32"><a href="#generic-inline-classes" id="q2xrww_33" data-tooltip="Generic inline classes is an Experimental feature. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">We introduced a new experimental feature for JVM: inline classes with a generic underlying type</a></p></li></ul><p id="q2xrww_6">You can also find a short overview of the changes in this video:</p><div class="video-player" id="q2xrww_7"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/OG9npowJgE8?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><section class="chapter"><h2 id="support-for-kotlin-k2-compiler-plugins" data-toc="support-for-kotlin-k2-compiler-plugins">Support for Kotlin K2 compiler plugins</h2><p id="q2xrww_34">The Kotlin team continues to stabilize the K2 compiler. K2 is still in <span class="control" id="q2xrww_42">Alpha</span> (as announced in the <a href="whatsnew17.html#new-kotlin-k2-compiler-for-the-jvm-in-alpha" id="q2xrww_43" data-tooltip="This Kotlin release introduces the Alpha version of the new Kotlin K2 compiler. The new compiler aims to speed up the development of new language features, unify all of the platforms Kotlin supports, bring performance improvements, and provide an API for compiler extensions.">Kotlin 1.7.0 release</a>), but it now supports several compiler plugins. You can follow <a href="https://youtrack.jetbrains.com/issue/KT-52604" id="q2xrww_44" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack issue</a> to get updates from the Kotlin team on the new compiler.</p><p id="q2xrww_35">Starting with this 1.7.20 release, the Kotlin K2 compiler supports the following plugins:</p><ul class="list _bullet" id="q2xrww_36"><li class="list__item" id="q2xrww_45"><p id="q2xrww_51"><a href="all-open-plugin.html" id="q2xrww_52" data-tooltip="Kotlin has classes and their members final by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be open. The all-open compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with…"><code class="code" id="q2xrww_53">all-open</code></a></p></li><li class="list__item" id="q2xrww_46"><p id="q2xrww_54"><a href="no-arg-plugin.html" id="q2xrww_55" data-tooltip="The no-arg compiler plugin generates an additional zero-argument constructor for classes with a specific annotation."><code class="code" id="q2xrww_56">no-arg</code></a></p></li><li class="list__item" id="q2xrww_47"><p id="q2xrww_57"><a href="sam-with-receiver-plugin.html" id="q2xrww_58" data-tooltip="The sam-with-receiver compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM…">SAM with receiver</a></p></li><li class="list__item" id="q2xrww_48"><p id="q2xrww_59"><a href="lombok.html" id="q2xrww_60" data-tooltip="The Lombok compiler plugin is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Lombok</a></p></li><li class="list__item" id="q2xrww_49"><p id="q2xrww_61">AtomicFU</p></li><li class="list__item" id="q2xrww_50"><p id="q2xrww_62"><code class="code" id="q2xrww_63">jvm-abi-gen</code></p></li></ul><aside class="prompt" data-type="warning" data-title="" id="q2xrww_37"><p id="q2xrww_64">The Alpha version of the new K2 compiler only works with JVM projects. It doesn't support Kotlin/JS, Kotlin/Native, or other multiplatform projects.</p></aside><p id="q2xrww_38">Learn more about the new compiler and its benefits in the following videos:</p><ul class="list _bullet" id="q2xrww_39"><li class="list__item" id="q2xrww_65"><p id="q2xrww_67"><a href="https://www.youtube.com/watch?v=iTdJJq_LyoY" id="q2xrww_68" data-external="true" rel="noopener noreferrer" target="_blank">The Road to the New Kotlin Compiler</a></p></li><li class="list__item" id="q2xrww_66"><p id="q2xrww_69"><a href="https://www.youtube.com/watch?v=db19VFLZqJM" id="q2xrww_70" data-external="true" rel="noopener noreferrer" target="_blank">K2 Compiler: a Top-Down View</a></p></li></ul><section class="chapter"><h3 id="how-to-enable-the-kotlin-k2-compiler" data-toc="how-to-enable-the-kotlin-k2-compiler">How to enable the Kotlin K2 compiler</h3><p id="q2xrww_71">To enable the Kotlin K2 compiler and test it, use the following compiler option:</p><div class="code-block" data-lang="bash">
-Xuse-k2
</div><p id="q2xrww_73">You can specify it in your <code class="code" id="q2xrww_76">build.gradle(.kts)</code> file:</p><div class="tabs" id="q2xrww_74" data-group="build-script" data-anchors="[q2xrww_77,q2xrww_78]"><div class="tabs__content" data-gtm="tab" id="q2xrww_77" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
tasks.withType&lt;KotlinCompile&gt; {
    kotlinOptions.useK2 = true
}
</div></div><div class="tabs__content" data-gtm="tab" id="q2xrww_78" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
compileKotlin {
    kotlinOptions.useK2 = true
}
</div></div></div><p id="q2xrww_75">Check out the performance boost on your JVM projects and compare it with the results of the old compiler.</p></section><section class="chapter"><h3 id="leave-your-feedback-on-the-new-k2-compiler" data-toc="leave-your-feedback-on-the-new-k2-compiler">Leave your feedback on the new K2 compiler</h3><p id="q2xrww_81">We really appreciate your feedback in any form:</p><ul class="list _bullet" id="q2xrww_82"><li class="list__item" id="q2xrww_83"><p id="q2xrww_86">Provide your feedback directly to K2 developers in Kotlin Slack: <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*ju6cbn*_ga*MTA3MTk5NDkzMC4xNjQ2MDY3MDU4*_ga_9J976DJZ68*MTY1ODMzNzA3OS4xMDAuMS4xNjU4MzQwODEwLjYw" id="q2xrww_87" data-external="true" rel="noopener noreferrer" target="_blank">get an invite</a> and join the <a href="https://kotlinlang.slack.com/archives/C03PK0PE257" id="q2xrww_88" data-external="true" rel="noopener noreferrer" target="_blank">#k2-early-adopters</a> channel.</p></li><li class="list__item" id="q2xrww_84"><p id="q2xrww_89">Report any problems you faced with the new K2 compiler to <a href="https://kotl.in/issue" id="q2xrww_90" data-external="true" rel="noopener noreferrer" target="_blank">our issue tracker</a>.</p></li><li class="list__item" id="q2xrww_85"><p id="q2xrww_91"><a href="https://www.jetbrains.com/help/idea/settings-usage-statistics.html" id="q2xrww_92" data-external="true" rel="noopener noreferrer" target="_blank">Enable the <span class="control" id="q2xrww_93">Send usage statistics</span> option</a> to allow JetBrains collecting anonymous data about K2 usage.</p></li></ul></section></section><section class="chapter"><h2 id="language" data-toc="language">Language</h2><p id="q2xrww_94">Kotlin 1.7.20 introduces preview versions for new language features, as well as puts restrictions on builder type inference:</p><ul class="list _bullet" id="q2xrww_95"><li class="list__item" id="q2xrww_99"><p id="q2xrww_102"><a href="#preview-of-the-operator-for-creating-open-ended-ranges" id="q2xrww_103" data-tooltip="The new operator is Experimental, and it has limited support in the IDE.">Preview of the ..&lt; operator for creating open-ended ranges</a></p></li><li class="list__item" id="q2xrww_100"><p id="q2xrww_104"><a href="#improved-string-representations-for-singletons-and-sealed-class-hierarchies-with-data-objects" id="q2xrww_105" data-tooltip="Data objects are Experimental, and have limited support in the IDE at the moment.">New data object declarations</a></p></li><li class="list__item" id="q2xrww_101"><p id="q2xrww_106"><a href="#new-builder-type-inference-restrictions" id="q2xrww_107" data-tooltip="Kotlin 1.7.20 places some major restrictions on the use of builder type inference that could affect your code. These restrictions apply to code containing builder lambda functions, where it's impossible to derive the parameter without analyzing the lambda itself. The parameter is…">Builder type inference restrictions</a></p></li></ul><section class="chapter"><h3 id="preview-of-the-operator-for-creating-open-ended-ranges" data-toc="preview-of-the-operator-for-creating-open-ended-ranges">Preview of the ..&lt; operator for creating open-ended ranges</h3><aside class="prompt" data-type="warning" data-title="" id="q2xrww_108"><p id="q2xrww_116">The new operator is <a href="components-stability.html#stability-levels-explained" id="q2xrww_117" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>, and it has limited support in the IDE.</p></aside><p id="q2xrww_109">This release introduces the new <code class="code" id="q2xrww_118">..&lt;</code> operator. Kotlin has the <code class="code" id="q2xrww_119">..</code> operator to express a range of values. The new <code class="code" id="q2xrww_120">..&lt;</code> operator acts like the <code class="code" id="q2xrww_121">until</code> function and helps you define the open-ended range.</p><div class="video-player" id="q2xrww_110"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/v0AHdAIBnbs?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><p id="q2xrww_111">Our research shows that this new operator does a better job at expressing open-ended ranges and making it clear that the upper bound is not included.</p><p id="q2xrww_112">Here is an example of using the <code class="code" id="q2xrww_122">..&lt;</code> operator in a <code class="code" id="q2xrww_123">when</code> expression:</p><div class="code-block" data-lang="kotlin">
when (value) {
    in 0.0..&lt;0.25 -&gt; // First quarter
    in 0.25..&lt;0.5 -&gt; // Second quarter
    in 0.5..&lt;0.75 -&gt; // Third quarter
    in 0.75..1.0 -&gt;  // Last quarter  &lt;- Note closed range here
}
</div><section class="chapter"><h4 id="standard-library-api-changes" data-toc="standard-library-api-changes">Standard library API changes</h4><p id="q2xrww_124">The following new types and operations will be introduced in the <code class="code" id="q2xrww_128">kotlin.ranges</code> packages in the common Kotlin standard library:</p><section class="chapter"><h5 id="new-openendrange-t-interface" data-toc="new-openendrange-t-interface">New OpenEndRange&lt;T&gt; interface</h5><p id="q2xrww_130">The new interface to represent open-ended ranges is very similar to the existing <code class="code" id="q2xrww_132">ClosedRange&lt;T&gt;</code> interface:</p><div class="code-block" data-lang="kotlin">
interface OpenEndRange&lt;T : Comparable&lt;T&gt;&gt; {
    // Lower bound
    val start: T
    // Upper bound, not included in the range
    val endExclusive: T
    operator fun contains(value: T): Boolean = value &gt;= start &amp;&amp; value &lt; endExclusive
    fun isEmpty(): Boolean = start &gt;= endExclusive
}
</div></section><section class="chapter"><h5 id="implementing-openendrange-in-the-existing-iterable-ranges" data-toc="implementing-openendrange-in-the-existing-iterable-ranges">Implementing OpenEndRange in the existing iterable ranges</h5><p id="q2xrww_133">When developers need to get a range with an excluded upper bound, they currently use the <code class="code" id="q2xrww_135">until</code> function to effectively produce a closed iterable range with the same values. To make these ranges acceptable in the new API that takes <code class="code" id="q2xrww_136">OpenEndRange&lt;T&gt;</code>, we want to implement that interface in the existing iterable ranges: <code class="code" id="q2xrww_137">IntRange</code>, <code class="code" id="q2xrww_138">LongRange</code>, <code class="code" id="q2xrww_139">CharRange</code>, <code class="code" id="q2xrww_140">UIntRange</code>, and <code class="code" id="q2xrww_141">ULongRange</code>. So they will simultaneously implement both the <code class="code" id="q2xrww_142">ClosedRange&lt;T&gt;</code> and <code class="code" id="q2xrww_143">OpenEndRange&lt;T&gt;</code> interfaces.</p><div class="code-block" data-lang="kotlin">
class IntRange : IntProgression(...), ClosedRange&lt;Int&gt;, OpenEndRange&lt;Int&gt; {
    override val start: Int
    override val endInclusive: Int
    override val endExclusive: Int
}
</div></section><section class="chapter"><h5 id="rangeuntil-operators-for-the-standard-types" data-toc="rangeuntil-operators-for-the-standard-types">rangeUntil operators for the standard types</h5><p id="q2xrww_144">The <code class="code" id="q2xrww_145">rangeUntil</code> operators will be provided for the same types and combinations currently defined by the <code class="code" id="q2xrww_146">rangeTo</code> operator. We provide them as extension functions for prototype purposes, but for consistency, we plan to make them members later before stabilizing the open-ended ranges API.</p></section></section><section class="chapter"><h4 id="how-to-enable-the-operator" data-toc="how-to-enable-the-operator">How to enable the ..&lt; operator</h4><p id="q2xrww_148">To use the <code class="code" id="q2xrww_151">..&lt;</code> operator or to implement that operator convention for your own types, enable the <code class="code" id="q2xrww_152">-language-version 1.8</code> compiler option.</p><p id="q2xrww_149">The new API elements introduced to support the open-ended ranges of the standard types require an opt-in, as usual for an experimental stdlib API: <code class="code" id="q2xrww_153">@OptIn(ExperimentalStdlibApi::class)</code>. Alternatively, you could use the <code class="code" id="q2xrww_154">-opt-in=kotlin.ExperimentalStdlibApi</code> compiler option.</p><p id="q2xrww_150"><a href="https://github.com/kotlin/KEEP/blob/open-ended-ranges/proposals/open-ended-ranges.md" id="q2xrww_155" data-external="true" rel="noopener noreferrer" target="_blank">Read more about the new operator in this KEEP document</a>.</p></section></section><section class="chapter"><h3 id="improved-string-representations-for-singletons-and-sealed-class-hierarchies-with-data-objects" data-toc="improved-string-representations-for-singletons-and-sealed-class-hierarchies-with-data-objects">Improved string representations for singletons and sealed class hierarchies with data objects</h3><aside class="prompt" data-type="warning" data-title="" id="q2xrww_156"><p id="q2xrww_163">Data objects are <a href="components-stability.html#stability-levels-explained" id="q2xrww_164" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a>, and have limited support in the IDE at the moment.</p></aside><p id="q2xrww_157">This release introduces a new type of <code class="code" id="q2xrww_165">object</code> declaration for you to use: <code class="code" id="q2xrww_166">data object</code>. <a href="https://youtrack.jetbrains.com/issue/KT-4107" id="q2xrww_167" data-external="true" rel="noopener noreferrer" target="_blank">Data object</a> behaves conceptually identical to a regular <code class="code" id="q2xrww_168">object</code> declaration but comes with a clean <code class="code" id="q2xrww_169">toString</code> representation out of the box.</p><div class="video-player" id="q2xrww_158"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/ovAqcwFhEGc?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><div class="code-block" data-lang="kotlin">
package org.example
object MyObject
data object MyDataObject

fun main() {
    println(MyObject) // org.example.MyObject@1f32e575
    println(MyDataObject) // MyDataObject
}
</div><p id="q2xrww_160">This makes <code class="code" id="q2xrww_170">data object</code> declarations perfect for sealed class hierarchies, where you may use them alongside <code class="code" id="q2xrww_171">data class</code> declarations. In this snippet, declaring <code class="code" id="q2xrww_172">EndOfFile</code> as a <code class="code" id="q2xrww_173">data object</code> instead of a plain <code class="code" id="q2xrww_174">object</code> means that it will get a pretty <code class="code" id="q2xrww_175">toString</code> without the need to override it manually, maintaining symmetry with the accompanying <code class="code" id="q2xrww_176">data class</code> definitions:</p><div class="code-block" data-lang="kotlin">
sealed class ReadResult {
    data class Number(val value: Int) : ReadResult()
    data class Text(val value: String) : ReadResult()
    data object EndOfFile : ReadResult()
}

fun main() {
    println(ReadResult.Number(1)) // Number(value=1)
    println(ReadResult.Text(&quot;Foo&quot;)) // Text(value=Foo)
    println(ReadResult.EndOfFile) // EndOfFile
}
</div><section class="chapter"><h4 id="how-to-enable-data-objects" data-toc="how-to-enable-data-objects">How to enable data objects</h4><p id="q2xrww_177">To use data object declarations in your code, enable the <code class="code" id="q2xrww_180">-language-version 1.9</code> compiler option. In a Gradle project, you can do so by adding the following to your <code class="code" id="q2xrww_181">build.gradle(.kts)</code>:</p><div class="tabs" id="q2xrww_178" data-group="build-script" data-anchors="[q2xrww_182,q2xrww_183]"><div class="tabs__content" data-gtm="tab" id="q2xrww_182" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
tasks.withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt;().configureEach {
    // ...
    kotlinOptions.languageVersion = &quot;1.9&quot;
}
</div></div><div class="tabs__content" data-gtm="tab" id="q2xrww_183" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
compileKotlin {
    // ...
    kotlinOptions.languageVersion = '1.9'
}
</div></div></div><p id="q2xrww_179">Read more about data objects, and share your feedback on their implementation in the <a href="https://github.com/Kotlin/KEEP/pull/316" id="q2xrww_186" data-external="true" rel="noopener noreferrer" target="_blank">respective KEEP document</a>.</p></section></section><section class="chapter"><h3 id="new-builder-type-inference-restrictions" data-toc="new-builder-type-inference-restrictions">New builder type inference restrictions</h3><p id="q2xrww_187">Kotlin 1.7.20 places some major restrictions on the <a href="using-builders-with-builder-inference.html" id="q2xrww_192" data-tooltip="Kotlin supports builder type inference (or builder inference), which can come in useful when you are working with generic builders. It helps the compiler infer the type arguments of a builder call based on the type information about other calls inside its lambda argument.">use of builder type inference</a> that could affect your code. These restrictions apply to code containing builder lambda functions, where it's impossible to derive the parameter without analyzing the lambda itself. The parameter is used as an argument. Now, the compiler will always show an error for such code and ask you to specify the type explicitly.</p><p id="q2xrww_188">This is a breaking change, but our research shows that these cases are very rare, and the restrictions shouldn't affect your code. If they do, consider the following cases:</p><ul class="list _bullet" id="q2xrww_189"><li class="list__item" id="q2xrww_193"><p id="q2xrww_195">Builder inference with extension that hides members.</p><p id="q2xrww_196">If your code contains an extension function with the same name that will be used during the builder inference, the compiler will show you an error:</p><div class="code-block" data-lang="kotlin">
class Data {
    fun doSmth() {} // 1
}

fun &lt;T&gt; T.doSmth() {} // 2

fun test() {
    buildList {
        this.add(Data())
        this.get(0).doSmth() // Resolves to 2 and leads to error
    }
}
</div><p id="q2xrww_198"></p><p id="q2xrww_199">To fix the code, you should specify the type explicitly:</p><div class="code-block" data-lang="kotlin">
class Data {
    fun doSmth() {} // 1
}

fun &lt;T&gt; T.doSmth() {} // 2

fun test() {
    buildList&lt;Data&gt; { // Type argument!
        this.add(Data())
        this.get(0).doSmth() // Resolves to 1
    }
}
</div></li><li class="list__item" id="q2xrww_194"><p id="q2xrww_201">Builder inference with multiple lambdas and the type arguments are not specified explicitly.</p><p id="q2xrww_202">If there are two or more lambda blocks in builder inference, they affect the type. To prevent an error, the compiler requires you to specify the type:</p><div class="code-block" data-lang="kotlin">
fun &lt;T: Any&gt; buildList(
    first: MutableList&lt;T&gt;.() -&gt; Unit, 
    second: MutableList&lt;T&gt;.() -&gt; Unit
): List&lt;T&gt; {
    val list = mutableListOf&lt;T&gt;()
    list.first()
    list.second()
    return list 
}

fun main() {
    buildList(
        first = { // this: MutableList&lt;String&gt;
            add(&quot;&quot;)
        },
        second = { // this: MutableList&lt;Int&gt; 
            val i: Int = get(0)
            println(i)
        }
    )
}
</div><p id="q2xrww_204"></p><p id="q2xrww_205">To fix the error, you should specify the type explicitly and fix the type mismatch:</p><div class="code-block" data-lang="kotlin">
fun main() {
    buildList&lt;Int&gt;(
        first = { // this: MutableList&lt;Int&gt;
            add(0)
        },
        second = { // this: MutableList&lt;Int&gt;
            val i: Int = get(0)
            println(i)
        }
    )
}
</div></li></ul><p id="q2xrww_190">If you haven't found your case mentioned above, <a href="https://kotl.in/issue" id="q2xrww_207" data-external="true" rel="noopener noreferrer" target="_blank">file an issue</a> to our team.</p><p id="q2xrww_191">See this <a href="https://youtrack.jetbrains.com/issue/KT-53797" id="q2xrww_208" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a> for more information about this builder inference update.</p></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="q2xrww_209">Kotlin 1.7.20 introduces generic inline classes, adds more bytecode optimizations for delegated properties, and supports IR in the kapt stub generating task, making it possible to use all the newest Kotlin features with kapt:</p><ul class="list _bullet" id="q2xrww_210"><li class="list__item" id="q2xrww_214"><p id="q2xrww_217"><a href="#generic-inline-classes" id="q2xrww_218" data-tooltip="Generic inline classes is an Experimental feature. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Generic inline classes</a></p></li><li class="list__item" id="q2xrww_215"><p id="q2xrww_219"><a href="#more-optimized-cases-of-delegated-properties" id="q2xrww_220" data-tooltip="In Kotlin 1.6.0, we optimized the case of delegating to a property by omitting the $delegate field and generating immediate access to the referenced property. In 1.7.20, we've implemented this optimization for more cases. The $delegate field will now be omitted if a delegate is:">More optimized cases of delegated properties</a></p></li><li class="list__item" id="q2xrww_216"><p id="q2xrww_221"><a href="#support-for-the-jvm-ir-backend-in-kapt-stub-generating-task" id="q2xrww_222" data-tooltip="Support for the JVM IR backend in the kapt stub generating task is an Experimental feature. It may be changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes.">Support for the JVM IR backend in kapt stub generating task</a></p></li></ul><section class="chapter"><h3 id="generic-inline-classes" data-toc="generic-inline-classes">Generic inline classes</h3><aside class="prompt" data-type="warning" data-title="" id="q2xrww_223"><p id="q2xrww_231">Generic inline classes is an <a href="components-stability.html#stability-levels-explained" id="q2xrww_232" data-tooltip="Here's a quick guide to these stability levels and their meaning:">Experimental</a> feature. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-52994" id="q2xrww_233" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="q2xrww_224">Kotlin 1.7.20 allows the underlying type of JVM inline classes to be a type parameter. The compiler maps it to <code class="code" id="q2xrww_234">Any?</code> or, generally, to the upper bound of the type parameter.</p><div class="video-player" id="q2xrww_225"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/0JRPA0tt9og?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><p id="q2xrww_226">Consider the following example:</p><div class="code-block" data-lang="kotlin">
@JvmInline
value class UserId&lt;T&gt;(val value: T)

fun compute(s: UserId&lt;String&gt;) {} // Compiler generates fun compute-&lt;hashcode&gt;(s: Any?)
</div><p id="q2xrww_228">The function accepts the inline class as a parameter. The parameter is mapped to the upper bound, not the type argument.</p><p id="q2xrww_229">To enable this feature, use the <code class="code" id="q2xrww_235">-language-version 1.8</code> compiler option.</p><p id="q2xrww_230">We would appreciate your feedback on this feature in <a href="https://youtrack.jetbrains.com/issue/KT-52994" id="q2xrww_236" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="more-optimized-cases-of-delegated-properties" data-toc="more-optimized-cases-of-delegated-properties">More optimized cases of delegated properties</h3><p id="q2xrww_237">In Kotlin 1.6.0, we optimized the case of delegating to a property by omitting the <code class="code" id="q2xrww_241">$delegate</code> field and <a href="whatsnew16.html#optimize-delegated-properties-which-call-get-set-on-the-given-kproperty-instance" id="q2xrww_242" data-tooltip="We optimized the generated JVM bytecode by omitting the $delegate field and generating immediate access to the referenced property.">generating immediate access to the referenced property</a>. In 1.7.20, we've implemented this optimization for more cases. The <code class="code" id="q2xrww_243">$delegate</code> field will now be omitted if a delegate is:</p><ul class="list _bullet" id="q2xrww_238"><li class="list__item" id="q2xrww_244"><p id="q2xrww_247">A named object:</p><div class="code-block" data-lang="kotlin">
object NamedObject {
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String = ...
}

val s: String by NamedObject
</div><p id="q2xrww_249"></p></li><li class="list__item" id="q2xrww_245"><p id="q2xrww_250">A final <code class="code" id="q2xrww_253">val</code> property with a <a href="properties.html#backing-fields" id="q2xrww_254" data-tooltip="In Kotlin, a field is only used as a part of a property to hold its value in memory. Fields cannot be declared directly. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the field identifier:">backing field</a> and a default getter in the same module:</p><div class="code-block" data-lang="kotlin">
val impl: ReadOnlyProperty&lt;Any?, String&gt; = ...

class A {
    val s: String by impl
}
</div><p id="q2xrww_252"></p></li><li class="list__item" id="q2xrww_246"><p id="q2xrww_255">A constant expression, an enum entry, <code class="code" id="q2xrww_258">this</code>, or <code class="code" id="q2xrww_259">null</code>. Here's an example of <code class="code" id="q2xrww_260">this</code>:</p><div class="code-block" data-lang="kotlin">
class A {
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;) ...

    val s by this
}
</div><p id="q2xrww_257"></p></li></ul><p id="q2xrww_239">Learn more about <a href="delegated-properties.html" id="q2xrww_261" data-tooltip="With some common kinds of properties, even though you can implement them manually every time you need them, it is more helpful to implement them once, add them to a library, and reuse them later. For example:">delegated properties</a>.</p><p id="q2xrww_240">We would appreciate your feedback on this feature in <a href="https://youtrack.jetbrains.com/issue/KT-23397" id="q2xrww_262" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="support-for-the-jvm-ir-backend-in-kapt-stub-generating-task" data-toc="support-for-the-jvm-ir-backend-in-kapt-stub-generating-task">Support for the JVM IR backend in kapt stub generating task</h3><aside class="prompt" data-type="warning" data-title="" id="q2xrww_263"><p id="q2xrww_268">Support for the JVM IR backend in the kapt stub generating task is an <a href="components-stability.html" id="q2xrww_269" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a> feature. It may be changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes.</p></aside><p id="q2xrww_264">Before 1.7.20, the kapt stub generating task used the old backend, and <a href="annotations.html#repeatable-annotations" id="q2xrww_270" data-tooltip="Just like in Java, Kotlin has repeatable annotations, which can be applied to a single code element multiple times. To make your annotation repeatable, mark its declaration with the @kotlin.annotation.Repeatable meta-annotation. This will make it repeatable both in Kotlin and Java.…">repeatable annotations</a> didn't work with <a href="kapt.html" id="q2xrww_271" data-tooltip="kapt is in maintenance mode. We are keeping it up-to-date with recent Kotlin and Java releases but have no plans to implement new features. Please use the Kotlin Symbol Processing API (KSP) for annotation processing. See the list of libraries supported by KSP.">kapt</a>. With Kotlin 1.7.20, we've added support for the <a href="whatsnew15.html#stable-jvm-ir-backend" id="q2xrww_272" data-tooltip="The IR-based backend for the Kotlin/JVM compiler is now Stable and enabled by default.">JVM IR backend</a> in the kapt stub generating task. This makes it possible to use all the newest Kotlin features with kapt, including repeatable annotations.</p><p id="q2xrww_265">To use the IR backend in kapt, add the following option to your <code class="code" id="q2xrww_273">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kapt.use.jvm.ir=true
</div><p id="q2xrww_267">We would appreciate your feedback on this feature in <a href="https://youtrack.jetbrains.com/issue/KT-49682" id="q2xrww_274" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="q2xrww_275">Kotlin 1.7.20 comes with the new Kotlin/Native memory manager enabled by default and gives you the option to customize the <code class="code" id="q2xrww_279">Info.plist</code> file:</p><ul class="list _bullet" id="q2xrww_276"><li class="list__item" id="q2xrww_280"><p id="q2xrww_282"><a href="#the-new-kotlin-native-memory-manager-enabled-by-default" id="q2xrww_283" data-tooltip="This release brings further stability and performance improvements to the new memory manager, allowing us to promote the new memory manager to Beta.">The new default memory manager</a></p></li><li class="list__item" id="q2xrww_281"><p id="q2xrww_284"><a href="#customizing-the-info-plist-file" id="q2xrww_285" data-tooltip="When producing a framework, the Kotlin/Native compiler generates the information property list file, Info.plist. Previously, it was cumbersome to customize its contents. With Kotlin 1.7.20, you can directly set the following properties:">Customizing the Info.plist file</a></p></li></ul><section class="chapter"><h3 id="the-new-kotlin-native-memory-manager-enabled-by-default" data-toc="the-new-kotlin-native-memory-manager-enabled-by-default">The new Kotlin/Native memory manager enabled by default</h3><p id="q2xrww_286">This release brings further stability and performance improvements to the new memory manager, allowing us to promote the new memory manager to <a href="components-stability.html" id="q2xrww_293" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Beta</a>.</p><p id="q2xrww_287">The previous memory manager complicated writing concurrent and asynchronous code, including issues with implementing the <code class="code" id="q2xrww_294">kotlinx.coroutines</code> library. This blocked the adoption of Kotlin Multiplatform Mobile because concurrency limitations created problems with sharing Kotlin code between iOS and Android platforms. The new memory manager finally paves the way to <a href="https://blog.jetbrains.com/kotlin/2022/05/kotlin-multiplatform-mobile-beta-roadmap-update/" id="q2xrww_295" data-external="true" rel="noopener noreferrer" target="_blank">promote Kotlin Multiplatform Mobile to Beta</a>.</p><p id="q2xrww_288">The new memory manager also supports the compiler cache that makes compilation times comparable to previous releases. For more on the benefits of the new memory manager, see our original <a href="https://blog.jetbrains.com/kotlin/2021/08/try-the-new-kotlin-native-memory-manager-development-preview/" id="q2xrww_296" data-external="true" rel="noopener noreferrer" target="_blank">blog post</a> for the preview version. You can find more technical details in the <a href="native-memory-manager.html" id="q2xrww_297" data-tooltip="Kotlin/Native uses a modern memory manager that is similar to the JVM, Go, and other mainstream technologies, including the following features:">documentation</a>.</p><section class="chapter"><h4 id="configuration-and-setup" data-toc="configuration-and-setup">Configuration and setup</h4><p id="q2xrww_298">Starting with Kotlin 1.7.20, the new memory manager is the default. Not much additional setup is required.</p><p id="q2xrww_299">If you've already turned it on manually, you can remove the <code class="code" id="q2xrww_301">kotlin.native.binary.memoryModel=experimental</code> option from your <code class="code" id="q2xrww_302">gradle.properties</code> or <code class="code" id="q2xrww_303">binaryOptions[&quot;memoryModel&quot;] = &quot;experimental&quot;</code> from the <code class="code" id="q2xrww_304">build.gradle(.kts)</code> file.</p><p id="q2xrww_300">If necessary, you can switch back to the legacy memory manager with the <code class="code" id="q2xrww_305">kotlin.native.binary.memoryModel=strict</code> option in your <code class="code" id="q2xrww_306">gradle.properties</code>. However, compiler cache support is no longer available for the legacy memory manager, so compilation times might worsen.</p></section><section class="chapter"><h4 id="freezing" data-toc="freezing">Freezing</h4><p id="q2xrww_307">In the new memory manager, freezing is deprecated. Don't use it unless you need your code to work with the legacy manager (where freezing is still required). This may be helpful for library authors that need to maintain support for the legacy memory manager or developers who want to have a fallback if they encounter issues with the new memory manager.</p><p id="q2xrww_308">In such cases, you can temporarily support code for both new and legacy memory managers. To ignore deprecation warnings, do one of the following:</p><ul class="list _bullet" id="q2xrww_309"><li class="list__item" id="q2xrww_310"><p id="q2xrww_313">Annotate usages of the deprecated API with <code class="code" id="q2xrww_314">@OptIn(FreezingIsDeprecated::class)</code>.</p></li><li class="list__item" id="q2xrww_311"><p id="q2xrww_315">Apply <code class="code" id="q2xrww_316">languageSettings.optIn(&quot;kotlin.native.FreezingIsDeprecated&quot;)</code> to all the Kotlin source sets in Gradle.</p></li><li class="list__item" id="q2xrww_312"><p id="q2xrww_317">Pass the compiler flag <code class="code" id="q2xrww_318">-opt-in=kotlin.native.FreezingIsDeprecated</code>.</p></li></ul></section><section class="chapter"><h4 id="calling-kotlin-suspending-functions-from-swift-objective-c" data-toc="calling-kotlin-suspending-functions-from-swift-objective-c">Calling Kotlin suspending functions from Swift/Objective-C</h4><p id="q2xrww_319">The new memory manager still restricts calling Kotlin <code class="code" id="q2xrww_325">suspend</code> functions from Swift and Objective-C from threads other than the main one, but you can lift it with a new Gradle option.</p><p id="q2xrww_320">This restriction was originally introduced in the legacy memory manager due to cases where the code dispatched a continuation to be resumed on the original thread. If this thread didn't have a supported event loop, the task would never run, and the coroutine would never be resumed.</p><p id="q2xrww_321">In certain cases, this restriction is no longer required, but a check of all the necessary conditions can't be easily implemented. Because of this, we decided to keep it in the new memory manager while introducing an option for you to disable it. For this, add the following option to your <code class="code" id="q2xrww_326">gradle.properties</code>:</p><div class="code-block" data-lang="none">
kotlin.native.binary.objcExportSuspendFunctionLaunchThreadRestriction=none
</div><aside class="prompt" data-type="warning" data-title="" id="q2xrww_323"><p id="q2xrww_327">Do not add this option if you use the <code class="code" id="q2xrww_328">native-mt</code> version of <code class="code" id="q2xrww_329">kotlinx.coroutines</code> or other libraries that have the same &quot;dispatch to the original thread&quot; approach.</p></aside><p id="q2xrww_324">The Kotlin team is very grateful to <a href="https://github.com/ahmedre" id="q2xrww_330" data-external="true" rel="noopener noreferrer" target="_blank">Ahmed El-Helw</a> for implementing this option.</p></section><section class="chapter"><h4 id="leave-your-feedback" data-toc="leave-your-feedback">Leave your feedback</h4><p id="q2xrww_331">This is a significant change to our ecosystem. We would appreciate your feedback to help make it even better.</p><p id="q2xrww_332">Try the new memory manager on your projects and <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="q2xrww_333" data-external="true" rel="noopener noreferrer" target="_blank">share feedback in our issue tracker, YouTrack</a>.</p></section></section><section class="chapter"><h3 id="customizing-the-info-plist-file" data-toc="customizing-the-info-plist-file">Customizing the Info.plist file</h3><p id="q2xrww_334">When producing a framework, the Kotlin/Native compiler generates the information property list file, <code class="code" id="q2xrww_338">Info.plist</code>. Previously, it was cumbersome to customize its contents. With Kotlin 1.7.20, you can directly set the following properties:</p><div class="table-wrapper"><table class="wide" id="q2xrww_335"><thead><tr class="ijRowHead" id="q2xrww_339"><th id="q2xrww_343"><p>Property</p></th><th id="q2xrww_344"><p>Binary option</p></th></tr></thead><tbody><tr id="q2xrww_340"><td id="q2xrww_345"><p><code class="code" id="q2xrww_347">CFBundleIdentifier</code></p></td><td id="q2xrww_346"><p><code class="code" id="q2xrww_348">bundleId</code></p></td></tr><tr id="q2xrww_341"><td id="q2xrww_349"><p><code class="code" id="q2xrww_351">CFBundleShortVersionString</code></p></td><td id="q2xrww_350"><p><code class="code" id="q2xrww_352">bundleShortVersionString</code></p></td></tr><tr id="q2xrww_342"><td id="q2xrww_353"><p><code class="code" id="q2xrww_355">CFBundleVersion</code></p></td><td id="q2xrww_354"><p><code class="code" id="q2xrww_356">bundleVersion</code></p></td></tr></tbody></table></div><p id="q2xrww_336">To do that, use the corresponding binary option. Pass the <code class="code" id="q2xrww_357">-Xbinary=$option=$value</code> compiler flag or set the <code class="code" id="q2xrww_358">binaryOption(option, value)</code> Gradle DSL for the necessary framework.</p><p id="q2xrww_337">The Kotlin team is very grateful to Mads Ager for implementing this feature.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="q2xrww_359">Kotlin/JS has received some enhancements that improve the developer experience and boost performance:</p><ul class="list _bullet" id="q2xrww_360"><li class="list__item" id="q2xrww_361"><p id="q2xrww_364">Klib generation is faster in both incremental and clean builds, thanks to efficiency improvements for the loading of dependencies.</p></li><li class="list__item" id="q2xrww_362"><p id="q2xrww_365"><a href="js-ir-compiler.html#incremental-compilation-for-development-binaries" id="q2xrww_366" data-tooltip="The JS IR compiler provides the incremental compilation mode for development binaries that speeds up the development process. In this mode, the compiler caches the results of compileDevelopmentExecutableKotlinJs Gradle task on the module level. It uses the cached compilation results…">Incremental compilation for development binaries</a> has been reworked, resulting in major improvements in clean build scenarios, faster incremental builds, and stability fixes.</p></li><li class="list__item" id="q2xrww_363"><p id="q2xrww_367">We've improved <code class="code" id="q2xrww_368">.d.ts</code> generation for nested objects, sealed classes, and optional parameters in constructors.</p></li></ul></section><section class="chapter"><h2 id="gradle" data-toc="gradle">Gradle</h2><p id="q2xrww_369">The updates for the Kotlin Gradle plugin are focused on compatibility with the new Gradle features and the latest Gradle versions.</p><p id="q2xrww_370">Kotlin 1.7.20 contains changes to support Gradle 7.1. Deprecated methods and properties were removed or replaced, reducing the number of deprecation warnings produced by the Kotlin Gradle plugin and unblocking future support for Gradle 8.0.</p><p id="q2xrww_371">There are, however, some potentially breaking changes that may need your attention:</p><section class="chapter"><h3 id="target-configuration" data-toc="target-configuration">Target configuration</h3><ul class="list _bullet" id="q2xrww_375"><li class="list__item" id="q2xrww_376"><p id="q2xrww_379"><code class="code" id="q2xrww_380">org.jetbrains.kotlin.gradle.dsl.SingleTargetExtension</code> now has a generic parameter, <code class="code" id="q2xrww_381">SingleTargetExtension&lt;T : KotlinTarget&gt;</code>.</p></li><li class="list__item" id="q2xrww_377"><p id="q2xrww_382">The <code class="code" id="q2xrww_383">kotlin.targets.fromPreset()</code> convention has been deprecated. Instead, you can still use <code class="code" id="q2xrww_384">kotlin.targets { fromPreset() }</code>, but we recommend <a href="multiplatform-discover-project.html#targets" id="q2xrww_385" data-tooltip="Targets define the platforms to which Kotlin compiles the common code. These could be, for example, the JVM, JS, Android, iOS, or Linux. The previous example compiled the common code to the JVM and native targets.">setting up targets explicitly</a>.</p></li><li class="list__item" id="q2xrww_378"><p id="q2xrww_386">Target accessors auto-generated by Gradle are no longer available inside the <code class="code" id="q2xrww_388">kotlin.targets { }</code> block. Please use the <code class="code" id="q2xrww_389">findByName(&quot;targetName&quot;)</code> method instead.</p><p id="q2xrww_387">Note that such accessors are still available in the case of <code class="code" id="q2xrww_390">kotlin.targets</code>, for example, <code class="code" id="q2xrww_391">kotlin.targets.linuxX64</code>.</p></li></ul></section><section class="chapter"><h3 id="source-directories-configuration" data-toc="source-directories-configuration">Source directories configuration</h3><p id="q2xrww_392">The Kotlin Gradle plugin now adds Kotlin <code class="code" id="q2xrww_397">SourceDirectorySet</code> as a <code class="code" id="q2xrww_398">kotlin</code> extension to Java's <code class="code" id="q2xrww_399">SourceSet</code> group. This makes it possible to configure source directories in the <code class="code" id="q2xrww_400">build.gradle.kts</code> file similarly to how they are configured in <a href="https://docs.gradle.org/7.1/release-notes.html#easier-source-set-configuration-in-kotlin-dsl" id="q2xrww_401" data-external="true" rel="noopener noreferrer" target="_blank">Java, Groovy, and Scala</a>:</p><div class="code-block" data-lang="kotlin">
sourceSets {
    main {
        kotlin {
            java.setSrcDirs(listOf(&quot;src/java&quot;))
            kotlin.setSrcDirs(listOf(&quot;src/kotlin&quot;))
        }
    }
}
</div><p id="q2xrww_394">You no longer need to use a deprecated Gradle convention and specify the source directories for Kotlin.</p><p id="q2xrww_395">Remember that you can also use the <code class="code" id="q2xrww_402">kotlin</code> extension to access <code class="code" id="q2xrww_403">KotlinSourceSet</code>:</p><div class="code-block" data-lang="kotlin">
kotlin {
    sourceSets {
        main {
        // ...
        }
    }
}
</div></section><section class="chapter"><h3 id="new-method-for-jvm-toolchain-configuration" data-toc="new-method-for-jvm-toolchain-configuration">New method for JVM toolchain configuration</h3><p id="q2xrww_404">This release provides a new <code class="code" id="q2xrww_408">jvmToolchain()</code> method for enabling the <a href="gradle-configure-project.html#gradle-java-toolchains-support" id="q2xrww_409" data-tooltip="A warning for Android users. To use Gradle toolchain support, use the Android Gradle plugin (AGP) version 8.1.0-alpha09 or higher.">JVM toolchain feature</a>. If you don't need any additional <a href="https://docs.gradle.org/current/javadoc/org/gradle/jvm/toolchain/JavaToolchainSpec.html" id="q2xrww_410" data-external="true" rel="noopener noreferrer" target="_blank">configuration fields</a>, such as <code class="code" id="q2xrww_411">implementation</code> or <code class="code" id="q2xrww_412">vendor</code>, you can use this method from the Kotlin extension:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvmToolchain(17)
}
</div><p id="q2xrww_406">This simplifies the Kotlin project setup process without any additional configuration. Before this release, you could specify the JDK version only in the following way:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}
</div></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><p id="q2xrww_413">Kotlin 1.7.20 offers new <a href="extensions.html#extension-functions" id="q2xrww_420" data-tooltip="To declare an extension function, prefix its name with a receiver type, which refers to the type being extended. The following adds a swap function to MutableList&lt;Int&gt;:">extension functions</a> for the <code class="code" id="q2xrww_421">java.nio.file.Path</code> class, which allows you to walk through a file tree:</p><ul class="list _bullet" id="q2xrww_414"><li class="list__item" id="q2xrww_422"><p id="q2xrww_427"><code class="code" id="q2xrww_428">walk()</code> lazily traverses the file tree rooted at the specified path.</p></li><li class="list__item" id="q2xrww_423"><p id="q2xrww_429"><code class="code" id="q2xrww_430">fileVisitor()</code> makes it possible to create a <code class="code" id="q2xrww_431">FileVisitor</code> separately. <code class="code" id="q2xrww_432">FileVisitor</code> defines actions on directories and files when traversing them.</p></li><li class="list__item" id="q2xrww_424"><p id="q2xrww_433"><code class="code" id="q2xrww_434">visitFileTree(fileVisitor: FileVisitor, ...)</code> consumes a ready <code class="code" id="q2xrww_435">FileVisitor</code> and uses <code class="code" id="q2xrww_436">java.nio.file.Files.walkFileTree()</code> under the hood.</p></li><li class="list__item" id="q2xrww_425"><p id="q2xrww_437"><code class="code" id="q2xrww_438">visitFileTree(..., builderAction: FileVisitorBuilder.() -&gt; Unit)</code> creates a <code class="code" id="q2xrww_439">FileVisitor</code> with the <code class="code" id="q2xrww_440">builderAction</code> and calls the <code class="code" id="q2xrww_441">visitFileTree(fileVisitor, ...)</code> function.</p></li><li class="list__item" id="q2xrww_426"><p id="q2xrww_442"><code class="code" id="q2xrww_443">FileVisitResult</code>, return type of <code class="code" id="q2xrww_444">FileVisitor</code>, has the <code class="code" id="q2xrww_445">CONTINUE</code> default value that continues the processing of the file.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="q2xrww_415"><p id="q2xrww_446">The new extension functions for <code class="code" id="q2xrww_447">java.nio.file.Path</code> are <a href="components-stability.html" id="q2xrww_448" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. They may be changed at any time. Opt-in is required (see details below), and you should use them only for evaluation purposes.</p></aside><p id="q2xrww_416">Here are some things you can do with these new extension functions:</p><ul class="list _bullet" id="q2xrww_417"><li class="list__item" id="q2xrww_449"><p id="q2xrww_452">Explicitly create a <code class="code" id="q2xrww_454">FileVisitor</code> and then use:</p><div class="code-block" data-lang="kotlin">
val cleanVisitor = fileVisitor {
    onPreVisitDirectory { directory, attributes -&gt;
        // Some logic on visiting directories
        FileVisitResult.CONTINUE
    }

    onVisitFile { file, attributes -&gt;
        // Some logic on visiting files
        FileVisitResult.CONTINUE
    }
}

// Some logic may go here

projectDirectory.visitFileTree(cleanVisitor)
</div></li><li class="list__item" id="q2xrww_450"><p id="q2xrww_455">Create a <code class="code" id="q2xrww_457">FileVisitor</code> with the <code class="code" id="q2xrww_458">builderAction</code> and use it immediately:</p><div class="code-block" data-lang="kotlin">
projectDirectory.visitFileTree {
// Definition of the builderAction:
    onPreVisitDirectory { directory, attributes -&gt;
        // Some logic on visiting directories
        FileVisitResult.CONTINUE
    }

    onVisitFile { file, attributes -&gt;
        // Some logic on visiting files
        FileVisitResult.CONTINUE
    }
}
</div></li><li class="list__item" id="q2xrww_451"><p id="q2xrww_459">Traverse a file tree rooted at the specified path with the <code class="code" id="q2xrww_461">walk()</code> function:</p><div class="code-block" data-lang="kotlin">
@OptIn(kotlin.io.path.ExperimentalPathApi::class)
fun traverseFileTree() {
    val cleanVisitor = fileVisitor {
        onPreVisitDirectory { directory, _ -&gt;
            if (directory.name == &quot;build&quot;) {
                directory.toFile().deleteRecursively()
                FileVisitResult.SKIP_SUBTREE
            } else {
                FileVisitResult.CONTINUE
            }
        }

        onVisitFile { file, _ -&gt;
            if (file.extension == &quot;class&quot;) {
                file.deleteExisting()
            }
            FileVisitResult.CONTINUE
        }
    }

    val rootDirectory = createTempDirectory(&quot;Project&quot;)

    rootDirectory.resolve(&quot;src&quot;).let { srcDirectory -&gt;
        srcDirectory.createDirectory()
        srcDirectory.resolve(&quot;A.kt&quot;).createFile()
        srcDirectory.resolve(&quot;A.class&quot;).createFile()
    }

    rootDirectory.resolve(&quot;build&quot;).let { buildDirectory -&gt;
        buildDirectory.createDirectory()
        buildDirectory.resolve(&quot;Project.jar&quot;).createFile()
    }


// Use walk function:
    val directoryStructure = rootDirectory.walk(PathWalkOption.INCLUDE_DIRECTORIES)
        .map { it.relativeTo(rootDirectory).toString() }
        .toList().sorted()
    assertPrints(directoryStructure, &quot;[, build, build/Project.jar, src, src/A.class, src/A.kt]&quot;)

    rootDirectory.visitFileTree(cleanVisitor)

    val directoryStructureAfterClean = rootDirectory.walk(PathWalkOption.INCLUDE_DIRECTORIES)
        .map { it.relativeTo(rootDirectory).toString() }
        .toList().sorted()
    assertPrints(directoryStructureAfterClean, &quot;[, src, src/A.kt]&quot;)
//sampleEnd
}
</div></li></ul><p id="q2xrww_418">As is usual for an experimental API, the new extensions require an opt-in: <code class="code" id="q2xrww_462">@OptIn(kotlin.io.path.ExperimentalPathApi::class)</code> or <code class="code" id="q2xrww_463">@kotlin.io.path.ExperimentalPathApi</code>. Alternatively, you can use a compiler option: <code class="code" id="q2xrww_464">-opt-in=kotlin.io.path.ExperimentalPathApi</code>.</p><p id="q2xrww_419">We would appreciate your feedback on the <a href="https://youtrack.jetbrains.com/issue/KT-52909" id="q2xrww_465" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="q2xrww_467">walk()</code> function</a> and the <a href="https://youtrack.jetbrains.com/issue/KT-52910" id="q2xrww_466" data-external="true" rel="noopener noreferrer" target="_blank">visit extension functions</a> in YouTrack.</p></section><section class="chapter"><h2 id="documentation-updates" data-toc="documentation-updates">Documentation updates</h2><p id="q2xrww_468">Since the previous release, the Kotlin documentation has received some notable changes:</p><section class="chapter"><h3 id="revamped-and-improved-pages" data-toc="revamped-and-improved-pages">Revamped and improved pages</h3><ul class="list _bullet" id="q2xrww_473"><li class="list__item" id="q2xrww_474"><p id="q2xrww_476"><a href="basic-types.html" id="q2xrww_477" data-tooltip="In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable. While certain types have an optimized internal representation as primitive values at runtime (such as numbers, characters, booleans and others), they appear and behave…">Basic types overview</a> &ndash; learn about the basic types used in Kotlin: numbers, Booleans, characters, strings, arrays, and unsigned integer numbers.</p></li><li class="list__item" id="q2xrww_475"><p id="q2xrww_478"><a href="kotlin-ide.html" id="q2xrww_479" data-tooltip="JetBrains provides the official Kotlin support for the following IDEs and code editors: IntelliJ IDEA and Android Studio.">IDEs for Kotlin development</a> &ndash; see the list of IDEs with official Kotlin support and tools that have community-supported plugins.</p></li></ul></section><section class="chapter"><h3 id="new-articles-in-the-kotlin-multiplatform-journal" data-toc="new-articles-in-the-kotlin-multiplatform-journal">New articles in the Kotlin Multiplatform journal</h3><ul class="list _bullet" id="q2xrww_480"><li class="list__item" id="q2xrww_481"><p id="q2xrww_483"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/native-and-cross-platform.html" id="q2xrww_484" data-external="true" rel="noopener noreferrer" target="_blank">Native and cross-platform app development: how to choose?</a> &ndash; check out our overview and advantages of cross-platform app development and the native approach.</p></li><li class="list__item" id="q2xrww_482"><p id="q2xrww_485"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/cross-platform-frameworks.html" id="q2xrww_486" data-external="true" rel="noopener noreferrer" target="_blank">The six best cross-platform app development frameworks</a> &ndash; read about the key aspects to help you choose the right framework for your cross-platform project.</p></li></ul></section><section class="chapter"><h3 id="new-and-updated-tutorials" data-toc="new-and-updated-tutorials">New and updated tutorials</h3><ul class="list _bullet" id="q2xrww_487"><li class="list__item" id="q2xrww_488"><p id="q2xrww_490"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-create-first-app.html" id="q2xrww_491" data-external="true" rel="noopener noreferrer" target="_blank">Get started with Kotlin Multiplatform</a> &ndash; learn about cross-platform mobile development with Kotlin and create an app that works on both Android and iOS.</p></li><li class="list__item" id="q2xrww_489"><p id="q2xrww_492"><a href="js-react.html" id="q2xrww_493" data-tooltip="This tutorial will teach you how to build a browser application with Kotlin/JS and the React framework. You will:">Build a web application with React and Kotlin/JS</a> &ndash; create a browser app exploring Kotlin's DSLs and features of a typical React program.</p></li></ul></section><section class="chapter"><h3 id="changes-in-release-documentation" data-toc="changes-in-release-documentation">Changes in release documentation</h3><p id="q2xrww_494">We no longer provide a list of recommended kotlinx libraries for each release. This list included only the versions recommended and tested with Kotlin itself. It didn't take into account that some libraries depend on each other and require a special kotlinx version, which may differ from the recommended Kotlin version.</p><p id="q2xrww_495">We're working on finding a way to provide information on how libraries interrelate and depend on each other so that it will be clear which kotlinx library version you should use when you upgrade the Kotlin version in your project.</p></section></section><section class="chapter"><h2 id="install-kotlin-1-7-20" data-toc="install-kotlin-1-7-20">Install Kotlin 1.7.20</h2><p id="q2xrww_496"><a href="https://www.jetbrains.com/idea/download/" id="q2xrww_500" data-external="true" rel="noopener noreferrer" target="_blank">IntelliJ IDEA</a> 2021.3, 2022.1, and 2022.2 automatically suggest updating the Kotlin plugin to 1.7.20.</p><aside class="prompt" data-type="note" data-title="" id="q2xrww_497"><p id="q2xrww_501">For Android Studio Dolphin (213), Electric Eel (221), and Flamingo (222), the Kotlin plugin 1.7.20 will be delivered with upcoming Android Studios updates.</p></aside><p id="q2xrww_498">The new command-line compiler is available for download on the <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.7.20" id="q2xrww_502" data-external="true" rel="noopener noreferrer" target="_blank">GitHub release page</a>.</p><section class="chapter"><h3 id="compatibility-guide-for-kotlin-1-7-20" data-toc="compatibility-guide-for-kotlin-1-7-20">Compatibility guide for Kotlin 1.7.20</h3><p id="q2xrww_503">Although Kotlin 1.7.20 is an incremental release, there are still incompatible changes we had to make to limit spread of the issues introduced in Kotlin 1.7.0.</p><p id="q2xrww_504">Find the detailed list of such changes in the <a href="compatibility-guide-1720.html" id="q2xrww_505" data-tooltip="Keeping the Language Modern and Comfortable Updates are among the fundamental principles in Kotlin Language Design. The former says that constructs which obstruct language evolution should be removed, and the latter says that this removal should be well-communicated beforehand to…">Compatibility guide for Kotlin 1.7.20</a>.</p></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew18.html" class="navigation-links__prev">What's new in Kotlin 1.8.0</a><a href="whatsnew17.html" class="navigation-links__next">What's new in Kotlin 1.7.0</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>