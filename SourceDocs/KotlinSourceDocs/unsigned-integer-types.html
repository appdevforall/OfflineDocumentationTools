<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:01.582441253"><title>Unsigned integer types | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"unsigned-arrays-and-ranges","level":0,"title":"Unsigned arrays and ranges","anchor":"#unsigned-arrays-and-ranges"},{"id":"unsigned-integers-literals","level":0,"title":"Unsigned integers literals","anchor":"#unsigned-integers-literals"},{"id":"use-cases","level":0,"title":"Use cases","anchor":"#use-cases"},{"id":"non-goals","level":1,"title":"Non-goals","anchor":"#non-goals"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Unsigned integer types | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/unsigned-integer-types.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Unsigned integer types | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/unsigned-integer-types.html#webpage",
    "url": "writerside-documentation/unsigned-integer-types.html",
    "name": "Unsigned integer types | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="unsigned-integer-types" data-main-title="Unsigned integer types" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts///Types///Basic types"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="unsigned-integer-types" id="unsigned-integer-types.md">Unsigned integer types</h1><p id="z7qlpcj_2">In addition to <a href="numbers.html#integer-types" id="z7qlpcj_9" data-tooltip="Kotlin provides a set of built-in types that represent numbers.For integer numbers, there are four types with different sizes and value ranges:">integer types</a>, Kotlin provides the following types for unsigned integer numbers:</p><div class="table-wrapper"><table class="wide" id="z7qlpcj_3"><thead><tr class="ijRowHead" id="z7qlpcj_10"><th id="z7qlpcj_15"><p>Type</p></th><th id="z7qlpcj_16"><p>Size (bits)</p></th><th id="z7qlpcj_17"><p>Min value</p></th><th id="z7qlpcj_18"><p>Max value</p></th></tr></thead><tbody><tr id="z7qlpcj_11"><td id="z7qlpcj_19"><p><code class="code" id="z7qlpcj_23">UByte</code></p></td><td id="z7qlpcj_20"><p>8</p></td><td id="z7qlpcj_21"><p>0</p></td><td id="z7qlpcj_22"><p>255</p></td></tr><tr id="z7qlpcj_12"><td id="z7qlpcj_24"><p><code class="code" id="z7qlpcj_28">UShort</code></p></td><td id="z7qlpcj_25"><p>16</p></td><td id="z7qlpcj_26"><p>0</p></td><td id="z7qlpcj_27"><p>65,535</p></td></tr><tr id="z7qlpcj_13"><td id="z7qlpcj_29"><p><code class="code" id="z7qlpcj_33">UInt</code></p></td><td id="z7qlpcj_30"><p>32</p></td><td id="z7qlpcj_31"><p>0</p></td><td id="z7qlpcj_32"><p>4,294,967,295 (2<sup class="superscript" id="z7qlpcj_34">32</sup> - 1)</p></td></tr><tr id="z7qlpcj_14"><td id="z7qlpcj_35"><p><code class="code" id="z7qlpcj_39">ULong</code></p></td><td id="z7qlpcj_36"><p>64</p></td><td id="z7qlpcj_37"><p>0</p></td><td id="z7qlpcj_38"><p>18,446,744,073,709,551,615 (2<sup class="superscript" id="z7qlpcj_40">64</sup> - 1)</p></td></tr></tbody></table></div><p id="z7qlpcj_4">Unsigned types support most of the operations of their signed counterparts.</p><aside class="prompt" data-type="note" data-title="" id="z7qlpcj_5"><p id="z7qlpcj_41">Unsigned numbers are implemented as <a href="inline-classes.html" id="z7qlpcj_42" data-tooltip="Sometimes it is useful to wrap a value in a class to create a more domain-specific type. However, it introduces runtime overhead due to additional heap allocations. Moreover, if the wrapped type is primitive, the performance hit is significant, because primitive types are usually…">inline classes</a> with a single storage property that contains the corresponding signed counterpart type of the same width. If you want to convert between unsigned and signed integer types, make sure you update your code so that any function calls and operations support the new type.</p></aside><section class="chapter"><h2 id="unsigned-arrays-and-ranges" data-toc="unsigned-arrays-and-ranges">Unsigned arrays and ranges</h2><aside class="prompt" data-type="warning" data-title="" id="z7qlpcj_43"><p id="z7qlpcj_49">Unsigned arrays and operations on them are in <a href="components-stability.html" id="z7qlpcj_50" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Beta</a>. They can be changed incompatibly at any time. Opt-in is required (see the details below).</p></aside><p id="z7qlpcj_44">Same as for primitives, each unsigned type has a corresponding type that represents arrays of that type:</p><ul class="list _bullet" id="z7qlpcj_45"><li class="list__item" id="z7qlpcj_51"><p id="z7qlpcj_55"><code class="code" id="z7qlpcj_56">UByteArray</code>: an array of unsigned bytes.</p></li><li class="list__item" id="z7qlpcj_52"><p id="z7qlpcj_57"><code class="code" id="z7qlpcj_58">UShortArray</code>: an array of unsigned shorts.</p></li><li class="list__item" id="z7qlpcj_53"><p id="z7qlpcj_59"><code class="code" id="z7qlpcj_60">UIntArray</code>: an array of unsigned ints.</p></li><li class="list__item" id="z7qlpcj_54"><p id="z7qlpcj_61"><code class="code" id="z7qlpcj_62">ULongArray</code>: an array of unsigned longs.</p></li></ul><p id="z7qlpcj_46">Same as for signed integer arrays, they provide a similar API to the <code class="code" id="z7qlpcj_63">Array</code> class without boxing overhead.</p><p id="z7qlpcj_47">When you use unsigned arrays, you receive a warning that indicates that this feature is not stable yet. To remove the warning, opt-in with the <code class="code" id="z7qlpcj_64">@ExperimentalUnsignedTypes</code> annotation. It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but keep in mind that unsigned arrays are not a stable feature, so an API that uses them can be broken by changes in the language. <a href="opt-in-requirements.html" id="z7qlpcj_65" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">Learn more about opt-in requirements</a>.</p><p id="z7qlpcj_48"><a href="ranges.html" id="z7qlpcj_66" data-tooltip="Ranges and progressions define sequences of values in Kotlin, supporting range operators, iteration, custom step values, and arithmetic progressions.">Ranges and progressions</a> are supported for <code class="code" id="z7qlpcj_67">UInt</code> and <code class="code" id="z7qlpcj_68">ULong</code> by classes <code class="code" id="z7qlpcj_69">UIntRange</code>, <code class="code" id="z7qlpcj_70">UIntProgression</code>, <code class="code" id="z7qlpcj_71">ULongRange</code>, and <code class="code" id="z7qlpcj_72">ULongProgression</code>. Together with the unsigned integer types, these classes are stable.</p></section><section class="chapter"><h2 id="unsigned-integers-literals" data-toc="unsigned-integers-literals">Unsigned integers literals</h2><p id="z7qlpcj_73">To make unsigned integers easier to use, you can append a suffix to an integer literal<br> indicating a specific unsigned type (similarly to <code class="code" id="z7qlpcj_76">F</code> for <code class="code" id="z7qlpcj_77">Float</code> or <code class="code" id="z7qlpcj_78">L</code> for <code class="code" id="z7qlpcj_79">Long</code>):</p><ul class="list _bullet" id="z7qlpcj_74"><li class="list__item" id="z7qlpcj_80"><p id="z7qlpcj_82"><code class="code" id="z7qlpcj_84">u</code> and <code class="code" id="z7qlpcj_85">U</code> letters signify unsigned literals without specifying the exact type. If no expected type is provided, the compiler uses <code class="code" id="z7qlpcj_86">UInt</code> or <code class="code" id="z7qlpcj_87">ULong</code> depending on the size of the literal:</p><div class="code-block" data-lang="kotlin">
val b: UByte = 1u  // UByte, expected type provided
val s: UShort = 1u // UShort, expected type provided
val l: ULong = 1u  // ULong, expected type provided

val a1 = 42u // UInt: no expected type provided, constant fits in UInt
val a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt
</div></li><li class="list__item" id="z7qlpcj_81"><p id="z7qlpcj_88"><code class="code" id="z7qlpcj_90">uL</code> and <code class="code" id="z7qlpcj_91">UL</code> explicitly specify that literal should be an unsigned long:</p><div class="code-block" data-lang="kotlin">
val a = 1UL // ULong, even though no expected type provided and the constant fits into UInt
</div></li></ul></section><section class="chapter"><h2 id="use-cases" data-toc="use-cases">Use cases</h2><p id="z7qlpcj_92">The main use case of unsigned numbers is utilizing the full bit range of an integer to represent positive values. <br> For example, to represent hexadecimal constants that do not fit in signed types such as color in 32-bit <code class="code" id="z7qlpcj_99">AARRGGBB</code> format:</p><div class="code-block" data-lang="kotlin">
data class Color(val representation: UInt)

val yellow = Color(0xFFCC00CCu)
</div><p id="z7qlpcj_94">You can use unsigned numbers to initialize byte arrays without explicit <code class="code" id="z7qlpcj_100">toByte()</code> literal casts:</p><div class="code-block" data-lang="kotlin">
val byteOrderMarkUtf8 = ubyteArrayOf(0xEFu, 0xBBu, 0xBFu)
</div><p id="z7qlpcj_96">Another use case is interoperability with native APIs. Kotlin allows representing native declarations that contain unsigned types in the signature. The mapping won't substitute unsigned integers with signed ones keeping the semantics unaltered.</p><section class="chapter"><h3 id="non-goals" data-toc="non-goals">Non-goals</h3><p id="z7qlpcj_101">While unsigned integers can only represent positive numbers and zero, it's not a goal to use them where application domain requires non-negative integers. For example, as a type of collection size or collection index value.</p><p id="z7qlpcj_102">There are a couple of reasons:</p><ul class="list _bullet" id="z7qlpcj_103"><li class="list__item" id="z7qlpcj_104"><p id="z7qlpcj_106">Using signed integers can help to detect accidental overflows and signal error conditions, such as <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/last-index.html" id="z7qlpcj_107" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z7qlpcj_108">List.lastIndex</code></a> being -1 for an empty list.</p></li><li class="list__item" id="z7qlpcj_105"><p id="z7qlpcj_109">Unsigned integers cannot be treated as a range-limited version of signed ones because their range of values is not a subset of the signed integers range. Neither signed, nor unsigned integers are subtypes of each other.</p></li></ul></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="numbers.html" class="navigation-links__prev">Numbers</a><a href="booleans.html" class="navigation-links__next">Booleans</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>