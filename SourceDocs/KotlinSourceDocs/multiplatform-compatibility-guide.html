<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:00.965000112"><title>Compatibility guide for Kotlin Multiplatform | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"version-compatibility","level":0,"title":"Version compatibility","anchor":"#version-compatibility"},{"id":"kotlin-2-0-0-and-later","level":0,"title":"Kotlin 2.0.0 and later","anchor":"#kotlin-2-0-0-and-later"},{"id":"kotlin-1-9-0-1-9-25","level":0,"title":"Kotlin 1.9.0−1.9.25","anchor":"#kotlin-1-9-0-1-9-25"},{"id":"kotlin-1-7-0-1-8-22","level":0,"title":"Kotlin 1.7.0−1.8.22","anchor":"#kotlin-1-7-0-1-8-22"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Compatibility guide for Kotlin Multiplatform | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/multiplatform-compatibility-guide.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Compatibility guide for Kotlin Multiplatform | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/multiplatform-compatibility-guide.html#webpage",
    "url": "writerside-documentation/multiplatform-compatibility-guide.html",
    "name": "Compatibility guide for Kotlin Multiplatform | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="multiplatform-compatibility-guide" data-main-title="Compatibility guide for Kotlin Multiplatform" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Multiplatform development///Reference"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="multiplatform-compatibility-guide" id="multiplatform-compatibility-guide.md">Compatibility guide for Kotlin Multiplatform</h1><p id="z47omw7_3">This guide summarizes <a href="kotlin-evolution-principles.html#incompatible-changes" id="z47omw7_10" data-tooltip="If, upon updating from one version to another, some code that used to work doesn't work anymore, it is an incompatible change in the language (sometimes referred to as a &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work anymore&quot; means precisely in…">incompatible changes</a> you might encounter while developing projects with Kotlin Multiplatform.</p><p id="z47omw7_4">The current Stable version of Kotlin is 2.1.20. Mind the deprecation cycle of a specific change in relation to the Kotlin version you have in your projects, for example:</p><ul class="list _bullet" id="z47omw7_5"><li class="list__item" id="z47omw7_11"><p id="z47omw7_13">When upgrading from Kotlin 1.7.0 to Kotlin 1.9.0, check incompatible changes that came into effect both in <a href="#kotlin-1-9-0-1-9-25" id="z47omw7_14" data-tooltip="This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 1.9.0−1.9.25.">Kotlin 1.9.0</a> and in <a href="#kotlin-1-7-0-1-8-22" id="z47omw7_15" data-tooltip="This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 1.7.0−1.8.22.">Kotlin 1.7.0&minus;1.8.22</a>.</p></li><li class="list__item" id="z47omw7_12"><p id="z47omw7_16">When upgrading from Kotlin 1.9.0 to Kotlin 2.0.0, check incompatible changes that came into effect both in <a href="#kotlin-2-0-0-and-later" id="z47omw7_17" data-tooltip="This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 2.0.0−2.1.20.">Kotlin 2.0.0</a> and in <a href="#kotlin-1-9-0-1-9-25" id="z47omw7_18" data-tooltip="This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 1.9.0−1.9.25.">Kotlin 1.9.0&minus;1.9.25</a>.</p></li></ul><section class="chapter"><h2 id="version-compatibility" data-toc="version-compatibility">Version compatibility</h2><p id="z47omw7_19">When configuring your project, check the compatibility of a particular version of the Kotlin Multiplatform Gradle plugin (same as the Kotlin version in your project) with Gradle, Xcode, and Android Gradle plugin versions:</p><div class="table-wrapper"><table class="wide" id="z47omw7_20"><thead><tr class="ijRowHead" id="z47omw7_22"><th id="z47omw7_29"><p>Kotlin Multiplatform plugin version</p></th><th id="z47omw7_30"><p>Gradle</p></th><th id="z47omw7_31"><p>Android Gradle plugin</p></th><th id="z47omw7_32"><p>Xcode</p></th></tr></thead><tbody><tr id="z47omw7_23"><td id="z47omw7_33"><p>2.1.20</p></td><td id="z47omw7_34"><p>7.6.3&ndash;8.11</p></td><td id="z47omw7_35"><p>7.4.2&ndash;8.7.2</p></td><td id="z47omw7_36"><p>16.0</p></td></tr><tr id="z47omw7_24"><td id="z47omw7_37"><p>2.1.0&ndash;2.1.10</p></td><td id="z47omw7_38"><p>7.6.3-8.10*</p></td><td id="z47omw7_39"><p>7.4.2&ndash;8.7.2</p></td><td id="z47omw7_40"><p>16.0</p></td></tr><tr id="z47omw7_25"><td id="z47omw7_41"><p>2.0.21</p></td><td id="z47omw7_42"><p>7.5-8.8*</p></td><td id="z47omw7_43"><p>7.4.2&ndash;8.5</p></td><td id="z47omw7_44"><p>16.0</p></td></tr><tr id="z47omw7_26"><td id="z47omw7_45"><p>2.0.20</p></td><td id="z47omw7_46"><p>7.5-8.8*</p></td><td id="z47omw7_47"><p>7.4.2&ndash;8.5</p></td><td id="z47omw7_48"><p>15.3</p></td></tr><tr id="z47omw7_27"><td id="z47omw7_49"><p>2.0.0</p></td><td id="z47omw7_50"><p>7.5-8.5</p></td><td id="z47omw7_51"><p>7.4.2&ndash;8.3</p></td><td id="z47omw7_52"><p>15.3</p></td></tr><tr id="z47omw7_28"><td id="z47omw7_53"><p>1.9.20</p></td><td id="z47omw7_54"><p>7.5-8.1.1</p></td><td id="z47omw7_55"><p>7.4.2&ndash;8.2</p></td><td id="z47omw7_56"><p>15.0</p></td></tr></tbody></table></div><aside class="prompt" data-type="warning" data-title="" id="z47omw7_21"><p id="z47omw7_57">*Kotlin 2.0.20&ndash;2.0.21 and Kotlin 2.1.0&ndash;2.1.10 are fully compatible with Gradle up to 8.6. Gradle versions 8.7&ndash;8.10 are also supported, with only one exception: If you use the Kotlin Multiplatform Gradle plugin, you may see deprecation warnings in your multiplatform projects calling the <code class="code" id="z47omw7_58">withJava()</code> function in the JVM target. For more information, see <a href="#java-source-sets-created-by-default" id="z47omw7_59" data-tooltip="What's changed?">Java source sets created by default</a>.</p></aside></section><section class="chapter"><h2 id="kotlin-2-0-0-and-later" data-toc="kotlin-2-0-0-and-later">Kotlin 2.0.0 and later</h2><p id="z47omw7_60">This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 2.0.0&minus;2.1.20.</p><a name="java-source-set-created-by-default"></a><section class="chapter"><h3 id="java-source-sets-created-by-default" data-toc="java-source-sets-created-by-default">Java source sets created by default</h3><p id="z47omw7_70"><span class="control" id="z47omw7_85">What's changed?</span></p><p id="z47omw7_71">To align Kotlin Multiplatform with upcoming changes in Gradle, we are phasing out the <code class="code" id="z47omw7_86">withJava()</code> function. The <code class="code" id="z47omw7_87">withJava()</code> function enabled integration with Gradle's Java plugins by creating the necessary Java source sets. From Kotlin 2.1.20, these Java source sets are created by default.</p><p id="z47omw7_72"><span class="control" id="z47omw7_88">What's the best practice now?</span></p><p id="z47omw7_73">Previously, you had to explicitly use the <code class="code" id="z47omw7_89">withJava()</code> function to create <code class="code" id="z47omw7_90">src/jvmMain/java</code> and <code class="code" id="z47omw7_91">src/jvmTest/java</code> source sets:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm {
        withJava()
    }
}
</div><p id="z47omw7_75">From Kotlin 2.1.20, you can remove the <code class="code" id="z47omw7_92">withJava()</code> function from your build script.</p><p id="z47omw7_76">In addition, Gradle now only runs Java compile tasks if Java sources are present, triggering a JVM validation diagnostic that previously didn't run before. This diagnostic fails if you explicitly configure an incompatible JVM target for <code class="code" id="z47omw7_93">KotlinJvmCompile</code> tasks or inside <code class="code" id="z47omw7_94">compilerOptions</code>. For guidance on ensuring JVM target compatibility, see <a href="gradle-configure-project.html#check-for-jvm-target-compatibility-of-related-compile-tasks" id="z47omw7_95" data-tooltip="In the build module, you may have related compile tasks, for example:">Check for JVM target compatibility of related compile tasks</a>.</p><p id="z47omw7_77">If your project uses Gradle versions higher than 8.7 and doesn't rely on Gradle Java plugins, like <a href="https://docs.gradle.org/current/userguide/java_plugin.html" id="z47omw7_96" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" id="z47omw7_97" data-external="true" rel="noopener noreferrer" target="_blank">Java Library</a>, or <a href="https://docs.gradle.org/current/userguide/application_plugin.html" id="z47omw7_98" data-external="true" rel="noopener noreferrer" target="_blank">Application</a>, or a third party Gradle plugin that has a dependency on a Gradle Java plugin, you can remove the <code class="code" id="z47omw7_99">withJava()</code> function.</p><p id="z47omw7_78">If your project uses the <a href="https://docs.gradle.org/current/userguide/application_plugin.html" id="z47omw7_100" data-external="true" rel="noopener noreferrer" target="_blank">Application</a> Gradle Java plugin, we recommend migrating to the <a href="whatsnew2120.html#kotlin-multiplatform-new-dsl-to-replace-gradle-s-application-plugin" id="z47omw7_101" data-tooltip="Starting with Gradle 8.7, the Application plugin is no longer compatible with the Kotlin Multiplatform Gradle plugin. Kotlin 2.1.20 introduces an Experimental DSL to achieve similar functionality. The new executable {} block configures execution tasks and Gradle distributions for…">new Experimental DSL</a>. Starting with Gradle 8.7, the Application plugin will no longer work with the Kotlin Multiplatform Gradle plugin.</p><p id="z47omw7_79">If you want to use both the Kotlin Multiplatform Gradle plugin and other Gradle plugins for Java in your multiplatform project, see <a href="#deprecated-compatibility-with-kotlin-multiplatform-gradle-plugin-and-gradle-java-plugins" id="z47omw7_102" data-tooltip="What's changed?">Deprecated compatibility with Kotlin Multiplatform Gradle plugin and Java plugins</a>.</p><p id="z47omw7_80">If you run into any issues, report them in our <a href="https://kotl.in/issue" id="z47omw7_103" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a> or ask for help in our <a href="https://kotlinlang.slack.com/archives/C19FD9681" id="z47omw7_104" data-external="true" rel="noopener noreferrer" target="_blank">public Slack channel</a>.</p><p id="z47omw7_81"><span class="control" id="z47omw7_105">When do the changes take effect?</span></p><p id="z47omw7_82">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_83"><li class="list__item" id="z47omw7_106"><p id="z47omw7_109">Gradle &gt;8.6: introduce a deprecation warning for any previous version of Kotlin in multiplatform projects using the <code class="code" id="z47omw7_110">withJava()</code> function.</p></li><li class="list__item" id="z47omw7_107"><p id="z47omw7_111">Gradle 9.0: raise this warning to an error.</p></li><li class="list__item" id="z47omw7_108"><p id="z47omw7_112">2.1.20: introduce a deprecation warning when using the <code class="code" id="z47omw7_113">withJava()</code> function with any version of Gradle.</p></li></ul><a name="android-target-rename"></a></section><section class="chapter"><h3 id="rename-of-android-target-to-androidtarget" data-toc="rename-of-android-target-to-androidtarget">Rename of <code class="code" id="z47omw7_124">android</code> target to <code class="code" id="z47omw7_125">androidTarget</code></h3><p id="z47omw7_115"><span class="control" id="z47omw7_126">What's changed?</span></p><p id="z47omw7_116">We continue our efforts to make Kotlin Multiplatform more stable. An essential step in this direction is to provide first-class support for the Android target. In the future, this support will be provided via a separate plugin, developed by the Android team from Google.</p><p id="z47omw7_117">To open the way for the new solution, we're renaming the <code class="code" id="z47omw7_127">android</code> block to <code class="code" id="z47omw7_128">androidTarget</code> in the current Kotlin DSL. This is a temporary change that is necessary to free the short <code class="code" id="z47omw7_129">android</code> name for the upcoming DSL from Google.</p><p id="z47omw7_118"><span class="control" id="z47omw7_130">What's the best practice now?</span></p><p id="z47omw7_119">Rename all the occurrences of the <code class="code" id="z47omw7_131">android</code> block to <code class="code" id="z47omw7_132">androidTarget</code>. When the new plugin for the Android target support is available, migrate to the DSL from Google. It will be the preferred option to work with Android in Kotlin Multiplatform projects.</p><p id="z47omw7_120"><span class="control" id="z47omw7_133">When do the changes take effect?</span></p><p id="z47omw7_121">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_122"><li class="list__item" id="z47omw7_134"><p id="z47omw7_137">1.9.0: introduce a deprecation warning when the <code class="code" id="z47omw7_138">android</code> name is used in Kotlin Multiplatform projects</p></li><li class="list__item" id="z47omw7_135"><p id="z47omw7_139">2.1.0: raise this warning to an error</p></li><li class="list__item" id="z47omw7_136"><p id="z47omw7_140">2.2.0: remove the <code class="code" id="z47omw7_141">android</code> target DSL from the Kotlin Multiplatform Gradle plugin</p></li></ul><a name="declaring-multiple-targets"></a></section><section class="chapter"><h3 id="declaring-several-similar-targets" data-toc="declaring-several-similar-targets">Declaring several similar targets</h3><p id="z47omw7_142"><span class="control" id="z47omw7_158">What's changed?</span></p><p id="z47omw7_143">We discourage declaring several similar targets in a single Gradle project. For example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm(&quot;jvmKtor&quot;)
    jvm(&quot;jvmOkHttp&quot;) // Not recommended and produces a deprecation warning
}
</div><p id="z47omw7_145">One popular case is having two related pieces of code together. For example, you might want to use <code class="code" id="z47omw7_159">jvm(&quot;jvmKtor&quot;)</code> and <code class="code" id="z47omw7_160">jvm(&quot;jvmOkHttp&quot;)</code> in your <code class="code" id="z47omw7_161">:shared</code> Gradle project to implement networking using the Ktor or OkHttp libraries:</p><div class="code-block" data-lang="kotlin">
// shared/build.gradle.kts:
kotlin {
    jvm(&quot;jvmKtor&quot;) {
        attributes.attribute(/* ... */)
    }
    jvm(&quot;jvmOkHttp&quot;) {
        attributes.attribute(/* ... */)
    }

    sourceSets {
        val commonMain by getting
        val commonJvmMain by sourceSets.creating {
            dependsOn(commonMain)
            dependencies {
                // Shared dependencies
            }
        }
        val jvmKtorMain by getting {
            dependsOn(commonJvmMain)
            dependencies {
                // Ktor dependencies
            }
        }
        val jvmOkHttpMain by getting {
            dependsOn(commonJvmMain)
            dependencies {
                // OkHttp dependencies
            }
        }
    }
}
</div><p id="z47omw7_147">The implementation comes with non-trivial configuration complexity:</p><ul class="list _bullet" id="z47omw7_148"><li class="list__item" id="z47omw7_162"><p id="z47omw7_165">You have to set up Gradle attributes on the <code class="code" id="z47omw7_166">:shared</code> side and each consumer's side. Otherwise, Gradle can't resolve dependencies in such projects because without additional information it's not clear whether the consumer should receive the Ktor-based or the OkHttp-based implementation.</p></li><li class="list__item" id="z47omw7_163"><p id="z47omw7_167">You have to set up the <code class="code" id="z47omw7_168">commonJvmMain</code> source set manually.</p></li><li class="list__item" id="z47omw7_164"><p id="z47omw7_169">The configuration involves a handful of low-level Gradle and Kotlin Gradle plugin abstractions and APIs.</p></li></ul><p id="z47omw7_149"><span class="control" id="z47omw7_170">What's the best practice now?</span></p><p id="z47omw7_150">The configuration is complex because Ktor-based and OkHttp-based implementations are <span class="emphasis" id="z47omw7_171">in the same Gradle project</span>. In many cases, it's possible to extract those parts into separate Gradle projects. Here's a general outline of such as a refactoring:</p><ol class="list _decimal" id="z47omw7_151" type="1"><li class="list__item" id="z47omw7_172"><p id="z47omw7_175">Replace two duplicated targets from the original project with a single target. If you had a shared source set between these targets, move its sources and configuration to the default source set of the newly created target:</p><div class="code-block" data-lang="kotlin">
// shared/build.gradle.kts:
kotlin {
    jvm()

    sourceSets {
        jvmMain {
            // Copy the configuration of jvmCommonMain here
        }
    }
}
</div></li><li class="list__item" id="z47omw7_173"><p id="z47omw7_177">Add two new Gradle projects, usually by calling <code class="code" id="z47omw7_179">include</code> in your <code class="code" id="z47omw7_180">settings.gradle.kts</code> file. For example:</p><div class="code-block" data-lang="kotlin">
include(&quot;:okhttp-impl&quot;)
include(&quot;:ktor-impl&quot;)
</div></li><li class="list__item" id="z47omw7_174"><p id="z47omw7_181">Configure each new Gradle project:</p><ul class="list _bullet" id="z47omw7_182"><li class="list__item" id="z47omw7_184"><p id="z47omw7_188">Most likely, you don't need to apply the <code class="code" id="z47omw7_189">kotlin(&quot;multiplatform&quot;)</code> plugin, as these projects compile only to one target. In this example, you can apply <code class="code" id="z47omw7_190">kotlin(&quot;jvm&quot;)</code>.</p></li><li class="list__item" id="z47omw7_185"><p id="z47omw7_191">Move the content of original target-specific source sets to their respective projects, for example, from <code class="code" id="z47omw7_192">jvmKtorMain</code> to <code class="code" id="z47omw7_193">ktor-impl/src</code>.</p></li><li class="list__item" id="z47omw7_186"><p id="z47omw7_194">Copy the configuration of source sets: dependencies, compiler options, and so on.</p></li><li class="list__item" id="z47omw7_187"><p id="z47omw7_195">Add a dependency from the new Gradle project to the original project.</p></li></ul><div class="code-block" data-lang="kotlin">
// ktor-impl/build.gradle.kts:
plugins {
    kotlin(&quot;jvm&quot;)
}

dependencies {
    project(&quot;:shared&quot;) // Add dependency on the original project
    // Copy dependencies of jvmKtorMain here
}

kotlin {
    compilerOptions {
        // Copy compiler options of jvmKtorMain here
    }
}
</div></li></ol><p id="z47omw7_152">While this approach requires more work on the initial setup, it doesn't use any low-level entities of Gradle and the Kotlin Gradle plugin, making it easier to use and maintain the resulting build.</p><aside class="prompt" data-type="tip" data-title="" id="z47omw7_153"><p id="z47omw7_196">Unfortunately, we can't provide detailed migration steps for each case. If the instructions above don't work for you, describe your use case in this <a href="https://youtrack.jetbrains.com/issue/KT-59316" id="z47omw7_197" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a>.</p></aside><p id="z47omw7_154"><span class="control" id="z47omw7_198">When do the changes take effect?</span></p><p id="z47omw7_155">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_156"><li class="list__item" id="z47omw7_199"><p id="z47omw7_201">1.9.20: introduce a deprecation warning when multiple similar targets are used in Kotlin Multiplatform projects</p></li><li class="list__item" id="z47omw7_200"><p id="z47omw7_202">2.1.0: report an error in such cases, except for Kotlin/JS targets; to learn more about this exception, see the issue in <a href="https://youtrack.jetbrains.com/issue/KT-47038/KJS-MPP-Split-JS-target-into-JsBrowser-and-JsNode" id="z47omw7_203" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a></p></li></ul><a name="deprecate-pre-hmpp-dependencies"></a></section><section class="chapter"><h3 id="deprecated-support-of-multiplatform-libraries-published-in-the-legacy-mode" data-toc="deprecated-support-of-multiplatform-libraries-published-in-the-legacy-mode">Deprecated support of multiplatform libraries published in the legacy mode</h3><p id="z47omw7_204"><span class="control" id="z47omw7_217">What's changed?</span></p><p id="z47omw7_205">Previously, we <a href="#deprecated-gradle-properties-for-hierarchical-structure-support" id="z47omw7_218" data-tooltip="What's changed?">have deprecated the legacy mode</a> in Kotlin Multiplatform projects preventing the publication of &quot;legacy&quot; binaries and encouraged you to migrate your projects to the <a href="multiplatform-hierarchy.html" id="z47omw7_219" data-tooltip="Kotlin Multiplatform projects support hierarchical source set structures. This means you can arrange a hierarchy of intermediate source sets for sharing the common code among some, but not all, supported targets. Using intermediate source sets helps you to:">hierarchical structure</a>.</p><p id="z47omw7_206">To continue phasing out &quot;legacy&quot; binaries from the ecosystem, starting with Kotlin 1.9.0, the use of legacy libraries is also discouraged. If your project uses dependencies on legacy libraries, you'll see the following warning:</p><div class="code-block" data-lang="none">
The dependency group:artifact:1.0 was published in the legacy mode. Support for such dependencies will be removed in the future
</div><p id="z47omw7_208"><span class="control" id="z47omw7_220">What's the best practice now?</span></p><p id="z47omw7_209"><span class="emphasis" id="z47omw7_221">If you use multiplatform libraries</span>, most of them have already migrated to the &quot;hierarchical structure&quot; mode, so you only need to update the library version. See the documentation of the respective libraries for details.</p><p id="z47omw7_210">If the library doesn't support non-legacy binaries yet, you can contact the maintainers and tell them about this compatibility issue.</p><p id="z47omw7_211"><span class="emphasis" id="z47omw7_222">If you're a library author</span>, update the Kotlin Gradle plugin to the latest version and ensure you've fixed the <a href="#deprecated-gradle-properties-for-hierarchical-structure-support" id="z47omw7_223" data-tooltip="What's changed?">deprecated Gradle properties</a>.</p><p id="z47omw7_212">The Kotlin team is eager to help the ecosystem migrate, so if you face any issues, don't hesitate to create an <a href="https://kotl.in/issue" id="z47omw7_224" data-external="true" rel="noopener noreferrer" target="_blank">issue in YouTrack</a>.</p><p id="z47omw7_213"><span class="control" id="z47omw7_225">When do the changes take effect?</span></p><p id="z47omw7_214">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_215"><li class="list__item" id="z47omw7_226"><p id="z47omw7_229">1.9: introduce a deprecation warning for dependencies on legacy libraries</p></li><li class="list__item" id="z47omw7_227"><p id="z47omw7_230">2.0: raise the warning for dependencies on legacy libraries to an error</p></li><li class="list__item" id="z47omw7_228"><p id="z47omw7_231">&gt;2.0: remove support for dependencies on legacy libraries; using such dependencies can cause build failures</p></li></ul><a name="deprecate-hmpp-properties"></a></section><section class="chapter"><h3 id="deprecated-gradle-properties-for-hierarchical-structure-support" data-toc="deprecated-gradle-properties-for-hierarchical-structure-support">Deprecated Gradle properties for hierarchical structure support</h3><p id="z47omw7_232"><span class="control" id="z47omw7_247">What's changed?</span></p><p id="z47omw7_233">Throughout its evolution, Kotlin was gradually introducing the support for <a href="multiplatform-hierarchy.html" id="z47omw7_248" data-tooltip="Kotlin Multiplatform projects support hierarchical source set structures. This means you can arrange a hierarchy of intermediate source sets for sharing the common code among some, but not all, supported targets. Using intermediate source sets helps you to:">hierarchical structure</a>, in multiplatform projects, an ability to have intermediate source sets between the common source set <code class="code" id="z47omw7_249">commonMain</code> and any platform-specific one, for example, <code class="code" id="z47omw7_250">jvmMain</code>.</p><p id="z47omw7_234">For the transition period, while the toolchain wasn't stable enough, a couple of Gradle properties were introduced, allowing granular opt-ins and opt-outs.</p><p id="z47omw7_235">Since Kotlin 1.6.20, the hierarchical project structure support has been enabled by default. However, these properties were kept for opting out in case of blocking issues. After processing all the feedback, we're now starting to phase out those properties completely.</p><p id="z47omw7_236">The following properties are now deprecated:</p><ul class="list _bullet" id="z47omw7_237"><li class="list__item" id="z47omw7_251"><p id="z47omw7_256"><code class="code" id="z47omw7_257">kotlin.internal.mpp.hierarchicalStructureByDefault</code></p></li><li class="list__item" id="z47omw7_252"><p id="z47omw7_258"><code class="code" id="z47omw7_259">kotlin.mpp.enableCompatibilityMetadataVariant</code></p></li><li class="list__item" id="z47omw7_253"><p id="z47omw7_260"><code class="code" id="z47omw7_261">kotlin.mpp.hierarchicalStructureSupport</code></p></li><li class="list__item" id="z47omw7_254"><p id="z47omw7_262"><code class="code" id="z47omw7_263">kotlin.mpp.enableGranularSourceSetsMetadata</code></p></li><li class="list__item" id="z47omw7_255"><p id="z47omw7_264"><code class="code" id="z47omw7_265">kotlin.native.enableDependencyPropagation</code></p></li></ul><p id="z47omw7_238"><span class="control" id="z47omw7_266">What's the best practice now?</span></p><ul class="list _bullet" id="z47omw7_239"><li class="list__item" id="z47omw7_267"><p id="z47omw7_270">Remove these properties from your <code class="code" id="z47omw7_271">gradle.properties</code> and <code class="code" id="z47omw7_272">local.properties</code> files.</p></li><li class="list__item" id="z47omw7_268"><p id="z47omw7_273">Avoid setting them programmatically in the Gradle build scripts or your Gradle plugins.</p></li><li class="list__item" id="z47omw7_269"><p id="z47omw7_274">In case deprecated properties are set by some third-party Gradle plugin used in your build, ask the plugin maintainers not to set these properties.</p></li></ul><p id="z47omw7_240">As the default behavior of the Kotlin toolchain doesn't include such properties since 1.6.20, we don't expect any serious impact from removing them. Most possible consequences will be visible immediately after the project rebuild.</p><p id="z47omw7_241">If you're a library author and want to be extra safe, check that consumers can work with your library.</p><p id="z47omw7_242"><span class="control" id="z47omw7_275">When do the changes take effect?</span></p><p id="z47omw7_243">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_244"><li class="list__item" id="z47omw7_276"><p id="z47omw7_279">1.8.20: report a warning when these properties are used</p></li><li class="list__item" id="z47omw7_277"><p id="z47omw7_280">1.9.20: raise this warning to an error</p></li><li class="list__item" id="z47omw7_278"><p id="z47omw7_281">2.0: remove these properties; the Kotlin Gradle plugin ignores their usages</p></li></ul><p id="z47omw7_245">In the unlikely case you face some problems after removing these properties, create an <a href="https://kotl.in/issue" id="z47omw7_282" data-external="true" rel="noopener noreferrer" target="_blank">issue in YouTrack</a>.</p><a name="target-presets-deprecation"></a></section><section class="chapter"><h3 id="deprecated-target-presets-api" data-toc="deprecated-target-presets-api">Deprecated target presets API</h3><p id="z47omw7_283"><span class="control" id="z47omw7_294">What's changed?</span></p><p id="z47omw7_284">In the very early development stages, Kotlin Multiplatform introduced an API for working with so-called <span class="emphasis" id="z47omw7_295">target presets</span>. Each target preset essentially represented a factory for Kotlin Multiplatform targets. This API turned out to be largely redundant, as DSL functions like <code class="code" id="z47omw7_296">jvm()</code> or <code class="code" id="z47omw7_297">iosSimulatorArm64()</code> cover the same use cases while being much more straightforward and concise.</p><p id="z47omw7_285">To reduce the confusion and provide clearer guidelines, all presets-related APIs are now deprecated and will be removed from the public API of the Kotlin Gradle plugin in future releases. This includes:</p><ul class="list _bullet" id="z47omw7_286"><li class="list__item" id="z47omw7_298"><p id="z47omw7_301">The <code class="code" id="z47omw7_302">presets</code> property in <code class="code" id="z47omw7_303">org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension</code></p></li><li class="list__item" id="z47omw7_299"><p id="z47omw7_304">The <code class="code" id="z47omw7_305">org.jetbrains.kotlin.gradle.plugin.KotlinTargetPreset</code> interface and all its inheritors</p></li><li class="list__item" id="z47omw7_300"><p id="z47omw7_306">The <code class="code" id="z47omw7_307">fromPreset</code> overloads</p></li></ul><p id="z47omw7_287"><span class="control" id="z47omw7_308">What's the best practice now?</span></p><p id="z47omw7_288">Use respective <a href="multiplatform-dsl-reference.html#targets" id="z47omw7_309" data-tooltip="A target is a part of the build responsible for compiling, testing, and packaging a piece of software aimed at one of the supported platforms. Kotlin provides targets for each platform, so you can instruct Kotlin to compile code for that specific target. Learn more about setting up…">Kotlin targets</a> instead, for example:</p><div class="table-wrapper"><table class="wide" id="z47omw7_289"><thead><tr class="ijRowHead" id="z47omw7_310"><th id="z47omw7_312"><p>Before</p></th><th id="z47omw7_313"><p>Now</p></th></tr></thead><tbody><tr id="z47omw7_311"><td id="z47omw7_314"><div class="code-block" data-lang="kotlin">
kotlin {
    targets {
        fromPreset(presets.iosArm64, 'ios')
    }
}
</div></td><td id="z47omw7_315"><div class="code-block" data-lang="kotlin">
kotlin {
    iosArm64()
}
</div></td></tr></tbody></table></div><p id="z47omw7_290"><span class="control" id="z47omw7_318">When do the changes take effect?</span></p><p id="z47omw7_291">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_292"><li class="list__item" id="z47omw7_319"><p id="z47omw7_322">1.9.20: report a warning on any usages of the presets-related API</p></li><li class="list__item" id="z47omw7_320"><p id="z47omw7_323">2.0: raise this warning to an error</p></li><li class="list__item" id="z47omw7_321"><p id="z47omw7_324">&gt;2.0: remove the presets-related API from the public API of the Kotlin Gradle plugin; sources that still use it fail with &quot;unresolved reference&quot; errors, and binaries (for example, Gradle plugins) might fail with linkage errors unless recompiled against the latest versions of the Kotlin Gradle plugin</p></li></ul><a name="target-shortcuts-deprecation"></a></section><section class="chapter"><h3 id="deprecated-apple-target-shortcuts" data-toc="deprecated-apple-target-shortcuts">Deprecated Apple target shortcuts</h3><p id="z47omw7_325"><span class="control" id="z47omw7_336">What's changed?</span></p><p id="z47omw7_326">We're deprecating <code class="code" id="z47omw7_337">ios()</code>, <code class="code" id="z47omw7_338">watchos()</code>, and <code class="code" id="z47omw7_339">tvos()</code> target shortcuts in Kotlin Multiplatform DSL. They were designed to partially create a source set hierarchy for Apple targets. However, they proved to be difficult to expand and sometimes confusing.</p><p id="z47omw7_327">For example, the <code class="code" id="z47omw7_340">ios()</code> shortcut created both the <code class="code" id="z47omw7_341">iosArm64</code> and <code class="code" id="z47omw7_342">iosX64</code> targets but didn't include the <code class="code" id="z47omw7_343">iosSimulatorArm64</code> target, which is necessary when working on hosts with Apple M chips. However, changing this shortcut was hard to implement and could cause issues in existing user projects.</p><p id="z47omw7_328"><span class="control" id="z47omw7_344">What's the best practice now?</span></p><p id="z47omw7_329">The Kotlin Gradle plugin now provides a built-in hierarchy template. Since Kotlin 1.9.20, it's enabled by default and contains predefined intermediate source sets for popular use cases.</p><p id="z47omw7_330">Instead of shortcuts, you should specify the list of targets, and then the plugin automatically sets up intermediate source sets based on this list.</p><p id="z47omw7_331">For example, if you have <code class="code" id="z47omw7_345">iosArm64</code> and <code class="code" id="z47omw7_346">iosSimulatorArm64</code> targets in your project, the plugin automatically creates the <code class="code" id="z47omw7_347">iosMain</code> and <code class="code" id="z47omw7_348">iosTest</code> intermediate source sets. If you have <code class="code" id="z47omw7_349">iosArm64</code> and <code class="code" id="z47omw7_350">macosArm64</code> targets, the <code class="code" id="z47omw7_351">appleMain</code> and <code class="code" id="z47omw7_352">appleTest</code> source sets are created.</p><p id="z47omw7_332">For more information, see <a href="multiplatform-hierarchy.html" id="z47omw7_353" data-tooltip="Kotlin Multiplatform projects support hierarchical source set structures. This means you can arrange a hierarchy of intermediate source sets for sharing the common code among some, but not all, supported targets. Using intermediate source sets helps you to:">Hierarchical project structure</a></p><p id="z47omw7_333"><span class="control" id="z47omw7_354">When do the changes take effect?</span></p><p id="z47omw7_334">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_335"><li class="list__item" id="z47omw7_355"><p id="z47omw7_358">1.9.20: report a warning when <code class="code" id="z47omw7_359">ios()</code>, <code class="code" id="z47omw7_360">watchos()</code>, and <code class="code" id="z47omw7_361">tvos()</code> target shortcuts are used; the default hierarchy template is enabled by default instead</p></li><li class="list__item" id="z47omw7_356"><p id="z47omw7_362">2.1.0: report an error when target shortcuts are used</p></li><li class="list__item" id="z47omw7_357"><p id="z47omw7_363">2.2.0: remove target shortcut DSL from the Kotlin Multiplatform Gradle plugin</p></li></ul></section><section class="chapter"><h3 id="incorrect-version-of-ios-framework-after-kotlin-upgrade" data-toc="incorrect-version-of-ios-framework-after-kotlin-upgrade">Incorrect version of iOS framework after Kotlin upgrade</h3><p id="z47omw7_364"><span class="control" id="z47omw7_372">What's the issue?</span></p><p id="z47omw7_365">Changes in Kotlin code might not be reflected in the iOS app in Xcode when direct integration is used. The direct integration is set up with the <code class="code" id="z47omw7_373">embedAndSignAppleFrameworkForXcode</code> task, which connects the iOS framework from your multiplatform project to the iOS app in Xcode.</p><p id="z47omw7_366">This can happen when you upgrade the Kotlin version from 1.9.2x to 2.0.0 in your multiplatform project (or downgrade it from 2.0.0 to 1.9.2x), then make changes in Kotlin files and try building the app, Xcode may incorrectly use the previous version of the iOS framework. So, the changes won't be visible in the iOS app in Xcode.</p><p id="z47omw7_367"><span class="control" id="z47omw7_374">What's the workaround?</span></p><ol class="list _decimal" id="z47omw7_368" type="1"><li class="list__item" id="z47omw7_375"><p id="z47omw7_378">In Xcode, clean build directories using <span class="control" id="z47omw7_379">Product</span> | <span class="control" id="z47omw7_380">Clean Build Folder</span>.</p></li><li class="list__item" id="z47omw7_376"><p id="z47omw7_381">In the terminal, run the following command:</p><div class="code-block" data-lang="none">
./gradlew clean
</div></li><li class="list__item" id="z47omw7_377"><p id="z47omw7_383">Build the app again to ensure that the new version of the iOS framework is used.</p></li></ol><p id="z47omw7_369"><span class="control" id="z47omw7_384">When will the issue be fixed?</span></p><p id="z47omw7_370">We're planning to fix this issue in Kotlin 2.0.10. You can check if any preview versions of Kotlin 2.0.10 are already available in the <a href="eap.html" id="z47omw7_385" data-tooltip="You can participate in the Kotlin Early Access Preview (EAP) to try out the latest Kotlin features before they are released.">Participate in the Kotlin Early Access Preview</a> section.</p><p id="z47omw7_371">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-68257" id="z47omw7_386" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section></section><section class="chapter"><h2 id="kotlin-1-9-0-1-9-25" data-toc="kotlin-1-9-0-1-9-25">Kotlin 1.9.0&minus;1.9.25</h2><p id="z47omw7_387">This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 1.9.0&minus;1.9.25.</p><a name="compilation-source-deprecation"></a><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="deprecated-api-for-adding-kotlin-source-sets-directly-to-the-kotlin-compilation" data-toc="deprecated-api-for-adding-kotlin-source-sets-directly-to-the-kotlin-compilation">Deprecated API for adding Kotlin source sets directly to the Kotlin compilation</h3></div><div class="collapse__content"><p id="z47omw7_395"><span class="control" id="z47omw7_406">What's changed?</span></p><p id="z47omw7_396">The access to <code class="code" id="z47omw7_407">KotlinCompilation.source</code> has been deprecated. A code like this produces a deprecation warning:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm()
    js()
    iosArm64()
    iosSimulatorArm64()
    
    sourceSets {
        val commonMain by getting
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }
        
        targets[&quot;jvm&quot;].compilations[&quot;main&quot;].source(myCustomIntermediateSourceSet)
    }
}
</div><p id="z47omw7_398"><span class="control" id="z47omw7_408">What's the best practice now?</span></p><p id="z47omw7_399">To replace <code class="code" id="z47omw7_409">KotlinCompilation.source(someSourceSet)</code>, add the <code class="code" id="z47omw7_410">dependsOn</code> relation from the default source set of the <code class="code" id="z47omw7_411">KotlinCompilation</code> to <code class="code" id="z47omw7_412">someSourceSet</code>. We recommend referring to the source directly using <code class="code" id="z47omw7_413">by getting</code>, which is shorter and more readable. However, you can also use <code class="code" id="z47omw7_414">KotlinCompilation.defaultSourceSet.dependsOn(someSourceSet)</code>, which is applicable in all cases.</p><p id="z47omw7_400">You can change the code above in one of the following ways:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm()
    js()
    iosArm64()
    iosSimulatorArm64()

    sourceSets {
        val commonMain by getting
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }
        
        // Option #1. Shorter and more readable, use it when possible. 
        // Usually, the name of the default source set 
        // is a simple concatenation of the target name and the compilation name:
        val jvmMain by getting {
            dependsOn(myCustomIntermediateSourceSet)
        }
        
        // Option #2. Generic solution, use it if your build script requires a more advanced approach:
        targets[&quot;jvm&quot;].compilations[&quot;main&quot;].defaultSourceSet.dependsOn(myCustomIntermediateSourceSet)
    }
}
</div><p id="z47omw7_402"><span class="control" id="z47omw7_415">When do the changes take effect?</span></p><p id="z47omw7_403">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_404"><li class="list__item" id="z47omw7_416"><p id="z47omw7_419">1.9.0: introduce a deprecation warning when <code class="code" id="z47omw7_420">KotlinComplation.source</code> is used</p></li><li class="list__item" id="z47omw7_417"><p id="z47omw7_421">1.9.20: raise this warning to an error</p></li><li class="list__item" id="z47omw7_418"><p id="z47omw7_422">&gt;1.9.20: remove <code class="code" id="z47omw7_423">KotlinComplation.source</code> from the Kotlin Gradle plugin, attempts to use it lead to &quot;unresolved reference&quot; errors during the buildscript compilation</p></li></ul><a name="kotlin-js-plugin-deprecation"></a></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="migration-from-kotlin-js-gradle-plugin-to-kotlin-multiplatform-gradle-plugin" data-toc="migration-from-kotlin-js-gradle-plugin-to-kotlin-multiplatform-gradle-plugin">Migration from <code class="code" id="z47omw7_432">kotlin-js</code> Gradle plugin to <code class="code" id="z47omw7_433">kotlin-multiplatform</code> Gradle plugin</h3></div><div class="collapse__content"><p id="z47omw7_425"><span class="control" id="z47omw7_434">What's changed?</span></p><p id="z47omw7_426">Starting with Kotlin 1.9.0, the <code class="code" id="z47omw7_435">kotlin-js</code> Gradle plugin is deprecated. Basically, it duplicated the functionality of the <code class="code" id="z47omw7_436">kotlin-multiplatform</code> plugin with the <code class="code" id="z47omw7_437">js()</code> target and shared the same implementation under the hood. Such overlap created confusion and increased maintenance load on the Kotlin team. We encourage you to migrate to the <code class="code" id="z47omw7_438">kotlin-multiplatform</code> Gradle plugin with the <code class="code" id="z47omw7_439">js()</code> target instead.</p><p id="z47omw7_427"><span class="control" id="z47omw7_440">What's the best practice now?</span></p><ol class="list _decimal" id="z47omw7_428" type="1"><li class="list__item" id="z47omw7_441"><p id="z47omw7_445">Remove the <code class="code" id="z47omw7_448">kotlin-js</code> Gradle plugin from your project and apply <code class="code" id="z47omw7_449">kotlin-multiplatform</code> in the <code class="code" id="z47omw7_450">settings.gradle.kts</code> file if you're using the <code class="code" id="z47omw7_451">pluginManagement {}</code> block:</p><div class="tabs" id="z47omw7_446" data-anchors="[z47omw7_452,z47omw7_453]"><div class="tabs__content" data-gtm="tab" id="z47omw7_452" data-title="kotlin-js"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
// settings.gradle.kts:
pluginManagement {
    plugins {
        // Remove the following line:
        kotlin(&quot;js&quot;) version &quot;1.9.0&quot;
    }

    repositories {
        // ...
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="z47omw7_453" data-title="kotlin-multiplatform"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
// settings.gradle.kts:
pluginManagement {
    plugins {
        // Add the following line instead:
        kotlin(&quot;multiplatform&quot;) version &quot;1.9.0&quot;
    }

    repositories {
        // ...
    }
}
</div></div></div><p id="z47omw7_447">In case you're using a different way of applying plugins, see <a href="https://docs.gradle.org/current/userguide/plugins.html" id="z47omw7_456" data-external="true" rel="noopener noreferrer" target="_blank">the Gradle documentation</a> for migration instructions.</p></li><li class="list__item" id="z47omw7_442"><p id="z47omw7_457">Move your source files from the <code class="code" id="z47omw7_458">main</code> and <code class="code" id="z47omw7_459">test</code> folders to the <code class="code" id="z47omw7_460">jsMain</code> and <code class="code" id="z47omw7_461">jsTest</code> folders in the same directory.</p></li><li class="list__item" id="z47omw7_443"><p id="z47omw7_462">Adjust dependency declarations:</p><ul class="list _bullet" id="z47omw7_463"><li class="list__item" id="z47omw7_466"><p id="z47omw7_468">We recommend using the <code class="code" id="z47omw7_469">sourceSets {}</code> block and configuring dependencies of respective source sets, <code class="code" id="z47omw7_470">jsMain {}</code> for production dependencies and <code class="code" id="z47omw7_471">jsTest {}</code> for test dependencies. See <a href="multiplatform-add-dependencies.html" id="z47omw7_472" data-tooltip="Every program requires a set of libraries to operate successfully. A Kotlin Multiplatform project can depend on multiplatform libraries that work for all target platforms, platform-specific libraries, and other multiplatform projects.">Adding dependencies</a> for more details.</p></li><li class="list__item" id="z47omw7_467"><p id="z47omw7_473">However, if you want to declare your dependencies in a top-level block, change declarations from <code class="code" id="z47omw7_476">api(&quot;group:artifact:1.0&quot;)</code> to <code class="code" id="z47omw7_477">add(&quot;jsMainApi&quot;, &quot;group:artifact:1.0&quot;)</code> and so on.</p><aside class="prompt" data-type="note" data-title="" id="z47omw7_474"><p id="z47omw7_478">In this case, make sure that the top-level <code class="code" id="z47omw7_479">dependencies {}</code> block comes <span class="control" id="z47omw7_480">after</span> the <code class="code" id="z47omw7_481">kotlin {}</code> block. Otherwise, you'll get an error &quot;Configuration not found&quot;.</p></aside><p id="z47omw7_475"></p></li></ul><p id="z47omw7_464">You can change the code in your <code class="code" id="z47omw7_482">build.gradle.kts</code> file in one of the following ways:</p><div class="tabs" id="z47omw7_465" data-anchors="[z47omw7_483,z47omw7_484]"><div class="tabs__content" data-gtm="tab" id="z47omw7_483" data-title="kotlin-js"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
// build.gradle.kts:
plugins {
    kotlin(&quot;js&quot;) version &quot;1.9.0&quot;
}

dependencies {
    testImplementation(kotlin(&quot;test&quot;))
    implementation(&quot;org.jetbrains.kotlinx:kotlinx-html:0.8.0&quot;)
}

kotlin {
    js {
        // ...
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="z47omw7_484" data-title="kotlin-multiplatform"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
// build.gradle.kts:
plugins {
    kotlin(&quot;multiplatform&quot;) version &quot;1.9.0&quot;
}

kotlin {
    js {
        // ...
    }

    // Option #1. Declare dependencies in the sourceSets {} block:
    sourceSets {
        val jsMain by getting {
            dependencies {
                // No need for the js prefix here, you can just copy and paste it from the top-level block
                implementation(&quot;org.jetbrains.kotlinx:kotlinx-html:0.8.0&quot;)
            }
       }
    }
}

dependencies {
    // Option #2. Add the js prefix to the dependency declaration:
    add(&quot;jsTestImplementation&quot;, kotlin(&quot;test&quot;))
}
</div></div></div></li><li class="list__item" id="z47omw7_444"><p id="z47omw7_487">The DSL provided by the Kotlin Gradle plugin inside the <code class="code" id="z47omw7_488">kotlin {}</code> block remains unchanged in most cases. However, if you were referring to low-level Gradle entities, like tasks and configurations, by names, you now need to adjust them, usually by adding the <code class="code" id="z47omw7_489">js</code> prefix. For example, you can find the <code class="code" id="z47omw7_490">browserTest</code> task under the name <code class="code" id="z47omw7_491">jsBrowserTest</code>.</p></li></ol><p id="z47omw7_429"><span class="control" id="z47omw7_492">When do the changes take effect?</span></p><p id="z47omw7_430">In 1.9.0, the use of the <code class="code" id="z47omw7_493">kotlin-js</code> Gradle plugin produces a deprecation warning.</p><a name="jvmWithJava-preset-deprecation"></a></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="deprecated-jvmwithjava-preset" data-toc="deprecated-jvmwithjava-preset">Deprecated <code class="code" id="z47omw7_506">jvmWithJava</code> preset</h3></div><div class="collapse__content"><p id="z47omw7_495"><span class="control" id="z47omw7_507">What's changed?</span></p><p id="z47omw7_496"><code class="code" id="z47omw7_508">targetPresets.jvmWithJava</code> is deprecated, and its usage is discouraged.</p><p id="z47omw7_497"><span class="control" id="z47omw7_509">What's the best practice now?</span></p><p id="z47omw7_498">Use <code class="code" id="z47omw7_510">jvm { withJava() }</code> target instead. Note that after switching to <code class="code" id="z47omw7_511">jvm { withJava() }</code>, you'll need to adjust the paths to source directories with <code class="code" id="z47omw7_512">.java</code> sources.</p><p id="z47omw7_499">For example, if you use a <code class="code" id="z47omw7_513">jvm</code> target with the default name &quot;jvm&quot;:</p><div class="table-wrapper"><table class="wide" id="z47omw7_500"><thead><tr class="ijRowHead" id="z47omw7_514"><th id="z47omw7_517"><p>Before</p></th><th id="z47omw7_518"><p>Now</p></th></tr></thead><tbody><tr id="z47omw7_515"><td id="z47omw7_519"><p><code class="code" id="z47omw7_521">src/main/java</code></p></td><td id="z47omw7_520"><p><code class="code" id="z47omw7_522">src/jvmMain/java</code></p></td></tr><tr id="z47omw7_516"><td id="z47omw7_523"><p><code class="code" id="z47omw7_525">src/test/java</code></p></td><td id="z47omw7_524"><p><code class="code" id="z47omw7_526">src/jvmTest/java</code></p></td></tr></tbody></table></div><p id="z47omw7_501"><span class="control" id="z47omw7_527">When do the changes take effect?</span></p><p id="z47omw7_502">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_503"><li class="list__item" id="z47omw7_528"><p id="z47omw7_531">1.3.40: introduce a warning when <code class="code" id="z47omw7_532">targetPresets.jvmWithJava</code> is used</p></li><li class="list__item" id="z47omw7_529"><p id="z47omw7_533">1.9.20: raise this warning to an error</p></li><li class="list__item" id="z47omw7_530"><aside class="prompt" data-type="tip" data-title="" id="z47omw7_534"><p id="z47omw7_535">1.9.20: remove <code class="code" id="z47omw7_536">targetPresets.jvmWithJava</code> API; attempts to use it lead to the buildscript compilation failure</p></aside></li></ul><aside class="prompt" data-type="note" data-title="" id="z47omw7_504"><p id="z47omw7_537">Even though the whole <code class="code" id="z47omw7_538">targetPresets</code> API is deprecated, the <code class="code" id="z47omw7_539">jvmWithJava</code> preset has a different deprecation timeline.</p></aside><a name="android-sourceset-layout-v1-deprecation"></a></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="deprecated-legacy-android-source-set-layout" data-toc="deprecated-legacy-android-source-set-layout">Deprecated legacy Android source set layout</h3></div><div class="collapse__content"><p id="z47omw7_540"><span class="control" id="z47omw7_546">What's changed?</span></p><p id="z47omw7_541">The <a href="multiplatform-android-layout.html" id="z47omw7_547" data-tooltip="The new Android source set layout was introduced in Kotlin 1.8.0 and became the default in 1.9.0. Follow this guide to understand the key differences between the deprecated and the new layouts, as well as how to migrate your projects.">new Android source set layout</a> is used by default since Kotlin 1.9.0. Support for the legacy layout is deprecated, and the use of the <code class="code" id="z47omw7_548">kotlin.mpp.androidSourceSetLayoutVersion</code> Gradle property now triggers a deprecation diagnostic.</p><p id="z47omw7_542"><span class="control" id="z47omw7_549">When do the changes take effect?</span></p><p id="z47omw7_543">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_544"><li class="list__item" id="z47omw7_550"><p id="z47omw7_553">&lt;=1.9.0: report a warning when <code class="code" id="z47omw7_554">kotlin.mpp.androidSourceSetLayoutVersion=1</code> is used; the warning can be suppressed with <code class="code" id="z47omw7_555">kotlin.mpp.androidSourceSetLayoutVersion1.nowarn=true</code> Gradle property</p></li><li class="list__item" id="z47omw7_551"><p id="z47omw7_556">1.9.20: raise this warning to an error; the error <span class="control" id="z47omw7_557">cannot</span> be suppressed</p></li><li class="list__item" id="z47omw7_552"><p id="z47omw7_558">&gt;1.9.20: remove support for <code class="code" id="z47omw7_559">kotlin.mpp.androidSourceSetLayoutVersion=1</code>; the Kotlin Gradle plugin ignores the property</p></li></ul><a name="common-sourceset-with-dependson-deprecation"></a></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="deprecated-commonmain-and-commontest-with-custom-dependson" data-toc="deprecated-commonmain-and-commontest-with-custom-dependson">Deprecated <code class="code" id="z47omw7_573">commonMain</code> and <code class="code" id="z47omw7_574">commonTest</code> with custom <code class="code" id="z47omw7_575">dependsOn</code></h3></div><div class="collapse__content"><p id="z47omw7_561"><span class="control" id="z47omw7_576">What's changed?</span></p><p id="z47omw7_562">The <code class="code" id="z47omw7_577">commonMain</code> and <code class="code" id="z47omw7_578">commonTest</code> source sets usually represent the roots of the <code class="code" id="z47omw7_579">main</code> and <code class="code" id="z47omw7_580">test</code> source set hierarchies, respectively. However, it was possible to override that by manually configuring <code class="code" id="z47omw7_581">dependsOn</code> relations of these source sets.</p><p id="z47omw7_563">Maintaining such configuration requires extra effort and knowledge about multiplatform build internals. Additionally, it decreases code readability and reusability of the code because you need to read the particular buildscript to be sure whether <code class="code" id="z47omw7_582">commonMain</code> is the root of the <code class="code" id="z47omw7_583">main</code> source set hierarchy.</p><p id="z47omw7_564">Therefore, accessing <code class="code" id="z47omw7_584">dependsOn</code> on <code class="code" id="z47omw7_585">commonMain</code> and <code class="code" id="z47omw7_586">commonTest</code> is now deprecated.</p><p id="z47omw7_565"><span class="control" id="z47omw7_587">What's the best practice now?</span></p><p id="z47omw7_566">Suppose you need to migrate to 1.9.20 the <code class="code" id="z47omw7_588">customCommonMain</code> source set that uses <code class="code" id="z47omw7_589">commonMain.dependsOn(customCommonMain)</code>. In most cases, <code class="code" id="z47omw7_590">customCommonMain</code> participates in the same compilations as <code class="code" id="z47omw7_591">commonMain</code>, so you can merge <code class="code" id="z47omw7_592">customCommonMain</code> into <code class="code" id="z47omw7_593">commonMain</code>:</p><ol class="list _decimal" id="z47omw7_567" type="1"><li class="list__item" id="z47omw7_594"><p id="z47omw7_597">Copy sources of <code class="code" id="z47omw7_598">customCommonMain</code> into <code class="code" id="z47omw7_599">commonMain</code>.</p></li><li class="list__item" id="z47omw7_595"><p id="z47omw7_600">Add all dependencies of <code class="code" id="z47omw7_601">customCommonMain</code> to <code class="code" id="z47omw7_602">commonMain</code>.</p></li><li class="list__item" id="z47omw7_596"><p id="z47omw7_603">Add all compiler option settings of <code class="code" id="z47omw7_604">customCommonMain</code> to <code class="code" id="z47omw7_605">commonMain</code>.</p></li></ol><p id="z47omw7_568">In rare cases, <code class="code" id="z47omw7_606">customCommonMain</code> might be participating in more compilations than <code class="code" id="z47omw7_607">commonMain</code>. Such a configuration requires additional low-level configuration of the build script. If you're not sure if that's your use case, it most likely isn't.</p><p id="z47omw7_569">If it is your use case, &quot;swap&quot; these two source sets by moving the sources and settings of <code class="code" id="z47omw7_608">customCommonMain</code> to <code class="code" id="z47omw7_609">commonMain</code> and vice versa.</p><p id="z47omw7_570"><span class="control" id="z47omw7_610">When do the changes take effect?</span></p><p id="z47omw7_571">Here's the planned deprecation cycle:</p><ul class="list _bullet" id="z47omw7_572"><li class="list__item" id="z47omw7_611"><p id="z47omw7_613">1.9.0: report a warning when <code class="code" id="z47omw7_614">dependsOn</code> is used in <code class="code" id="z47omw7_615">commonMain</code></p></li><li class="list__item" id="z47omw7_612"><p id="z47omw7_616">&gt;=1.9.20: report an error when <code class="code" id="z47omw7_617">dependsOn</code> is used in <code class="code" id="z47omw7_618">commonMain</code> or <code class="code" id="z47omw7_619">commonTest</code></p></li></ul></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="new-approach-to-forward-declarations" data-toc="new-approach-to-forward-declarations">New approach to forward declarations</h3></div><div class="collapse__content"><p id="z47omw7_620"><span class="control" id="z47omw7_627">What's changed?</span></p><p id="z47omw7_621">The JetBrains team has revamped the approach to forward declarations in Kotlin to make their behavior more predictable:</p><ul class="list _bullet" id="z47omw7_622"><li class="list__item" id="z47omw7_628"><p id="z47omw7_630">You can only import forward declarations using the <code class="code" id="z47omw7_631">cnames</code> or <code class="code" id="z47omw7_632">objcnames</code> packages.</p></li><li class="list__item" id="z47omw7_629"><p id="z47omw7_633">You need to explicitly make a cast to and from the corresponding C and Objective-C forward declaration.</p></li></ul><p id="z47omw7_623"><span class="control" id="z47omw7_634">What's the best practice now?</span></p><ul class="list _bullet" id="z47omw7_624"><li class="list__item" id="z47omw7_635"><p id="z47omw7_637">Consider a C library with a <code class="code" id="z47omw7_638">library.package</code> that declares a <code class="code" id="z47omw7_639">cstructName</code> forward declaration. Previously, it was possible to import it directly from the library with <code class="code" id="z47omw7_640">import library.package.cstructName</code>. Now, you can only use a special forward declaration package for that: <code class="code" id="z47omw7_641">import cnames.structs.cstructName</code>. The same is true for <code class="code" id="z47omw7_642">objcnames</code>.</p></li><li class="list__item" id="z47omw7_636"><p id="z47omw7_643">Consider two objcinterop libraries: one that uses <code class="code" id="z47omw7_650">objcnames.protocols.ForwardDeclaredProtocolProtocol</code> and another that has an actual definition:</p><div class="code-block" data-lang="objectivec">
// First objcinterop library
#import &lt;Foundation/Foundation.h&gt;

@protocol ForwardDeclaredProtocol;

NSString* consumeProtocol(id&lt;ForwardDeclaredProtocol&gt; s) {
    return [NSString stringWithUTF8String:&quot;Protocol&quot;];
}
</div><div class="code-block" data-lang="objectivec">
// Second objcinterop library
// Header:
#import &lt;Foundation/Foundation.h&gt;
@protocol ForwardDeclaredProtocol
@end
// Implementation:
@interface ForwardDeclaredProtocolImpl : NSObject &lt;ForwardDeclaredProtocol&gt;
@end

id&lt;ForwardDeclaredProtocol&gt; produceProtocol() {
    return [ForwardDeclaredProtocolImpl new];
}
</div><p id="z47omw7_646">Previously, it was possible to transfer objects between them seamlessly. Now, an explicit <code class="code" id="z47omw7_651">as</code> cast is required for the forward declaration:</p><div class="code-block" data-lang="kotlin">
// Kotlin code:
fun test() {
    consumeProtocol(produceProtocol() as objcnames.protocols.ForwardDeclaredProtocolProtocol)
}
</div><aside class="prompt" data-type="note" data-title="" id="z47omw7_648"><p id="z47omw7_652">You can only cast to <code class="code" id="z47omw7_653">objcnames.protocols.ForwardDeclaredProtocolProtocol</code> from the corresponding real class. Otherwise, you'll get an error.</p></aside><p id="z47omw7_649"></p></li></ul><p id="z47omw7_625"><span class="control" id="z47omw7_654">When do the changes take effect?</span></p><p id="z47omw7_626">Starting with Kotlin 1.9.20, you need to explicitly make a cast to and from the corresponding C and Objective-C forward declarations. Also, it's now only possible to import forward declarations by using special packages.</p></div></div></section></section><section class="chapter"><h2 id="kotlin-1-7-0-1-8-22" data-toc="kotlin-1-7-0-1-8-22">Kotlin 1.7.0&minus;1.8.22</h2><p id="z47omw7_655">This section covers incompatible changes that end their deprecation cycle and come into effect in Kotlin 1.7.0&minus;1.8.22.</p><a name="deprecated-compatibility-with-kmp-gradle-plugin-and-gradle-java-plugins"></a><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="deprecated-compatibility-with-kotlin-multiplatform-gradle-plugin-and-gradle-java-plugins" data-toc="deprecated-compatibility-with-kotlin-multiplatform-gradle-plugin-and-gradle-java-plugins">Deprecated compatibility with Kotlin Multiplatform Gradle plugin and Gradle Java plugins</h3></div><div class="collapse__content"><p id="z47omw7_661"><span class="control" id="z47omw7_682">What's changed?</span></p><p id="z47omw7_662">Due to compatibility issues between the Kotlin Multiplatform Gradle plugin and the Gradle plugins <a href="https://docs.gradle.org/current/userguide/java_plugin.html" id="z47omw7_683" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" id="z47omw7_684" data-external="true" rel="noopener noreferrer" target="_blank">Java Library</a>, and <a href="https://docs.gradle.org/current/userguide/application_plugin.html" id="z47omw7_685" data-external="true" rel="noopener noreferrer" target="_blank">Application</a>, there is now a deprecation warning when you apply these plugins to the same project. The warning also appears when another Gradle plugin in your multiplatform project applies a Gradle Java plugin. For example, the <a href="https://docs.spring.io/spring-boot/gradle-plugin/index.html" id="z47omw7_686" data-external="true" rel="noopener noreferrer" target="_blank">Spring Boot Gradle Plugin</a> automatically applies the Application plugin. In future Kotlin releases, the warning will be increased to an error.</p><p id="z47omw7_663">We've added this deprecation warning due to fundamental compatibility issues between Kotlin Multiplatform's project model and Gradle's Java ecosystem plugins. Gradle's Java ecosystem plugins currently don't take into account that other plugins may:</p><ul class="list _bullet" id="z47omw7_664"><li class="list__item" id="z47omw7_687"><p id="z47omw7_690">Also publish or compile for the JVM target in a different way than the Java ecosystem plugins.</p></li><li class="list__item" id="z47omw7_688"><p id="z47omw7_691">Have two different JVM targets in the same project, such as JVM and Android.</p></li><li class="list__item" id="z47omw7_689"><p id="z47omw7_692">Have a complex multiplatform project structure with potentially multiple non-JVM targets.</p></li></ul><p id="z47omw7_665">Unfortunately, Gradle doesn't currently provide any API to address these issues.</p><p id="z47omw7_666">We previously used some workarounds in Kotlin Multiplatform to help with the integration of Java ecosystem plugins. However, these workarounds never truly solved the compatibility issues, and since the release of Gradle 8.8, these workarounds are no longer possible. For more information, see our <a href="https://youtrack.jetbrains.com/issue/KT-66542/Gradle-JVM-target-with-withJava-produces-a-deprecation-warning" id="z47omw7_693" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a>.</p><p id="z47omw7_667">While we don't yet know exactly how to resolve this compatibility problem, we are committed to continuing support for some form of Java source compilation in your Kotlin Multiplatform projects. At a minimum, we will support the compilation of Java sources and using Gradle's <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/JavaBasePlugin.html" id="z47omw7_694" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z47omw7_695">java-base</code></a> plugin within your multiplatform projects.</p><p id="z47omw7_668"><span class="control" id="z47omw7_696">What's the best practice now?</span></p><p id="z47omw7_669">If you see this deprecation warning in your multiplatform project, we recommend that you:</p><ol class="list _decimal" id="z47omw7_670" type="1"><li class="list__item" id="z47omw7_697"><p id="z47omw7_699">Determine whether you actually need the Gradle Java plugin in your project. If not, consider removing it.</p></li><li class="list__item" id="z47omw7_698"><p id="z47omw7_700">Check if the Gradle Java plugin is only used for a single task. If so, you might be able to remove the plugin without much effort. For example, if the task uses a Gradle Java plugin to create a Javadoc JAR file, you can define the Javadoc task manually instead.</p></li></ol><p id="z47omw7_671">Otherwise, if you want to use both the Kotlin Multiplatform Gradle plugin and these Gradle plugins for Java in your multiplatform project, we recommend that you:</p><ol class="list _decimal" id="z47omw7_672" type="1"><li class="list__item" id="z47omw7_701"><p id="z47omw7_704">Create a separate subproject in your Gradle project.</p></li><li class="list__item" id="z47omw7_702"><p id="z47omw7_705">In the separate subproject, apply the Gradle plugin for Java.</p></li><li class="list__item" id="z47omw7_703"><p id="z47omw7_706">In the separate subproject, add a dependency on your parent multiplatform project.</p></li></ol><aside class="prompt" data-type="warning" data-title="" id="z47omw7_673"><p id="z47omw7_707">The separate subproject must <span class="control" id="z47omw7_708">not</span> be a multiplatform project, and you must only use it to set up a dependency on your multiplatform project.</p></aside><p id="z47omw7_674">For example, you have a multiplatform project called <code class="code" id="z47omw7_709">my-main-project</code> and you want to use the <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" id="z47omw7_710" data-external="true" rel="noopener noreferrer" target="_blank">Java Library</a> Gradle plugin.</p><p id="z47omw7_675">Once you've created a subproject, let's call it <code class="code" id="z47omw7_711">subproject-A</code>, your parent project structure should look like this:</p><div class="code-block" data-lang="none">
.
├── build.gradle
├── settings.gradle.kts
├── subproject-A
    └── build.gradle.kts
    └── src
        └── Main.java
</div><p id="z47omw7_677">In your subproject's <code class="code" id="z47omw7_712">build.gradle.kts</code> file, apply the Java Library plugin in the <code class="code" id="z47omw7_713">plugins {}</code> block:</p><div class="tabs" id="z47omw7_678" data-group="build-script" data-anchors="[z47omw7_714,z47omw7_715]"><div class="tabs__content" data-gtm="tab" id="z47omw7_714" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
plugins {
    id(&quot;java-library&quot;)
}
</div></div><div class="tabs__content" data-gtm="tab" id="z47omw7_715" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
plugins {
    id('java-library')
}
</div></div></div><p id="z47omw7_679">In your subproject's <code class="code" id="z47omw7_718">build.gradle.kts</code> file, add a dependency on your parent multiplatform project:</p><div class="tabs" id="z47omw7_680" data-group="build-script" data-anchors="[z47omw7_719,z47omw7_720]"><div class="tabs__content" data-gtm="tab" id="z47omw7_719" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
dependencies {
    implementation(project(&quot;:my-main-project&quot;)) // The name of your parent multiplatform project
}
</div></div><div class="tabs__content" data-gtm="tab" id="z47omw7_720" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
dependencies {
    implementation project(':my-main-project') // The name of your parent multiplatform project
}
</div></div></div><p id="z47omw7_681">Your parent project is now set up to work with both plugins.</p></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="new-approach-to-auto-generated-targets" data-toc="new-approach-to-auto-generated-targets">New approach to auto-generated targets</h3></div><div class="collapse__content"><p id="z47omw7_723"><span class="control" id="z47omw7_731">What's changed?</span></p><p id="z47omw7_724">Target accessors auto-generated by Gradle are no longer available inside the <code class="code" id="z47omw7_732">kotlin.targets {}</code> block. Use the <code class="code" id="z47omw7_733">findByName(&quot;targetName&quot;)</code> method instead.</p><p id="z47omw7_725">Note that such accessors are still available in the <code class="code" id="z47omw7_734">kotlin.targets {}</code> case, for example, <code class="code" id="z47omw7_735">kotlin.targets.linuxX64</code>.</p><p id="z47omw7_726"><span class="control" id="z47omw7_736">What's the best practice now?</span></p><div class="table-wrapper"><table class="wide" id="z47omw7_727"><thead><tr class="ijRowHead" id="z47omw7_737"><th id="z47omw7_739"><p>Before</p></th><th id="z47omw7_740"><p>Now</p></th></tr></thead><tbody><tr id="z47omw7_738"><td id="z47omw7_741"><div class="code-block" data-lang="kotlin">
kotlin {
    targets {
        configure(['windows',
            'linux']) {
        }
    }
}
</div></td><td id="z47omw7_742"><div class="code-block" data-lang="kotlin">
kotlin {
    targets {
        configure([findByName('windows'),
            findByName('linux')]) {
        }
    }
}
</div></td></tr></tbody></table></div><p id="z47omw7_728"><span class="control" id="z47omw7_745">When do the changes take effect?</span></p><p id="z47omw7_729">In Kotlin 1.7.20, an error is introduced when using target accessors in the <code class="code" id="z47omw7_746">kotlin.targets {}</code> block.</p><p id="z47omw7_730">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-47047" id="z47omw7_747" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="changes-in-gradle-input-and-output-compile-tasks" data-toc="changes-in-gradle-input-and-output-compile-tasks">Changes in Gradle input and output compile tasks</h3></div><div class="collapse__content"><p id="z47omw7_748"><span class="control" id="z47omw7_756">What's changed?</span></p><p id="z47omw7_749">Kotlin compile tasks no longer inherit the Gradle <code class="code" id="z47omw7_757">AbstractCompile</code> task that has the <code class="code" id="z47omw7_758">sourceCompatibility</code> and <code class="code" id="z47omw7_759">targetCompatibility</code> inputs, making them unavailable in Kotlin users' scripts.</p><p id="z47omw7_750">Other breaking changes in compile tasks:</p><p id="z47omw7_751"><span class="control" id="z47omw7_760">What's the best practice now?</span></p><div class="table-wrapper"><table class="wide" id="z47omw7_752"><thead><tr class="ijRowHead" id="z47omw7_761"><th id="z47omw7_766"><p>Before</p></th><th id="z47omw7_767"><p>Now</p></th></tr></thead><tbody><tr id="z47omw7_762"><td id="z47omw7_768"><p>The <code class="code" id="z47omw7_770">SourceTask.stableSources</code> input is no longer available.</p></td><td id="z47omw7_769"><p>Use the <code class="code" id="z47omw7_771">sources</code> input instead. Also, the <code class="code" id="z47omw7_772">setSource()</code> methods are still available.</p></td></tr><tr id="z47omw7_763"><td id="z47omw7_773"><p>The <code class="code" id="z47omw7_775">sourceFilesExtensions</code> input was removed.</p></td><td id="z47omw7_774"><p>Compile tasks still implement the <code class="code" id="z47omw7_776">PatternFilterable</code> interface. Use its methods for filtering Kotlin sources.</p></td></tr><tr id="z47omw7_764"><td id="z47omw7_777"><p>The <code class="code" id="z47omw7_779">Gradle destinationDir: File</code> output was deprecated.</p></td><td id="z47omw7_778"><p>Use the <code class="code" id="z47omw7_780">destinationDirectory: DirectoryProperty</code> output instead.</p></td></tr><tr id="z47omw7_765"><td id="z47omw7_781"><p>The <code class="code" id="z47omw7_783">classpath</code> property of the <code class="code" id="z47omw7_784">KotlinCompile</code> task is deprecated.</p></td><td id="z47omw7_782"><p>All compile tasks now use the <code class="code" id="z47omw7_785">libraries</code> input for a list of libraries required for compilation.</p></td></tr></tbody></table></div><p id="z47omw7_753"><span class="control" id="z47omw7_786">When do the changes take effect?</span></p><p id="z47omw7_754">In Kotlin 1.7.20, inputs are not available, the output is replaced, and the <code class="code" id="z47omw7_787">classpath</code> property is deprecated.</p><p id="z47omw7_755">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-32805" id="z47omw7_788" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="new-configuration-names-for-dependencies-on-the-compilation" data-toc="new-configuration-names-for-dependencies-on-the-compilation">New configuration names for dependencies on the compilation</h3></div><div class="collapse__content"><p id="z47omw7_789"><span class="control" id="z47omw7_800">What's changed?</span></p><p id="z47omw7_790">Compilation configurations created by the Kotlin Multiplatform Gradle Plugin received new names.</p><p id="z47omw7_791">A target in the Kotlin Multiplatform project has two default compilations, <code class="code" id="z47omw7_801">main</code> and <code class="code" id="z47omw7_802">test</code>. Each of these compilations has its own default source set, for example, <code class="code" id="z47omw7_803">jvmMain</code> and <code class="code" id="z47omw7_804">jvmTest</code>. Previously the configuration names for the test compilation and its default source set were the same, which might lead to a name clash resulting in issues when a configuration marked with platform-specific attributes is included in another configuration.</p><p id="z47omw7_792">Now compilation configurations have an extra <code class="code" id="z47omw7_805">Compilation</code> postfix, while projects and plugins that use old hard-coded configuration names no longer compile.</p><p id="z47omw7_793">Configuration names for dependencies on the corresponding source set stay the same.</p><p id="z47omw7_794"><span class="control" id="z47omw7_806">What's the best practice now?</span></p><div class="table-wrapper"><table class="wide" id="z47omw7_795"><thead><tr class="ijRowHead" id="z47omw7_807"><th id="z47omw7_813"></th><th id="z47omw7_814"><p>Before</p></th><th id="z47omw7_815"><p>Now</p></th></tr></thead><tbody><tr id="z47omw7_808"><td id="z47omw7_816" rowspan="2"><p>Dependencies of the <code class="code" id="z47omw7_819">jvmMain</code> compilation</p></td><td id="z47omw7_817"><div class="code-block" data-lang="kotlin">
jvm&lt;Scope&gt;
</div></td><td id="z47omw7_818"><div class="code-block" data-lang="kotlin">
jvmCompilation&lt;Scope&gt;
</div></td></tr><tr id="z47omw7_809"><td id="z47omw7_822"><div class="code-block" data-lang="kotlin">
dependencies {
    add(&quot;jvmImplementation&quot;,
        &quot;foo.bar.baz:1.2.3&quot;)
}
</div></td><td id="z47omw7_823"><div class="code-block" data-lang="kotlin">
dependencies {
    add(&quot;jvmCompilationImplementation&quot;,
        &quot;foo.bar.baz:1.2.3&quot;)
}
</div></td></tr><tr id="z47omw7_810"><td id="z47omw7_826"><p>Dependencies of the <code class="code" id="z47omw7_828">jvmMain</code> source set</p></td><td id="z47omw7_827" colspan="2"><div class="code-block" data-lang="kotlin">
jvmMain&lt;Scope&gt;
</div></td></tr><tr id="z47omw7_811"><td id="z47omw7_830"><p>Dependencies of the <code class="code" id="z47omw7_833">jvmTest</code> compilation</p></td><td id="z47omw7_831"><div class="code-block" data-lang="kotlin">
jvmTest&lt;Scope&gt;
</div></td><td id="z47omw7_832"><div class="code-block" data-lang="kotlin">
jvmTestCompilation&lt;Scope&gt;
</div></td></tr><tr id="z47omw7_812"><td id="z47omw7_836"><p>Dependencies of the <code class="code" id="z47omw7_838">jvmTest</code> source set</p></td><td id="z47omw7_837" colspan="2"><div class="code-block" data-lang="kotlin">
jvmTest&lt;Scope&gt;
</div></td></tr></tbody></table></div><p id="z47omw7_796">The available scopes are <code class="code" id="z47omw7_840">Api</code>, <code class="code" id="z47omw7_841">Implementation</code>, <code class="code" id="z47omw7_842">CompileOnly</code>, and <code class="code" id="z47omw7_843">RuntimeOnly</code>.</p><p id="z47omw7_797"><span class="control" id="z47omw7_844">When do the changes take effect?</span></p><p id="z47omw7_798">In Kotlin 1.8.0, an error is introduced when using old configuration names in hard-coded strings.</p><p id="z47omw7_799">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-35916/" id="z47omw7_845" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></div></div></section></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="multiplatform-android-layout.html" class="navigation-links__prev">Android source set layout</a><a href="multiplatform-plugin-releases.html" class="navigation-links__next">Kotlin Multiplatform plugin releases</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>