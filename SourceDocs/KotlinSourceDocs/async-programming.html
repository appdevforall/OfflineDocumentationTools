<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:00.401730344"><title>Asynchronous programming techniques | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"threading","level":0,"title":"Threading","anchor":"#threading"},{"id":"callbacks","level":0,"title":"Callbacks","anchor":"#callbacks"},{"id":"futures-promises-and-others","level":0,"title":"Futures, promises, and others","anchor":"#futures-promises-and-others"},{"id":"reactive-extensions","level":0,"title":"Reactive extensions","anchor":"#reactive-extensions"},{"id":"coroutines","level":0,"title":"Coroutines","anchor":"#coroutines"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Asynchronous programming techniques | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/async-programming.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Asynchronous programming techniques | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/async-programming.html#webpage",
    "url": "writerside-documentation/async-programming.html",
    "name": "Asynchronous programming techniques | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="async-programming" data-main-title="Asynchronous programming techniques" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="async-programming" id="async-programming.md">Asynchronous programming techniques</h1><p id="z204in1_2">For decades, as developers we are confronted with a problem to solve - how to prevent our applications from blocking. Whether we're developing desktop, mobile, or even server-side applications, we want to avoid having the user wait or what's worse cause bottlenecks that would prevent an application from scaling.</p><p id="z204in1_3">There have been many approaches to solving this problem, including:</p><ul class="list _bullet" id="z204in1_4"><li class="list__item" id="z204in1_11"><p id="z204in1_16"><a href="#threading" id="z204in1_17" data-tooltip="Threads are by far probably the most well-known approach to avoid applications from blocking.">Threading</a></p></li><li class="list__item" id="z204in1_12"><p id="z204in1_18"><a href="#callbacks" id="z204in1_19" data-tooltip="With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.">Callbacks</a></p></li><li class="list__item" id="z204in1_13"><p id="z204in1_20"><a href="#futures-promises-and-others" id="z204in1_21" data-tooltip="The idea behind futures or promises (other terms may be used depending on the language or platform), is that when we make a call, we're promised that at some point the call will return a Promise object, which we can then operate on.">Futures, promises, and others</a></p></li><li class="list__item" id="z204in1_14"><p id="z204in1_22"><a href="#reactive-extensions" id="z204in1_23" data-tooltip="Reactive Extensions (Rx) were introduced to C# by Erik Meijer. While it was definitely used on the .NET platform it really didn't reach mainstream adoption until Netflix ported it over to Java, naming it RxJava. From then on, numerous ports have been provided for a variety ofâ€¦">Reactive Extensions</a></p></li><li class="list__item" id="z204in1_15"><p id="z204in1_24"><a href="#coroutines" id="z204in1_25" data-tooltip="Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.">Coroutines</a></p></li></ul><p id="z204in1_5">Before explaining what coroutines are, let's briefly review some of the other solutions.</p><section class="chapter"><h2 id="threading" data-toc="threading">Threading</h2><p id="z204in1_26">Threads are by far probably the most well-known approach to avoid applications from blocking.</p><div class="code-block" data-lang="kotlin">
fun postItem(item: Item) {
    val token = preparePost()
    val post = submitPost(token, item)
    processPost(post)
}

fun preparePost(): Token {
    // makes a request and consequently blocks the main thread
    return token
}
</div><p id="z204in1_28">Let's assume in the code above that <code class="code" id="z204in1_30">preparePost</code> is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</p><ul class="list _bullet" id="z204in1_29"><li class="list__item" id="z204in1_31"><p id="z204in1_35">Threads aren't cheap. Threads require context switches which are costly.</p></li><li class="list__item" id="z204in1_32"><p id="z204in1_36">Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</p></li><li class="list__item" id="z204in1_33"><p id="z204in1_37">Threads aren't always available. Some platforms, such as JavaScript do not even support threads.</p></li><li class="list__item" id="z204in1_34"><p id="z204in1_38">Threads aren't easy. Debugging threads and avoiding race conditions are common problems we suffer in multi-threaded programming.</p></li></ul></section><section class="chapter"><h2 id="callbacks" data-toc="callbacks">Callbacks</h2><p id="z204in1_39">With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.</p><div class="code-block" data-lang="kotlin">
fun postItem(item: Item) {
    preparePostAsync { token -&gt; 
        submitPostAsync(token, item) { post -&gt; 
            processPost(post)
        }
    }
}

fun preparePostAsync(callback: (Token) -&gt; Unit) {
    // make request and return immediately 
    // arrange callback to be invoked later
}
</div><p id="z204in1_41">This in principle feels like a much more elegant solution, but once again has several issues:</p><ul class="list _bullet" id="z204in1_42"><li class="list__item" id="z204in1_44"><p id="z204in1_46">Difficulty of nested callbacks. Usually a function that is used as a callback, often ends up needing its own callback. This leads to a series of nested callbacks which lead to incomprehensible code. The pattern is often referred to as callback hell, or the <a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" id="z204in1_47" data-external="true" rel="noopener noreferrer" target="_blank">pyramid of doom</a> due to the triangular shape that indentations from these deeply nested callbacks create.</p></li><li class="list__item" id="z204in1_45"><p id="z204in1_48">Error handling is complicated. The nesting model makes error handling and propagation of these somewhat more complicated.</p></li></ul><p id="z204in1_43">Callbacks are quite common in event-loop architectures such as JavaScript, but even there, generally people have moved away to using other approaches such as promises or reactive extensions.</p></section><section class="chapter"><h2 id="futures-promises-and-others" data-toc="futures-promises-and-others">Futures, promises, and others</h2><p id="z204in1_49">The idea behind futures or promises (other terms may be used depending on the language or platform), is that when we make a call, we're <span class="emphasis" id="z204in1_53">promised</span> that at some point the call will return a <code class="code" id="z204in1_54">Promise</code> object, which we can then operate on.</p><div class="code-block" data-lang="kotlin">
fun postItem(item: Item) {
    preparePostAsync() 
        .thenCompose { token -&gt; 
            submitPostAsync(token, item)
        }
        .thenAccept { post -&gt; 
            processPost(post)
        }
         
}

fun preparePostAsync(): Promise&lt;Token&gt; {
    // makes request and returns a promise that is completed later
    return promise 
}
</div><p id="z204in1_51">This approach requires a series of changes in how we program, in particular:</p><ul class="list _bullet" id="z204in1_52"><li class="list__item" id="z204in1_55"><p id="z204in1_59">Different programming model. Similar to callbacks, the programming model moves away from a top-down imperative approach to a compositional model with chained calls. Traditional program structures such as loops, exception handling, etc. usually are no longer valid in this model.</p></li><li class="list__item" id="z204in1_56"><p id="z204in1_60">Different APIs. Usually there's a need to learn a completely new API such as <code class="code" id="z204in1_61">thenCompose</code> or <code class="code" id="z204in1_62">thenAccept</code>, which can also vary across platforms.</p></li><li class="list__item" id="z204in1_57"><p id="z204in1_63">Specific return type. The return type moves away from the actual data that we need and instead returns a new type <code class="code" id="z204in1_64">Promise</code> which has to be introspected.</p></li><li class="list__item" id="z204in1_58"><p id="z204in1_65">Error handling can be complicated. The propagation and chaining of errors aren't always straightforward.</p></li></ul></section><section class="chapter"><h2 id="reactive-extensions" data-toc="reactive-extensions">Reactive extensions</h2><p id="z204in1_66">Reactive Extensions (Rx) were introduced to C# by <a href="https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)" id="z204in1_72" data-external="true" rel="noopener noreferrer" target="_blank">Erik Meijer</a>. While it was definitely used on the .NET platform it really didn't reach mainstream adoption until Netflix ported it over to Java, naming it RxJava. From then on, numerous ports have been provided for a variety of platforms including JavaScript (RxJS).</p><p id="z204in1_67">The idea behind Rx is to move towards what's called <code class="code" id="z204in1_73">observable streams</code> whereby we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the <a href="https://en.wikipedia.org/wiki/Observer_pattern" id="z204in1_74" data-external="true" rel="noopener noreferrer" target="_blank">Observer Pattern</a> with a series of extensions which allow us to operate on the data.</p><p id="z204in1_68">In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereas Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</p><div class="code-block" data-lang="none">&quot;everything is a stream, and it's observable&quot;
</div><p id="z204in1_70">This implies a different way to approach problems and quite a significant shift from what we're used to when writing synchronous code. One benefit as opposed to Futures is that given it's ported to so many platforms, generally we can find a consistent API experience no matter what we use, be it C#, Java, JavaScript, or any other language where Rx is available.</p><p id="z204in1_71">In addition, Rx does introduce a somewhat nicer approach to error handling.</p></section><section class="chapter"><h2 id="coroutines" data-toc="coroutines">Coroutines</h2><p id="z204in1_75">Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</p><p id="z204in1_76">One of the benefits however of coroutines is that when it comes to the developer, writing non-blocking code is essentially the same as writing blocking code. The programming model in itself doesn't really change.</p><p id="z204in1_77">Take for instance the following code:</p><div class="code-block" data-lang="kotlin">
fun postItem(item: Item) {
    launch {
        val token = preparePost()
        val post = submitPost(token, item)
        processPost(post)
    }
}

suspend fun preparePost(): Token {
    // makes a request and suspends the coroutine
    return suspendCoroutine { /* ... */ } 
}
</div><p id="z204in1_79">This code will launch a long-running operation without blocking the main thread. The <code class="code" id="z204in1_83">preparePost</code> is what's called a <code class="code" id="z204in1_84">suspendable function</code>, thus the keyword <code class="code" id="z204in1_85">suspend</code> prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</p><ul class="list _bullet" id="z204in1_80"><li class="list__item" id="z204in1_86"><p id="z204in1_90">The function signature remains exactly the same. The only difference is <code class="code" id="z204in1_91">suspend</code> being added to it. The return type however is the type we want to be returned.</p></li><li class="list__item" id="z204in1_87"><p id="z204in1_92">The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called <code class="code" id="z204in1_93">launch</code> which essentially kicks off the coroutine (covered in other tutorials).</p></li><li class="list__item" id="z204in1_88"><p id="z204in1_94">The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs.</p></li><li class="list__item" id="z204in1_89"><p id="z204in1_95">It is platform independent. Whether we're targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</p></li></ul><p id="z204in1_81">Coroutines are not a new concept, let alone invented by Kotlin. They've been around for decades and are popular in some other programming languages such as Go. What is important to note though is that the way they're implemented in Kotlin, most of the functionality is delegated to libraries. In fact, beyond the <code class="code" id="z204in1_96">suspend</code> keyword, no other keywords are added to the language. This is somewhat different from languages such as C# that have <code class="code" id="z204in1_97">async</code> and <code class="code" id="z204in1_98">await</code> as part of the syntax. With Kotlin, these are just library functions.</p><p id="z204in1_82">For more information, see the <a href="coroutines-overview.html" id="z204in1_99" data-tooltip="Asynchronous or non-blocking programming is an important part of the development landscape. When creating server-side, desktop, or mobile applications, it's important to provide an experience that is not only fluid from the user's perspective, but also scalable when needed.">Coroutines reference</a>.</p></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="this-expressions.html" class="navigation-links__prev">This expressions</a><a href="coroutines-overview.html" class="navigation-links__next">Coroutines</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>