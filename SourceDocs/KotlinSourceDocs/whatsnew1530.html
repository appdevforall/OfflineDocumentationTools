<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:01.659345257"><title>What's new in Kotlin 1.5.30 | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"language-features","level":0,"title":"Language features","anchor":"#language-features"},{"id":"exhaustive-when-statements-for-sealed-and-boolean-subjects","level":1,"title":"Exhaustive when statements for sealed and Boolean subjects","anchor":"#exhaustive-when-statements-for-sealed-and-boolean-subjects"},{"id":"suspending-functions-as-supertypes","level":1,"title":"Suspending functions as supertypes","anchor":"#suspending-functions-as-supertypes"},{"id":"requiring-opt-in-on-implicit-usages-of-experimental-apis","level":1,"title":"Requiring opt-in on implicit usages of experimental APIs","anchor":"#requiring-opt-in-on-implicit-usages-of-experimental-apis"},{"id":"changes-to-using-opt-in-requirement-annotations-with-different-targets","level":1,"title":"Changes to using opt-in requirement annotations with different targets","anchor":"#changes-to-using-opt-in-requirement-annotations-with-different-targets"},{"id":"improvements-to-type-inference-for-recursive-generic-types","level":1,"title":"Improvements to type inference for recursive generic types","anchor":"#improvements-to-type-inference-for-recursive-generic-types"},{"id":"eliminating-builder-inference-restrictions","level":1,"title":"Eliminating builder inference restrictions","anchor":"#eliminating-builder-inference-restrictions"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"instantiation-of-annotation-classes","level":1,"title":"Instantiation of annotation classes","anchor":"#instantiation-of-annotation-classes"},{"id":"improved-nullability-annotation-support-configuration","level":1,"title":"Improved nullability annotation support configuration","anchor":"#improved-nullability-annotation-support-configuration"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"apple-silicon-support","level":1,"title":"Apple silicon support","anchor":"#apple-silicon-support"},{"id":"improved-kotlin-dsl-for-the-cocoapods-gradle-plugin","level":1,"title":"Improved Kotlin DSL for the CocoaPods Gradle plugin","anchor":"#improved-kotlin-dsl-for-the-cocoapods-gradle-plugin"},{"id":"experimental-interoperability-with-swift-5-5-async-await","level":1,"title":"Experimental interoperability with Swift 5.5 async/await","anchor":"#experimental-interoperability-with-swift-5-5-async-await"},{"id":"improved-swift-objective-c-mapping-for-objects-and-companion-objects","level":1,"title":"Improved Swift/Objective-C mapping for objects and companion objects","anchor":"#improved-swift-objective-c-mapping-for-objects-and-companion-objects"},{"id":"deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets","level":1,"title":"Deprecation of linkage against DLLs without import libraries for MinGW targets","anchor":"#deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets"},{"id":"kotlin-multiplatform","level":0,"title":"Kotlin Multiplatform","anchor":"#kotlin-multiplatform"},{"id":"ability-to-use-custom-cinterop-libraries-in-shared-native-code","level":1,"title":"Ability to use custom cinterop libraries in shared native code","anchor":"#ability-to-use-custom-cinterop-libraries-in-shared-native-code"},{"id":"support-for-xcframeworks","level":1,"title":"Support for XCFrameworks","anchor":"#support-for-xcframeworks"},{"id":"new-default-publishing-setup-for-android-artifacts","level":1,"title":"New default publishing setup for Android artifacts","anchor":"#new-default-publishing-setup-for-android-artifacts"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"js-ir-compiler-backend-reaches-beta","level":1,"title":"JS IR compiler backend reaches Beta","anchor":"#js-ir-compiler-backend-reaches-beta"},{"id":"better-debugging-experience-for-applications-with-the-kotlin-js-ir-backend","level":1,"title":"Better debugging experience for applications with the Kotlin/JS IR backend","anchor":"#better-debugging-experience-for-applications-with-the-kotlin-js-ir-backend"},{"id":"gradle","level":0,"title":"Gradle","anchor":"#gradle"},{"id":"support-for-java-toolchains","level":1,"title":"Support for Java toolchains","anchor":"#support-for-java-toolchains"},{"id":"ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface","level":1,"title":"Ability to specify JDK home with UsesKotlinJavaToolchain interface","anchor":"#ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface"},{"id":"easier-way-to-explicitly-specify-kotlin-daemon-jvm-arguments","level":1,"title":"Easier way to explicitly specify Kotlin daemon JVM arguments","anchor":"#easier-way-to-explicitly-specify-kotlin-daemon-jvm-arguments"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"changing-duration-tostring-output","level":1,"title":"Changing Duration.toString() output","anchor":"#changing-duration-tostring-output"},{"id":"parsing-duration-from-string","level":1,"title":"Parsing Duration from String","anchor":"#parsing-duration-from-string"},{"id":"matching-with-regex-at-a-particular-position","level":1,"title":"Matching with Regex at a particular position","anchor":"#matching-with-regex-at-a-particular-position"},{"id":"splitting-regex-to-a-sequence","level":1,"title":"Splitting Regex to a sequence","anchor":"#splitting-regex-to-a-sequence"},{"id":"serialization-1-3-0-rc","level":0,"title":"Serialization 1.3.0-RC","anchor":"#serialization-1-3-0-rc"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.5.30 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/whatsnew1530.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="What's new in Kotlin 1.5.30 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/whatsnew1530.html#webpage",
    "url": "writerside-documentation/whatsnew1530.html",
    "name": "What's new in Kotlin 1.5.30 | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="whatsnew1530" data-main-title="What's new in Kotlin 1.5.30" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew1530" id="whatsnew1530.md">What's new in Kotlin 1.5.30</h1><p id="p5ebpv_2"><span class="emphasis" id="p5ebpv_16"><a href="releases.html#release-details" id="p5ebpv_17" data-tooltip="The following table lists details of the latest Kotlin releases:">Released: 24 August 2021</a></span></p><p id="p5ebpv_3">Kotlin 1.5.30 offers language updates including previews of future changes, various improvements in platform support and tooling, and new standard library functions.</p><p id="p5ebpv_4">Here are some major improvements:</p><ul class="list _bullet" id="p5ebpv_5"><li class="list__item" id="p5ebpv_18"><p id="p5ebpv_22">Language features, including experimental sealed <code class="code" id="p5ebpv_23">when</code> statements, changes in using opt-in requirement, and others</p></li><li class="list__item" id="p5ebpv_19"><p id="p5ebpv_24">Native support for Apple silicon</p></li><li class="list__item" id="p5ebpv_20"><p id="p5ebpv_25">Kotlin/JS IR backend reaches Beta</p></li><li class="list__item" id="p5ebpv_21"><p id="p5ebpv_26">Improved Gradle plugin experience</p></li></ul><p id="p5ebpv_6">You can also find a short overview of the changes in the <a href="https://blog.jetbrains.com/kotlin/2021/08/kotlin-1-5-30-released/" id="p5ebpv_27" data-external="true" rel="noopener noreferrer" target="_blank">release blog post</a> and this video:</p><div class="video-player" id="p5ebpv_7"><object class="article__bordered-element" width="560" height="315" data-theme="light" type="application/x-shockwave-flash" data="https://www.youtube.com/v/rNbb3A9IdOo?color2=FBE9EC&amp;rel=0&amp;hd=1&amp;autoplay=0&amp;version=3&amp;modestbranding=1&amp;fs=1"></object></div><section class="chapter"><h2 id="language-features" data-toc="language-features">Language features</h2><p id="p5ebpv_28">Kotlin 1.5.30 is presenting previews of future language changes and bringing improvements to the opt-in requirement mechanism and type inference:</p><ul class="list _bullet" id="p5ebpv_29"><li class="list__item" id="p5ebpv_36"><p id="p5ebpv_42"><a href="#exhaustive-when-statements-for-sealed-and-boolean-subjects" id="p5ebpv_43" data-tooltip="Support for sealed (exhaustive) when statements is Experimental. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Exhaustive when statements for sealed and Boolean subjects</a></p></li><li class="list__item" id="p5ebpv_37"><p id="p5ebpv_44"><a href="#suspending-functions-as-supertypes" id="p5ebpv_45" data-tooltip="Support for suspending functions as supertypes is Experimental. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Suspending functions as supertypes</a></p></li><li class="list__item" id="p5ebpv_38"><p id="p5ebpv_46"><a href="#requiring-opt-in-on-implicit-usages-of-experimental-apis" id="p5ebpv_47" data-tooltip="The opt-in requirement mechanism is Experimental. It may change at any time. See how to opt-in. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Requiring opt-in on implicit usages of experimental APIs</a></p></li><li class="list__item" id="p5ebpv_39"><p id="p5ebpv_48"><a href="#changes-to-using-opt-in-requirement-annotations-with-different-targets" id="p5ebpv_49" data-tooltip="The opt-in requirement mechanism is Experimental. It may change at any time. See how to opt-in. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Changes to using opt-in requirement annotations with different targets</a></p></li><li class="list__item" id="p5ebpv_40"><p id="p5ebpv_50"><a href="#improvements-to-type-inference-for-recursive-generic-types" id="p5ebpv_51" data-tooltip="In Kotlin and Java, you can define a recursive generic type, which references itself in its type parameters. In Kotlin 1.5.30, the Kotlin compiler can infer a type argument based only on upper bounds of the corresponding type parameter if it is a recursive generic. This makes it…">Improvements to type inference for recursive generic types</a></p></li><li class="list__item" id="p5ebpv_41"><p id="p5ebpv_52"><a href="#eliminating-builder-inference-restrictions" id="p5ebpv_53" data-tooltip="Builder inference is a special kind of type inference that allows you to infer the type arguments of a call based on type information from other calls inside its lambda argument. This can be useful when calling generic builder functions such as buildList() or sequence(): buildList {…">Eliminating builder inference restrictions</a></p></li></ul><section class="chapter"><h3 id="exhaustive-when-statements-for-sealed-and-boolean-subjects" data-toc="exhaustive-when-statements-for-sealed-and-boolean-subjects">Exhaustive when statements for sealed and Boolean subjects</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_54"><p id="p5ebpv_61">Support for sealed (exhaustive) when statements is <a href="components-stability.html" id="p5ebpv_62" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-12380" id="p5ebpv_63" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_55">An <span class="emphasis" id="p5ebpv_64">exhaustive</span> <a href="control-flow.html#when-expressions-and-statements" id="p5ebpv_65" data-tooltip="when is a conditional expression that runs code based on multiple possible values or conditions. It is similar to the switch statement in Java, C, and similar languages. For example:"><code class="code" id="p5ebpv_67">when</code></a> statement contains branches for either all possible types or values of its subject, or for certain types and includes an <code class="code" id="p5ebpv_66">else</code> branch to cover any remaining cases.</p><p id="p5ebpv_56">We're planning to prohibit non-exhaustive <code class="code" id="p5ebpv_68">when</code> statements soon to make the behavior consistent with <code class="code" id="p5ebpv_69">when</code> expressions. To ensure smooth migration, you can configure the compiler to report warnings about non-exhaustive <code class="code" id="p5ebpv_70">when</code> statements with a sealed class or a Boolean. Such warnings will appear by default in Kotlin 1.6 and will become errors later.</p><aside class="prompt" data-type="note" data-title="" id="p5ebpv_57"><p id="p5ebpv_71">Enums already get a warning.</p></aside><div class="code-block" data-lang="kotlin">
sealed class Mode {
    object ON : Mode()
    object OFF : Mode()
}

fun main() {
    val x: Mode = Mode.ON
    when (x) { 
        Mode.ON -&gt; println(&quot;ON&quot;)
    }
// WARNING: Non exhaustive 'when' statements on sealed classes/interfaces 
// will be prohibited in 1.7, add an 'OFF' or 'else' branch instead

    val y: Boolean = true
    when (y) {  
        true -&gt; println(&quot;true&quot;)
    }
// WARNING: Non exhaustive 'when' statements on Booleans will be prohibited 
// in 1.7, add a 'false' or 'else' branch instead
}
</div><p id="p5ebpv_59">To enable this feature in Kotlin 1.5.30, use language version <code class="code" id="p5ebpv_72">1.6</code>. You can also change the warnings to errors by enabling <a href="whatsnew13.html#progressive-mode" id="p5ebpv_73" data-tooltip="Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that breaking changes (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).">progressive mode</a>.</p><div class="tabs" id="p5ebpv_60" data-group="build-script" data-anchors="[p5ebpv_74,p5ebpv_75]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_74" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    sourceSets.all {
        languageSettings.apply {
            languageVersion = &quot;1.6&quot;
            //progressiveMode = true // false by default
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_75" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    sourceSets.all {
        languageSettings {
            languageVersion = '1.6'
            //progressiveMode = true // false by default
        }
    }
}
</div></div></div></section><section class="chapter"><h3 id="suspending-functions-as-supertypes" data-toc="suspending-functions-as-supertypes">Suspending functions as supertypes</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_78"><p id="p5ebpv_85">Support for suspending functions as supertypes is <a href="components-stability.html" id="p5ebpv_86" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-18707" id="p5ebpv_87" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_79">Kotlin 1.5.30 provides a preview of the ability to use a <code class="code" id="p5ebpv_88">suspend</code> functional type as a supertype with some limitations.</p><div class="code-block" data-lang="kotlin">
class MyClass: suspend () -&gt; Unit {
    override suspend fun invoke() { TODO() }
}
</div><p id="p5ebpv_81">Use the <code class="code" id="p5ebpv_89">-language-version 1.6</code> compiler option to enable the feature:</p><div class="tabs" id="p5ebpv_82" data-group="build-script" data-anchors="[p5ebpv_90,p5ebpv_91]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_90" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    sourceSets.all {
        languageSettings.apply {
            languageVersion = &quot;1.6&quot;
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_91" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    sourceSets.all {
        languageSettings {
            languageVersion = '1.6'
        }
    }
}
</div></div></div><p id="p5ebpv_83">The feature has the following restrictions:</p><ul class="list _bullet" id="p5ebpv_84"><li class="list__item" id="p5ebpv_94"><p id="p5ebpv_96">You can't mix an ordinary functional type and a <code class="code" id="p5ebpv_97">suspend</code> functional type as supertype. This is because of the implementation details of <code class="code" id="p5ebpv_98">suspend</code> functional types in the JVM backend. They are represented in it as ordinary functional types with a marker interface. Because of the marker interface, there is no way to tell which of the superinterfaces are suspended and which are ordinary.</p></li><li class="list__item" id="p5ebpv_95"><p id="p5ebpv_99">You can't use multiple <code class="code" id="p5ebpv_100">suspend</code> functional supertypes. If there are type checks, you also can't use multiple ordinary functional supertypes.</p></li></ul></section><section class="chapter"><h3 id="requiring-opt-in-on-implicit-usages-of-experimental-apis" data-toc="requiring-opt-in-on-implicit-usages-of-experimental-apis">Requiring opt-in on implicit usages of experimental APIs</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_101"><p id="p5ebpv_106">The opt-in requirement mechanism is <a href="components-stability.html" id="p5ebpv_107" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may change at any time. <a href="opt-in-requirements.html" id="p5ebpv_108" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">See how to opt-in</a>. Use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issues/KT" id="p5ebpv_109" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_102">The author of a library can mark an experimental API as <a href="opt-in-requirements.html#create-opt-in-requirement-annotations" id="p5ebpv_110" data-tooltip="To require opt-in to use your module's API, create an annotation class to use as an opt-in requirement annotation. This class must be annotated with @RequiresOptIn:">requiring opt-in</a> to inform users about its experimental state. The compiler raises a warning or error when the API is used and requires <a href="opt-in-requirements.html#opt-in-to-api" id="p5ebpv_111" data-tooltip="If a library author marks a declaration from their library's API as requiring opt-in, you must give explicit consent before you can use it in your code. There are several ways to opt in. We recommend choosing the approach that best suits your situation.">explicit consent</a> to suppress it.</p><p id="p5ebpv_103">In Kotlin 1.5.30, the compiler treats any declaration that has an experimental type in the signature as experimental. Namely, it requires opt-in even for implicit usages of an experimental API. For example, if the function's return type is marked as an experimental API element, a usage of the function requires you to opt-in even if the declaration is not marked as requiring an opt-in explicitly.</p><div class="code-block" data-lang="kotlin">
// Library code

@RequiresOptIn(message = &quot;This API is experimental.&quot;)
@Retention(AnnotationRetention.BINARY)
@Target(AnnotationTarget.CLASS)
annotation class MyDateTime // Opt-in requirement annotation

@MyDateTime
class DateProvider // A class requiring opt-in

// Client code

// Warning: experimental API usage
fun createDateSource(): DateProvider { /* ... */ }

fun getDate(): Date {
    val dateSource = createDateSource() // Also warning: experimental API usage
    // ... 
}
</div><p id="p5ebpv_105">Learn more about <a href="opt-in-requirements.html" id="p5ebpv_112" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">opt-in requirements</a>.</p></section><section class="chapter"><h3 id="changes-to-using-opt-in-requirement-annotations-with-different-targets" data-toc="changes-to-using-opt-in-requirement-annotations-with-different-targets">Changes to using opt-in requirement annotations with different targets</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_113"><p id="p5ebpv_117">The opt-in requirement mechanism is <a href="components-stability.html" id="p5ebpv_118" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may change at any time. <a href="opt-in-requirements.html" id="p5ebpv_119" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">See how to opt-in</a>. Use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issues/KT" id="p5ebpv_120" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_114">Kotlin 1.5.30 presents new rules for using and declaring opt-in requirement annotations on different <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/" id="p5ebpv_121" data-external="true" rel="noopener noreferrer" target="_blank">targets</a>. The compiler now reports an error for use cases that are impractical to handle at compile time. In Kotlin 1.5.30:</p><ul class="list _bullet" id="p5ebpv_115"><li class="list__item" id="p5ebpv_122"><p id="p5ebpv_126">Marking local variables and value parameters with opt-in requirement annotations is forbidden at the use site.</p></li><li class="list__item" id="p5ebpv_123"><p id="p5ebpv_127">Marking override is allowed only if its basic declaration is also marked.</p></li><li class="list__item" id="p5ebpv_124"><p id="p5ebpv_128">Marking backing fields and getters is forbidden. You can mark the basic property instead.</p></li><li class="list__item" id="p5ebpv_125"><p id="p5ebpv_129">Setting <code class="code" id="p5ebpv_130">TYPE</code> and <code class="code" id="p5ebpv_131">TYPE_PARAMETER</code> annotation targets is forbidden at the opt-in requirement annotation declaration site.</p></li></ul><p id="p5ebpv_116">Learn more about <a href="opt-in-requirements.html" id="p5ebpv_132" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">opt-in requirements</a>.</p></section><section class="chapter"><h3 id="improvements-to-type-inference-for-recursive-generic-types" data-toc="improvements-to-type-inference-for-recursive-generic-types">Improvements to type inference for recursive generic types</h3><p id="p5ebpv_133">In Kotlin and Java, you can define a recursive generic type, which references itself in its type parameters. In Kotlin 1.5.30, the Kotlin compiler can infer a type argument based only on upper bounds of the corresponding type parameter if it is a recursive generic. This makes it possible to create various patterns with recursive generic types that are often used in Java to make builder APIs.</p><div class="code-block" data-lang="kotlin">
// Kotlin 1.5.20
val containerA = PostgreSQLContainer&lt;Nothing&gt;(DockerImageName.parse(&quot;postgres:13-alpine&quot;)).apply {
    withDatabaseName(&quot;db&quot;)
    withUsername(&quot;user&quot;)
    withPassword(&quot;password&quot;)
    withInitScript(&quot;sql/schema.sql&quot;)
}

// Kotlin 1.5.30
val containerB = PostgreSQLContainer(DockerImageName.parse(&quot;postgres:13-alpine&quot;))
    .withDatabaseName(&quot;db&quot;)
    .withUsername(&quot;user&quot;)
    .withPassword(&quot;password&quot;)
    .withInitScript(&quot;sql/schema.sql&quot;)
</div><p id="p5ebpv_135">You can enable the improvements by passing the <code class="code" id="p5ebpv_136">-Xself-upper-bound-inference</code> or the <code class="code" id="p5ebpv_137">-language-version 1.6</code> compiler options. See other examples of newly supported use cases in <a href="https://youtrack.jetbrains.com/issue/KT-40804" id="p5ebpv_138" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="eliminating-builder-inference-restrictions" data-toc="eliminating-builder-inference-restrictions">Eliminating builder inference restrictions</h3><p id="p5ebpv_139">Builder inference is a special kind of type inference that allows you to infer the type arguments of a call based on type information from other calls inside its lambda argument. This can be useful when calling generic builder functions such as <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-list.html" id="p5ebpv_144" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_147">buildList()</code></a> or <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html" id="p5ebpv_145" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_148">sequence()</code></a>: <code class="code" id="p5ebpv_146">buildList { add(&quot;string&quot;) }</code>.</p><p id="p5ebpv_140">Inside such a lambda argument, there was previously a limitation on using the type information that the builder inference tries to infer. This means you can only specify it and cannot get it. For example, you cannot call <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/get.html" id="p5ebpv_149" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_151">get()</code></a> inside a lambda argument of <code class="code" id="p5ebpv_150">buildList()</code> without explicitly specified type arguments.</p><p id="p5ebpv_141">Kotlin 1.5.30 removes these limitations with the <code class="code" id="p5ebpv_152">-Xunrestricted-builder-inference</code> compiler option. Add this option to enable previously prohibited calls inside a lambda argument of generic builder functions:</p><div class="code-block" data-lang="kotlin">
@kotlin.ExperimentalStdlibApi
val list = buildList {
    add(&quot;a&quot;)
    add(&quot;b&quot;)
    set(1, null)
    val x = get(1)
    if (x != null) {
        removeAt(1)
    }
}

@kotlin.ExperimentalStdlibApi
val map = buildMap {
    put(&quot;a&quot;, 1)
    put(&quot;b&quot;, 1.1)
    put(&quot;c&quot;, 2f)
}
</div><p id="p5ebpv_143">Also, you can enable this feature with the <code class="code" id="p5ebpv_153">-language-version 1.6</code> compiler option.</p></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="p5ebpv_154">With Kotlin 1.5.30, Kotlin/JVM receives the following features:</p><ul class="list _bullet" id="p5ebpv_155"><li class="list__item" id="p5ebpv_159"><p id="p5ebpv_161"><a href="#instantiation-of-annotation-classes" id="p5ebpv_162" data-tooltip="Instantiation of annotation classes is Experimental. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Instantiation of annotation classes</a></p></li><li class="list__item" id="p5ebpv_160"><p id="p5ebpv_163"><a href="#improved-nullability-annotation-support-configuration" id="p5ebpv_164" data-tooltip="The Kotlin compiler can read various types of nullability annotations to get nullability information from Java. This information allows it to report nullability mismatches in Kotlin when calling Java code.">Improved nullability annotation support configuration</a></p></li></ul><p id="p5ebpv_156">See the <a href="#gradle" id="p5ebpv_165" data-tooltip="As a part of our mission to improve the Kotlin Gradle plugin user experience, we've implemented the following features:">Gradle</a> section for Kotlin Gradle plugin updates on the JVM platform.</p><section class="chapter"><h3 id="instantiation-of-annotation-classes" data-toc="instantiation-of-annotation-classes">Instantiation of annotation classes</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_166"><p id="p5ebpv_171">Instantiation of annotation classes is <a href="components-stability.html" id="p5ebpv_172" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-45395" id="p5ebpv_173" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_167">With Kotlin 1.5.30 you can now call constructors of <a href="annotations.html" id="p5ebpv_174" data-tooltip="Annotations are means of attaching metadata to code. To declare an annotation, put the annotation modifier in front of a class:">annotation classes</a> in arbitrary code to obtain a resulting instance. This feature covers the same use cases as the Java convention that allows the implementation of an annotation interface.</p><div class="code-block" data-lang="kotlin">
annotation class InfoMarker(val info: String)

fun processInfo(marker: InfoMarker) = ...

fun main(args: Array&lt;String&gt;) {
    if (args.size != 0)
        processInfo(getAnnotationReflective(args))
    else
        processInfo(InfoMarker(&quot;default&quot;))
}
</div><p id="p5ebpv_169">Use the <code class="code" id="p5ebpv_175">-language-version 1.6</code> compiler option to enable this feature. Note that all current annotation class limitations, such as restrictions to define non-<code class="code" id="p5ebpv_176">val</code> parameters or members different from secondary constructors, remain intact.</p><p id="p5ebpv_170">Learn more about instantiation of annotation classes in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-instantiation.md" id="p5ebpv_177" data-external="true" rel="noopener noreferrer" target="_blank">this KEEP</a></p></section><section class="chapter"><h3 id="improved-nullability-annotation-support-configuration" data-toc="improved-nullability-annotation-support-configuration">Improved nullability annotation support configuration</h3><p id="p5ebpv_178">The Kotlin compiler can read various types of <a href="java-interop.html#nullability-annotations" id="p5ebpv_183" data-tooltip="Java types that have nullability annotations are represented not as platform types, but as actual nullable or non-nullable Kotlin types. The compiler supports several flavors of nullability annotations, including:">nullability annotations</a> to get nullability information from Java. This information allows it to report nullability mismatches in Kotlin when calling Java code.</p><p id="p5ebpv_179">In Kotlin 1.5.30, you can specify whether the compiler reports a nullability mismatch based on the information from specific types of nullability annotations. Just use the compiler option <code class="code" id="p5ebpv_184">-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>. In the argument, specify the fully qualified nullability annotations package and one of these report levels:</p><ul class="list _bullet" id="p5ebpv_180"><li class="list__item" id="p5ebpv_185"><p id="p5ebpv_188"><code class="code" id="p5ebpv_189">ignore</code> to ignore nullability mismatches</p></li><li class="list__item" id="p5ebpv_186"><p id="p5ebpv_190"><code class="code" id="p5ebpv_191">warn</code> to report warnings</p></li><li class="list__item" id="p5ebpv_187"><p id="p5ebpv_192"><code class="code" id="p5ebpv_193">strict</code> to report errors.</p></li></ul><p id="p5ebpv_181">See the <a href="java-interop.html#nullability-annotations" id="p5ebpv_194" data-tooltip="Java types that have nullability annotations are represented not as platform types, but as actual nullable or non-nullable Kotlin types. The compiler supports several flavors of nullability annotations, including:">full list of supported nullability annotations</a> along with their fully qualified package names.</p><p id="p5ebpv_182">Here is an example showing how to enable error reporting for the newly supported <a href="https://github.com/ReactiveX/RxJava" id="p5ebpv_195" data-external="true" rel="noopener noreferrer" target="_blank">RxJava</a> 3 nullability annotations: <code class="code" id="p5ebpv_196">-Xnullability-annotations=@io.reactivex.rxjava3.annotations:strict</code>. Note that all such nullability mismatches are warnings by default.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="p5ebpv_197">Kotlin/Native has received various changes and improvements:</p><ul class="list _bullet" id="p5ebpv_198"><li class="list__item" id="p5ebpv_204"><p id="p5ebpv_209"><a href="#apple-silicon-support" id="p5ebpv_210" data-tooltip="Kotlin 1.5.30 introduces native support for Apple silicon.">Apple silicon support</a></p></li><li class="list__item" id="p5ebpv_205"><p id="p5ebpv_211"><a href="#improved-kotlin-dsl-for-the-cocoapods-gradle-plugin" id="p5ebpv_212" data-tooltip="Kotlin 1.5.30 introduces the improved CocoaPods Gradle plugin DSL for Kotlin/Native frameworks. In addition to the name of the framework, you can specify other parameters in the Pod configuration:">Improved Kotlin DSL for the CocoaPods Gradle plugin</a></p></li><li class="list__item" id="p5ebpv_206"><p id="p5ebpv_213"><a href="#experimental-interoperability-with-swift-5-5-async-await" id="p5ebpv_214" data-tooltip="Concurrency interoperability with Swift async/await is Experimental. It may be dropped or changed at any time. You should use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack.">Experimental interoperability with Swift 5.5 async/await</a></p></li><li class="list__item" id="p5ebpv_207"><p id="p5ebpv_215"><a href="#improved-swift-objective-c-mapping-for-objects-and-companion-objects" id="p5ebpv_216" data-tooltip="Getting objects and companion objects can now be done in a way that is more intuitive for native iOS developers. For example, if you have the following objects in Kotlin:">Improved Swift/Objective-C mapping for objects and companion objects</a></p></li><li class="list__item" id="p5ebpv_208"><p id="p5ebpv_217"><a href="#deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets" id="p5ebpv_218" data-tooltip="LLD is a linker from the LLVM project, which we plan to start using in Kotlin/Native for MinGW targets because of its benefits over the default ld.bfd – primarily its better performance.">Deprecation of linkage against DLLs without import libraries for MinGW targets</a></p></li></ul><section class="chapter"><h3 id="apple-silicon-support" data-toc="apple-silicon-support">Apple silicon support</h3><p id="p5ebpv_219">Kotlin 1.5.30 introduces native support for <a href="https://support.apple.com/en-us/HT211814" id="p5ebpv_225" data-external="true" rel="noopener noreferrer" target="_blank">Apple silicon</a>.</p><p id="p5ebpv_220">Previously, the Kotlin/Native compiler and tooling required the <a href="https://developer.apple.com/documentation/apple-silicon/about-the-rosetta-translation-environment" id="p5ebpv_226" data-external="true" rel="noopener noreferrer" target="_blank">Rosetta translation environment</a> for working on Apple silicon hosts. In Kotlin 1.5.30, the translation environment is no longer needed &ndash; the compiler and tooling can run on Apple silicon hardware without requiring any additional actions.</p><p id="p5ebpv_221">We've also introduced new targets that make Kotlin code run natively on Apple silicon:</p><ul class="list _bullet" id="p5ebpv_222"><li class="list__item" id="p5ebpv_227"><p id="p5ebpv_231"><code class="code" id="p5ebpv_232">macosArm64</code></p></li><li class="list__item" id="p5ebpv_228"><p id="p5ebpv_233"><code class="code" id="p5ebpv_234">iosSimulatorArm64</code></p></li><li class="list__item" id="p5ebpv_229"><p id="p5ebpv_235"><code class="code" id="p5ebpv_236">watchosSimulatorArm64</code></p></li><li class="list__item" id="p5ebpv_230"><p id="p5ebpv_237"><code class="code" id="p5ebpv_238">tvosSimulatorArm64</code></p></li></ul><p id="p5ebpv_223">They are available on both Intel-based and Apple silicon hosts. All existing targets are available on Apple silicon hosts as well.</p><p id="p5ebpv_224">Note that in 1.5.30 we provide only basic support for Apple silicon targets in the <code class="code" id="p5ebpv_239">kotlin-multiplatform</code> Gradle plugin. Particularly, the new simulator targets aren't included in the <code class="code" id="p5ebpv_240">ios</code>, <code class="code" id="p5ebpv_241">tvos</code>, and <code class="code" id="p5ebpv_242">watchos</code> target shortcuts. We will keep working to improve the user experience with the new targets.</p></section><section class="chapter"><h3 id="improved-kotlin-dsl-for-the-cocoapods-gradle-plugin" data-toc="improved-kotlin-dsl-for-the-cocoapods-gradle-plugin">Improved Kotlin DSL for the CocoaPods Gradle plugin</h3><section class="chapter"><h4 id="new-parameters-for-kotlin-native-frameworks" data-toc="new-parameters-for-kotlin-native-frameworks">New parameters for Kotlin/Native frameworks</h4><p id="p5ebpv_245">Kotlin 1.5.30 introduces the improved CocoaPods Gradle plugin DSL for Kotlin/Native frameworks. In addition to the name of the framework, you can specify other parameters in the Pod configuration:</p><ul class="list _bullet" id="p5ebpv_246"><li class="list__item" id="p5ebpv_249"><p id="p5ebpv_252">Specify the dynamic or static version of the framework</p></li><li class="list__item" id="p5ebpv_250"><p id="p5ebpv_253">Enable export dependencies explicitly</p></li><li class="list__item" id="p5ebpv_251"><p id="p5ebpv_254">Enable Bitcode embedding</p></li></ul><p id="p5ebpv_247">To use the new DSL, update your project to Kotlin 1.5.30, and specify the parameters in the <code class="code" id="p5ebpv_255">cocoapods</code> section of your <code class="code" id="p5ebpv_256">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
cocoapods {
    frameworkName = &quot;MyFramework&quot; // This property is deprecated 
    // and will be removed in future versions
    // New DSL for framework configuration:
    framework {
        // All Framework properties are supported
        // Framework name configuration. Use this property instead of 
        // deprecated 'frameworkName'
        baseName = &quot;MyFramework&quot;
        // Dynamic framework support
        isStatic = false
        // Dependency export
        export(project(&quot;:anotherKMMModule&quot;))
        transitiveExport = false // This is default.
        // Bitcode embedding
        embedBitcode(BITCODE)
    }
}
</div></section><section class="chapter"><h4 id="support-custom-names-for-xcode-configuration" data-toc="support-custom-names-for-xcode-configuration">Support custom names for Xcode configuration</h4><p id="p5ebpv_257">The Kotlin CocoaPods Gradle plugin supports custom names in the Xcode build configuration. It will also help you if you're using special names for the build configuration in Xcode, for example <code class="code" id="p5ebpv_262">Staging</code>.</p><p id="p5ebpv_258">To specify a custom name, use the <code class="code" id="p5ebpv_263">xcodeConfigurationToNativeBuildType</code> parameter in the <code class="code" id="p5ebpv_264">cocoapods</code> section of your <code class="code" id="p5ebpv_265">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
cocoapods {
    // Maps custom Xcode configuration to NativeBuildType
    xcodeConfigurationToNativeBuildType[&quot;CUSTOM_DEBUG&quot;] = NativeBuildType.DEBUG
    xcodeConfigurationToNativeBuildType[&quot;CUSTOM_RELEASE&quot;] = NativeBuildType.RELEASE
}
</div><p id="p5ebpv_260">This parameter will not appear in the Podspec file. When Xcode runs the Gradle build process, the Kotlin CocoaPods Gradle plugin will select the necessary native build type.</p><aside class="prompt" data-type="note" data-title="" id="p5ebpv_261"><p id="p5ebpv_266">There's no need to declare the <code class="code" id="p5ebpv_267">Debug</code> and <code class="code" id="p5ebpv_268">Release</code> configurations because they are supported by default.</p></aside></section></section><section class="chapter"><h3 id="experimental-interoperability-with-swift-5-5-async-await" data-toc="experimental-interoperability-with-swift-5-5-async-await">Experimental interoperability with Swift 5.5 async/await</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_269"><p id="p5ebpv_273">Concurrency interoperability with Swift async/await is <a href="components-stability.html" id="p5ebpv_274" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. You should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="p5ebpv_275" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_270">We added <a href="whatsnew14.html#support-for-kotlin-s-suspending-functions-in-swift-and-objective-c" id="p5ebpv_276" data-tooltip="In 1.4.0, we add the basic support for suspending functions in Swift and Objective-C. Now, when you compile a Kotlin module into an Apple framework, suspending functions are available in it as functions with callbacks (completionHandler in the Swift/Objective-C terminology). When…">support for calling Kotlin's suspending functions from Objective-C and Swift in 1.4.0</a>, and now we're improving it to keep up with a new Swift 5.5 feature &ndash; <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" id="p5ebpv_277" data-external="true" rel="noopener noreferrer" target="_blank">concurrency with <code class="code" id="p5ebpv_278">async</code> and <code class="code" id="p5ebpv_279">await</code> modifiers</a>.</p><p id="p5ebpv_271">The Kotlin/Native compiler now emits the <code class="code" id="p5ebpv_280">_Nullable_result</code> attribute in the generated Objective-C headers for suspending functions with nullable return types. This makes it possible to call them from Swift as <code class="code" id="p5ebpv_281">async</code> functions with the proper nullability.</p><p id="p5ebpv_272">Note that this feature is experimental and can be affected in the future by changes in both Kotlin and Swift. For now, we're offering a preview of this feature that has certain limitations, and we are eager to hear what you think. Learn more about its current state and leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="p5ebpv_282" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack issue</a>.</p></section><section class="chapter"><h3 id="improved-swift-objective-c-mapping-for-objects-and-companion-objects" data-toc="improved-swift-objective-c-mapping-for-objects-and-companion-objects">Improved Swift/Objective-C mapping for objects and companion objects</h3><p id="p5ebpv_283">Getting objects and companion objects can now be done in a way that is more intuitive for native iOS developers. For example, if you have the following objects in Kotlin:</p><div class="code-block" data-lang="kotlin">
object MyObject {
    val x = &quot;Some value&quot;
}

class MyClass {
    companion object {
        val x = &quot;Some value&quot;
    }
}
</div><p id="p5ebpv_285">To access them in Swift, you can use the <code class="code" id="p5ebpv_288">shared</code> and <code class="code" id="p5ebpv_289">companion</code> properties:</p><div class="code-block" data-lang="swift">
MyObject.shared
MyObject.shared.x
MyClass.companion
MyClass.Companion.shared
</div><p id="p5ebpv_287">Learn more about <a href="native-objc-interop.html" id="p5ebpv_290" data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation.">Swift/Objective-C interoperability</a>.</p></section><section class="chapter"><h3 id="deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets" data-toc="deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets">Deprecation of linkage against DLLs without import libraries for MinGW targets</h3><p id="p5ebpv_291"><a href="https://lld.llvm.org/" id="p5ebpv_294" data-external="true" rel="noopener noreferrer" target="_blank">LLD</a> is a linker from the LLVM project, which we plan to start using in Kotlin/Native for MinGW targets because of its benefits over the default ld.bfd &ndash; primarily its better performance.</p><p id="p5ebpv_292">However, the latest stable version of LLD doesn't support direct linkage against DLL for MinGW (Windows) targets. Such linkage requires using <a href="https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details/3573527#3573527" id="p5ebpv_295" data-external="true" rel="noopener noreferrer" target="_blank">import libraries</a>. Although they aren't needed with Kotlin/Native 1.5.30, we're adding a warning to inform you that such usage is incompatible with LLD that will become the default linker for MinGW in the future.</p><p id="p5ebpv_293">Please share your thoughts and concerns about the transition to the LLD linker in <a href="https://youtrack.jetbrains.com/issue/KT-47605" id="p5ebpv_296" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack issue</a>.</p></section></section><section class="chapter"><h2 id="kotlin-multiplatform" data-toc="kotlin-multiplatform">Kotlin Multiplatform</h2><p id="p5ebpv_297">1.5.30 brings the following notable updates to Kotlin Multiplatform:</p><ul class="list _bullet" id="p5ebpv_298"><li class="list__item" id="p5ebpv_302"><p id="p5ebpv_305"><a href="#ability-to-use-custom-cinterop-libraries-in-shared-native-code" id="p5ebpv_306" data-tooltip="Kotlin Multiplatform gives you an option to use platform-dependent interop libraries in shared source sets. Before 1.5.30, this worked only with platform libraries shipped with Kotlin/Native distribution. Starting from 1.5.30, you can use it with your custom cinterop libraries. To…">Ability to use custom <code class="code" id="p5ebpv_307">cinterop</code> libraries in shared native code</a></p></li><li class="list__item" id="p5ebpv_303"><p id="p5ebpv_308"><a href="#support-for-xcframeworks" id="p5ebpv_309" data-tooltip="All Kotlin Multiplatform projects can now have XCFrameworks as an output format. Apple introduced XCFrameworks as a replacement for universal (fat) frameworks. With the help of XCFrameworks you:">Support for XCFrameworks</a></p></li><li class="list__item" id="p5ebpv_304"><p id="p5ebpv_310"><a href="#new-default-publishing-setup-for-android-artifacts" id="p5ebpv_311" data-tooltip="Using the maven-publish Gradle plugin, you can publish your multiplatform library for the Android target by specifying Android variant names in the build script. The Kotlin Gradle plugin will generate publications automatically.">New default publishing setup for Android artifacts</a></p></li></ul><section class="chapter"><h3 id="ability-to-use-custom-cinterop-libraries-in-shared-native-code" data-toc="ability-to-use-custom-cinterop-libraries-in-shared-native-code">Ability to use custom cinterop libraries in shared native code</h3><p id="p5ebpv_312">Kotlin Multiplatform gives you an <a href="multiplatform-share-on-platforms.html#connect-platform-specific-libraries" id="p5ebpv_314" data-tooltip="To share more native code without being limited by platform-specific dependencies, use platform libraries, like Foundation, UIKit, and POSIX. These libraries are shipped with Kotlin/Native and available in shared source sets by default.">option</a> to use platform-dependent interop libraries in shared source sets. Before 1.5.30, this worked only with <a href="native-platform-libs.html" id="p5ebpv_315" data-tooltip="To provide access to native services of operating systems, the Kotlin/Native distribution includes a set of prebuilt libraries specific to each target. These are called platform libraries.">platform libraries</a> shipped with Kotlin/Native distribution. Starting from 1.5.30, you can use it with your custom <code class="code" id="p5ebpv_316">cinterop</code> libraries. To enable this feature, add the <code class="code" id="p5ebpv_317">kotlin.mpp.enableCInteropCommonization=true</code> property in your <code class="code" id="p5ebpv_318">gradle.properties</code>:</p><div class="code-block" data-lang="none">
kotlin.mpp.enableGranularSourceSetsMetadata=true
kotlin.native.enableDependencyPropagation=false
kotlin.mpp.enableCInteropCommonization=true
</div></section><section class="chapter"><h3 id="support-for-xcframeworks" data-toc="support-for-xcframeworks">Support for XCFrameworks</h3><p id="p5ebpv_319">All Kotlin Multiplatform projects can now have XCFrameworks as an output format. Apple introduced XCFrameworks as a replacement for universal (fat) frameworks. With the help of XCFrameworks you:</p><ul class="list _bullet" id="p5ebpv_320"><li class="list__item" id="p5ebpv_327"><p id="p5ebpv_329">Can gather logic for all the target platforms and architectures in a single bundle.</p></li><li class="list__item" id="p5ebpv_328"><p id="p5ebpv_330">Don't need to remove all unnecessary architectures before publishing the application to the App Store.</p></li></ul><p id="p5ebpv_321">XCFrameworks is useful if you want to use your Kotlin framework for devices and simulators on Apple M1.</p><p id="p5ebpv_322">To use XCFrameworks, update your <code class="code" id="p5ebpv_331">build.gradle(.kts)</code> script:</p><div class="tabs" id="p5ebpv_323" data-group="build-script" data-anchors="[p5ebpv_332,p5ebpv_333]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_332" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
import org.jetbrains.kotlin.gradle.plugin.mpp.apple.XCFramework

plugins {
    kotlin(&quot;multiplatform&quot;)
}

kotlin {
    val xcf = XCFramework()
  
    ios {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(this)
        }
    }
    watchos {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(this)
        }
    }
    tvos {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(this)
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_333" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
import org.jetbrains.kotlin.gradle.plugin.mpp.apple.XCFrameworkConfig

plugins {
    id 'org.jetbrains.kotlin.multiplatform'
}

kotlin {
    def xcf = new XCFrameworkConfig(project)

    ios {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(it)
        }
    }
    watchos {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(it)
        }
    }
    tvos {
        binaries.framework {
            baseName = &quot;shared&quot;
            xcf.add(it)
        }
    }
}
</div></div></div><p id="p5ebpv_324">When you declare XCFrameworks, these new Gradle tasks will be registered:</p><ul class="list _bullet" id="p5ebpv_325"><li class="list__item" id="p5ebpv_336"><p id="p5ebpv_339"><code class="code" id="p5ebpv_340">assembleXCFramework</code></p></li><li class="list__item" id="p5ebpv_337"><p id="p5ebpv_341"><code class="code" id="p5ebpv_342">assembleDebugXCFramework</code> (additionally debug artifact that <a href="native-ios-symbolication.html" id="p5ebpv_343" data-tooltip="Debugging an iOS application crash sometimes involves analyzing crash reports. More info about crash reports can be found in the Apple documentation.">contains dSYMs</a>)</p></li><li class="list__item" id="p5ebpv_338"><p id="p5ebpv_344"><code class="code" id="p5ebpv_345">assembleReleaseXCFramework</code></p></li></ul><p id="p5ebpv_326">Learn more about XCFrameworks in <a href="https://developer.apple.com/videos/play/wwdc2019/416/" id="p5ebpv_346" data-external="true" rel="noopener noreferrer" target="_blank">this WWDC video</a>.</p></section><section class="chapter"><h3 id="new-default-publishing-setup-for-android-artifacts" data-toc="new-default-publishing-setup-for-android-artifacts">New default publishing setup for Android artifacts</h3><p id="p5ebpv_347">Using the <code class="code" id="p5ebpv_351">maven-publish</code> Gradle plugin, you can <a href="multiplatform-publish-lib.html#publish-an-android-library" id="p5ebpv_352" data-tooltip="To publish an Android library, you need to provide additional configuration.">publish your multiplatform library for the Android target</a> by specifying <a href="https://developer.android.com/studio/build/build-variants" id="p5ebpv_353" data-external="true" rel="noopener noreferrer" target="_blank">Android variant</a> names in the build script. The Kotlin Gradle plugin will generate publications automatically.</p><p id="p5ebpv_348">Before 1.5.30, the generated publication <a href="https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html" id="p5ebpv_354" data-external="true" rel="noopener noreferrer" target="_blank">metadata</a> included the build type attributes for every published Android variant, making it compatible only with the same build type used by the library consumer. Kotlin 1.5.30 introduces a new default publishing setup:</p><ul class="list _bullet" id="p5ebpv_349"><li class="list__item" id="p5ebpv_355"><p id="p5ebpv_357">If all Android variants that the project publishes have the same build type attribute, then the published variants won't have the build type attribute and will be compatible with any build type.</p></li><li class="list__item" id="p5ebpv_356"><p id="p5ebpv_358">If the published variants have different build type attributes, then only those with the <code class="code" id="p5ebpv_359">release</code> value will be published without the build type attribute. This makes the release variants compatible with any build type on the consumer side, while non-release variants will only be compatible with the matching consumer build types.</p></li></ul><p id="p5ebpv_350">To opt-out and keep the build type attributes for all variants, you can set this Gradle property: <code class="code" id="p5ebpv_360">kotlin.android.buildTypeAttribute.keep=true</code>.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="p5ebpv_361">Two major improvements are coming to Kotlin/JS with 1.5.30:</p><ul class="list _bullet" id="p5ebpv_362"><li class="list__item" id="p5ebpv_365"><p id="p5ebpv_367"><a href="#js-ir-compiler-backend-reaches-beta" id="p5ebpv_368" data-tooltip="The IR-based compiler backend for Kotlin/JS, which was introduced in 1.4.0 in Alpha, has reached Beta.">JS IR compiler backend reaches Beta</a></p></li><li class="list__item" id="p5ebpv_366"><p id="p5ebpv_369"><a href="#better-debugging-experience-for-applications-with-the-kotlin-js-ir-backend" id="p5ebpv_370" data-tooltip="Kotlin 1.5.30 brings JavaScript source map generation for the Kotlin/JS IR backend. This will improve the Kotlin/JS debugging experience when the IR backend is enabled, with full debugging support that includes breakpoints, stepping, and readable stack traces with proper source…">Better debugging experience for applications with the Kotlin/JS IR backend</a></p></li></ul><section class="chapter"><h3 id="js-ir-compiler-backend-reaches-beta" data-toc="js-ir-compiler-backend-reaches-beta">JS IR compiler backend reaches Beta</h3><p id="p5ebpv_371">The <a href="whatsnew14.html#unified-backends-and-extensibility" id="p5ebpv_373" data-tooltip="In Kotlin, we have three backends that generate executables: Kotlin/JVM, Kotlin/JS, and Kotlin/Native. Kotlin/JVM and Kotlin/JS don't share much code since they were developed independently of each other. Kotlin/Native is based on a new infrastructure built around an intermediate…">IR-based compiler backend</a> for Kotlin/JS, which was introduced in 1.4.0 in <a href="components-stability.html" id="p5ebpv_374" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Alpha</a>, has reached Beta.</p><p id="p5ebpv_372">Previously, we published the <a href="js-ir-migration.html" id="p5ebpv_375" data-tooltip="We replaced the old Kotlin/JS compiler with the IR-based compiler in order to unify Kotlin's behavior on all platforms and to make it possible to implement new JS-specific optimizations, among other reasons. You can learn more about the internal differences between the two compilers…">migration guide for the JS IR backend</a> to help you migrate your projects to the new backend. Now we would like to present the <a href="https://plugins.jetbrains.com/plugin/17183-kotlin-js-inspection-pack/" id="p5ebpv_376" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin/JS Inspection Pack</a> IDE plugin, which displays the required changes directly in IntelliJ IDEA.</p></section><section class="chapter"><h3 id="better-debugging-experience-for-applications-with-the-kotlin-js-ir-backend" data-toc="better-debugging-experience-for-applications-with-the-kotlin-js-ir-backend">Better debugging experience for applications with the Kotlin/JS IR backend</h3><p id="p5ebpv_377">Kotlin 1.5.30 brings JavaScript source map generation for the Kotlin/JS IR backend. This will improve the Kotlin/JS debugging experience when the IR backend is enabled, with full debugging support that includes breakpoints, stepping, and readable stack traces with proper source references.</p><p id="p5ebpv_378">Learn how to <a href="js-debugging.html" id="p5ebpv_379" data-tooltip="JavaScript source maps provide mappings between the minified code produced by bundlers or minifiers and the actual source code a developer works with. This way, the source maps enable support for debugging the code during its execution.">debug Kotlin/JS in the browser or IntelliJ IDEA Ultimate</a>.</p></section></section><section class="chapter"><h2 id="gradle" data-toc="gradle">Gradle</h2><p id="p5ebpv_380">As a part of our mission to <a href="https://youtrack.jetbrains.com/issue/KT-45778" id="p5ebpv_385" data-external="true" rel="noopener noreferrer" target="_blank">improve the Kotlin Gradle plugin user experience</a>, we've implemented the following features:</p><ul class="list _bullet" id="p5ebpv_381"><li class="list__item" id="p5ebpv_386"><p id="p5ebpv_388"><a href="#support-for-java-toolchains" id="p5ebpv_389" data-tooltip="Gradle 6.7 introduced the &quot;Java toolchains support&quot; feature. Using this feature, you can:">Support for Java toolchains</a>, which includes an <a href="#ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface" id="p5ebpv_390" data-tooltip="All Kotlin tasks that support setting the JDK via kotlinOptions now implement the UsesKotlinJavaToolchain interface. To set the JDK home, put a path to your JDK and replace the &lt;JDK_VERSION&gt; placeholder:">ability to specify a JDK home with the <code class="code" id="p5ebpv_391">UsesKotlinJavaToolchain</code> interface for older Gradle versions</a></p></li><li class="list__item" id="p5ebpv_387"><p id="p5ebpv_392"><a href="#easier-way-to-explicitly-specify-kotlin-daemon-jvm-arguments" id="p5ebpv_393" data-tooltip="In Kotlin 1.5.30, there's a new logic for the Kotlin daemon's JVM arguments. Each of the options in the following list overrides the ones that came before it:">An easier way to explicitly specify the Kotlin daemon's JVM arguments</a></p></li></ul><section class="chapter"><h3 id="support-for-java-toolchains" data-toc="support-for-java-toolchains">Support for Java toolchains</h3><p id="p5ebpv_394">Gradle 6.7 introduced the <a href="https://docs.gradle.org/current/userguide/toolchains.html" id="p5ebpv_406" data-external="true" rel="noopener noreferrer" target="_blank">&quot;Java toolchains support&quot;</a> feature. Using this feature, you can:</p><ul class="list _bullet" id="p5ebpv_395"><li class="list__item" id="p5ebpv_407"><p id="p5ebpv_409">Run compilations, tests, and executables using JDKs and JREs that are different from the Gradle ones.</p></li><li class="list__item" id="p5ebpv_408"><p id="p5ebpv_410">Compile and test code with an unreleased language version.</p></li></ul><p id="p5ebpv_396">With toolchains support, Gradle can autodetect local JDKs and install missing JDKs that Gradle requires for the build. Now Gradle itself can run on any JDK and still reuse the <a href="gradle-compilation-and-caches.html#gradle-build-cache-support" id="p5ebpv_411" data-tooltip="The Kotlin plugin uses the Gradle build cache, which stores the build outputs for reuse in future builds.">build cache feature</a>.</p><p id="p5ebpv_397">The Kotlin Gradle plugin supports Java toolchains for Kotlin/JVM compilation tasks. A Java toolchain:</p><ul class="list _bullet" id="p5ebpv_398"><li class="list__item" id="p5ebpv_412"><p id="p5ebpv_415">Sets the <a href="gradle-compiler-options.html#attributes-specific-to-jvm" id="p5ebpv_418" data-tooltip="NameDescriptionPossible valuesDefault value javaParametersGenerate metadata for Java 1.8 reflection on method parameters false jvmTargetTarget version of the generated JVM bytecode&quot;1.8&quot;, &quot;9&quot;, &quot;10&quot;, ..., &quot;22&quot;, &quot;23&quot;. Also, see Types…"><code class="code" id="p5ebpv_419">jdkHome</code> option</a> available for JVM targets.</p><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_416"><p id="p5ebpv_420"><a href="https://youtrack.jetbrains.com/issue/KT-46541" id="p5ebpv_421" data-external="true" rel="noopener noreferrer" target="_blank">The ability to set the <code class="code" id="p5ebpv_422">jdkHome</code> option directly has been deprecated</a>.</p></aside><p id="p5ebpv_417"></p></li><li class="list__item" id="p5ebpv_413"><p id="p5ebpv_423">Sets the <a href="gradle-compiler-options.html#attributes-specific-to-jvm" id="p5ebpv_424" data-tooltip="NameDescriptionPossible valuesDefault value javaParametersGenerate metadata for Java 1.8 reflection on method parameters false jvmTargetTarget version of the generated JVM bytecode&quot;1.8&quot;, &quot;9&quot;, &quot;10&quot;, ..., &quot;22&quot;, &quot;23&quot;. Also, see Types…"><code class="code" id="p5ebpv_428">kotlinOptions.jvmTarget</code></a> to the toolchain's JDK version if the user didn't set the <code class="code" id="p5ebpv_425">jvmTarget</code> option explicitly. If the toolchain is not configured, the <code class="code" id="p5ebpv_426">jvmTarget</code> field uses the default value. Learn more about <a href="gradle-configure-project.html#check-for-jvm-target-compatibility-of-related-compile-tasks" id="p5ebpv_427" data-tooltip="In the build module, you may have related compile tasks, for example:">JVM target compatibility</a>.</p></li><li class="list__item" id="p5ebpv_414"><p id="p5ebpv_429">Affects which JDK <a href="kapt.html#run-kapt-tasks-in-parallel" id="p5ebpv_430" data-tooltip="To improve the speed of builds that use kapt, you can enable the Gradle Worker API for kapt tasks. Using the Worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time."><code class="code" id="p5ebpv_431">kapt</code> workers</a> are running on.</p></li></ul><p id="p5ebpv_399">Use the following code to set a toolchain. Replace the placeholder <code class="code" id="p5ebpv_432">&lt;MAJOR_JDK_VERSION&gt;</code> with the JDK version you would like to use:</p><div class="tabs" id="p5ebpv_400" data-group="build-script" data-anchors="[p5ebpv_433,p5ebpv_434]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_433" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    jvmToolchain {
        (this as JavaToolchainSpec).languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)) // &quot;8&quot;
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_434" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)) // &quot;8&quot;
    }
}
</div></div></div><p id="p5ebpv_401">Note that setting a toolchain via the <code class="code" id="p5ebpv_437">kotlin</code> extension will update the toolchain for Java compile tasks as well.</p><p id="p5ebpv_402">You can set a toolchain via the <code class="code" id="p5ebpv_438">java</code> extension, and Kotlin compilation tasks will use it:</p><div class="code-block" data-lang="kotlin">
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)) // &quot;8&quot;
    }
}
</div><p id="p5ebpv_404">For information about setting any JDK version for <code class="code" id="p5ebpv_439">KotlinCompile</code> tasks, look through the docs about <a href="gradle-configure-project.html#set-jdk-version-with-the-task-dsl" id="p5ebpv_440" data-tooltip="The Task DSL allows setting any JDK version for any task implementing the UsesKotlinJavaToolchain interface. At the moment, these tasks are KotlinCompile and KaptTask. If you want Gradle to search for the major JDK version, replace the &lt;MAJOR_JDK_VERSION&gt; placeholder in your…">setting the JDK version with the Task DSL</a>.</p><p id="p5ebpv_405">For Gradle versions from 6.1 to 6.6, <a href="#ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface" id="p5ebpv_441" data-tooltip="All Kotlin tasks that support setting the JDK via kotlinOptions now implement the UsesKotlinJavaToolchain interface. To set the JDK home, put a path to your JDK and replace the &lt;JDK_VERSION&gt; placeholder:">use the <code class="code" id="p5ebpv_442">UsesKotlinJavaToolchain</code> interface to set the JDK home</a>.</p></section><section class="chapter"><h3 id="ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface" data-toc="ability-to-specify-jdk-home-with-useskotlinjavatoolchain-interface">Ability to specify JDK home with UsesKotlinJavaToolchain interface</h3><p id="p5ebpv_443">All Kotlin tasks that support setting the JDK via <a href="gradle-compiler-options.html" id="p5ebpv_447" data-tooltip="Each release of Kotlin includes compilers for the supported targets: JVM, JavaScript, and native binaries for supported platforms."><code class="code" id="p5ebpv_450">kotlinOptions</code></a> now implement the <code class="code" id="p5ebpv_448">UsesKotlinJavaToolchain</code> interface. To set the JDK home, put a path to your JDK and replace the <code class="code" id="p5ebpv_449">&lt;JDK_VERSION&gt;</code> placeholder:</p><div class="tabs" id="p5ebpv_444" data-group="build-script" data-anchors="[p5ebpv_451,p5ebpv_452]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_451" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
project.tasks
    .withType&lt;UsesKotlinJavaToolchain&gt;()
    .configureEach {
        it.kotlinJavaToolchain.jdk.use(
            &quot;/path/to/local/jdk&quot;,
            JavaVersion.&lt;LOCAL_JDK_VERSION&gt;
        )
    }
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_452" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
project.tasks
    .withType(UsesKotlinJavaToolchain.class)
    .configureEach {
        it.kotlinJavaToolchain.jdk.use(
            '/path/to/local/jdk',
            JavaVersion.&lt;LOCAL_JDK_VERSION&gt;
        )
    }
</div></div></div><p id="p5ebpv_445">Use the <code class="code" id="p5ebpv_455">UsesKotlinJavaToolchain</code> interface for Gradle versions from 6.1 to 6.6. Starting from Gradle 6.7, use the <a href="#support-for-java-toolchains" id="p5ebpv_456" data-tooltip="Gradle 6.7 introduced the &quot;Java toolchains support&quot; feature. Using this feature, you can:">Java toolchains</a> instead.</p><p id="p5ebpv_446">When using this feature, note that <a href="kapt.html#run-kapt-tasks-in-parallel" id="p5ebpv_457" data-tooltip="To improve the speed of builds that use kapt, you can enable the Gradle Worker API for kapt tasks. Using the Worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time.">kapt task workers</a> will only use <a href="https://docs.gradle.org/current/userguide/worker_api.html#changing_the_isolation_mode" id="p5ebpv_458" data-external="true" rel="noopener noreferrer" target="_blank">process isolation mode</a>, and the <code class="code" id="p5ebpv_459">kapt.workers.isolation</code> property will be ignored.</p></section><section class="chapter"><h3 id="easier-way-to-explicitly-specify-kotlin-daemon-jvm-arguments" data-toc="easier-way-to-explicitly-specify-kotlin-daemon-jvm-arguments">Easier way to explicitly specify Kotlin daemon JVM arguments</h3><p id="p5ebpv_460">In Kotlin 1.5.30, there's a new logic for the Kotlin daemon's JVM arguments. Each of the options in the following list overrides the ones that came before it:</p><ul class="list _bullet" id="p5ebpv_461"><li class="list__item" id="p5ebpv_463"><p id="p5ebpv_468">If nothing is specified, the Kotlin daemon inherits arguments from the Gradle daemon (as before). For example, in the <code class="code" id="p5ebpv_470">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
org.gradle.jvmargs=-Xmx1500m -Xms=500m
</div></li><li class="list__item" id="p5ebpv_464"><p id="p5ebpv_471">If the Gradle daemon's JVM arguments have the <code class="code" id="p5ebpv_473">kotlin.daemon.jvm.options</code> system property, use it as before:</p><div class="code-block" data-lang="none">
org.gradle.jvmargs=-Dkotlin.daemon.jvm.options=-Xmx1500m -Xms=500m
</div></li><li class="list__item" id="p5ebpv_465"><p id="p5ebpv_474">You can add the<code class="code" id="p5ebpv_476">kotlin.daemon.jvmargs</code> property in the <code class="code" id="p5ebpv_477">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.daemon.jvmargs=-Xmx1500m -Xms=500m
</div></li><li class="list__item" id="p5ebpv_466"><p id="p5ebpv_478">You can specify arguments in the <code class="code" id="p5ebpv_480">kotlin</code> extension:</p><div class="tabs" id="p5ebpv_479" data-group="build-script" data-anchors="[p5ebpv_481,p5ebpv_482]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_481" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    kotlinDaemonJvmArgs = listOf(&quot;-Xmx486m&quot;, &quot;-Xms256m&quot;, &quot;-XX:+UseParallelGC&quot;)
}
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_482" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    kotlinDaemonJvmArgs = [&quot;-Xmx486m&quot;, &quot;-Xms256m&quot;, &quot;-XX:+UseParallelGC&quot;]
}
</div></div></div></li><li class="list__item" id="p5ebpv_467"><p id="p5ebpv_485">You can specify arguments for a specific task:</p><div class="tabs" id="p5ebpv_486" data-group="build-script" data-anchors="[p5ebpv_489,p5ebpv_490]"><div class="tabs__content" data-gtm="tab" id="p5ebpv_489" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
tasks
    .matching { it.name == &quot;compileKotlin&quot; &amp;&amp; it is CompileUsingKotlinDaemon }
    .configureEach {
        (this as CompileUsingKotlinDaemon).kotlinDaemonJvmArguments.set(listOf(&quot;-Xmx486m&quot;, &quot;-Xms256m&quot;, &quot;-XX:+UseParallelGC&quot;))
    }
</div></div><div class="tabs__content" data-gtm="tab" id="p5ebpv_490" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
tasks
    .matching {
        it.name == &quot;compileKotlin&quot; &amp;&amp; it instanceof CompileUsingKotlinDaemon
    }
    .configureEach {
        kotlinDaemonJvmArguments.set([&quot;-Xmx1g&quot;, &quot;-Xms512m&quot;])
    }
</div></div></div><aside class="prompt" data-type="note" data-title="" id="p5ebpv_487"><p id="p5ebpv_493">In this case a new Kotlin daemon instance can start on task execution. Learn more about <a href="gradle-compilation-and-caches.html#setting-kotlin-daemon-s-jvm-arguments" id="p5ebpv_494" data-tooltip="Each of the following ways to set arguments overrides the ones that came before it:">the Kotlin daemon's interactions with JVM arguments</a>.</p></aside><p id="p5ebpv_488"></p></li></ul><p id="p5ebpv_462">For more information about the Kotlin daemon, see <a href="gradle-compilation-and-caches.html#the-kotlin-daemon-and-how-to-use-it-with-gradle" id="p5ebpv_495" data-tooltip="The Kotlin daemon:">the Kotlin daemon and using it with Gradle</a>.</p></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><p id="p5ebpv_496">Kotlin 1.5.30 is bringing improvements to the standard library's <code class="code" id="p5ebpv_502">Duration</code> and <code class="code" id="p5ebpv_503">Regex</code> APIs:</p><ul class="list _bullet" id="p5ebpv_497"><li class="list__item" id="p5ebpv_504"><p id="p5ebpv_508"><a href="#changing-duration-tostring-output" id="p5ebpv_509" data-tooltip="The Duration API is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate hearing your feedback on it in YouTrack.">Changing <code class="code" id="p5ebpv_510">Duration.toString()</code> output</a></p></li><li class="list__item" id="p5ebpv_505"><p id="p5ebpv_511"><a href="#parsing-duration-from-string" id="p5ebpv_512" data-tooltip="The Duration API is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate hearing your feedback on it in this issue.">Parsing Duration from String</a></p></li><li class="list__item" id="p5ebpv_506"><p id="p5ebpv_513"><a href="#matching-with-regex-at-a-particular-position" id="p5ebpv_514" data-tooltip="Regex.matchAt() and Regex.matchesAt() functions are Experimental. They may be dropped or changed at any time. Use them only for evaluation purposes. We would appreciate hearing your feedback on them in YouTrack.">Matching with Regex at a particular position</a></p></li><li class="list__item" id="p5ebpv_507"><p id="p5ebpv_515"><a href="#splitting-regex-to-a-sequence" id="p5ebpv_516" data-tooltip="Regex.splitToSequence() and CharSequence.splitToSequence(Regex) functions are Experimental. They may be dropped or changed at any time. Use them only for evaluation purposes. We would appreciate hearing your feedback on them in YouTrack.">Splitting Regex to a sequence</a></p></li></ul><section class="chapter"><h3 id="changing-duration-tostring-output" data-toc="changing-duration-tostring-output">Changing Duration.toString() output</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_517"><p id="p5ebpv_524">The Duration API is <a href="components-stability.html" id="p5ebpv_525" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate hearing your feedback on it in <a href="https://youtrack.jetbrains.com/issues/KT" id="p5ebpv_526" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_518">Before Kotlin 1.5.30, the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-string.html" id="p5ebpv_527" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_532">Duration.toString()</code></a> function would return a string representation of its argument expressed in the unit that yielded the most compact and readable number value. From now on, it will return a string value expressed as a combination of numeric components, each in its own unit. Each component is a number followed by the unit's abbreviated name: <code class="code" id="p5ebpv_528">d</code>, <code class="code" id="p5ebpv_529">h</code>, <code class="code" id="p5ebpv_530">m</code>, <code class="code" id="p5ebpv_531">s</code>. For example:</p><div class="table-wrapper"><table class="wide" id="p5ebpv_519"><thead><tr class="ijRowHead" id="p5ebpv_533"><th id="p5ebpv_541"><p><span class="control" id="p5ebpv_544">Example of function call</span></p></th><th id="p5ebpv_542"><p><span class="control" id="p5ebpv_545">Previous output</span></p></th><th id="p5ebpv_543"><p><span class="control" id="p5ebpv_546">Current output</span></p></th></tr></thead><tbody><tr id="p5ebpv_534"><td id="p5ebpv_547"><p>Duration.days(45).toString()</p></td><td id="p5ebpv_548"><p><code class="code" id="p5ebpv_550">45.0d</code></p></td><td id="p5ebpv_549"><p><code class="code" id="p5ebpv_551">45d</code></p></td></tr><tr id="p5ebpv_535"><td id="p5ebpv_552"><p>Duration.days(1.5).toString()</p></td><td id="p5ebpv_553"><p><code class="code" id="p5ebpv_555">36.0h</code></p></td><td id="p5ebpv_554"><p><code class="code" id="p5ebpv_556">1d 12h</code></p></td></tr><tr id="p5ebpv_536"><td id="p5ebpv_557"><p>Duration.minutes(1230).toString()</p></td><td id="p5ebpv_558"><p><code class="code" id="p5ebpv_560">20.5h</code></p></td><td id="p5ebpv_559"><p><code class="code" id="p5ebpv_561">20h 30m</code></p></td></tr><tr id="p5ebpv_537"><td id="p5ebpv_562"><p>Duration.minutes(2415).toString()</p></td><td id="p5ebpv_563"><p><code class="code" id="p5ebpv_565">40.3h</code></p></td><td id="p5ebpv_564"><p><code class="code" id="p5ebpv_566">1d 16h 15m</code></p></td></tr><tr id="p5ebpv_538"><td id="p5ebpv_567"><p>Duration.minutes(920).toString()</p></td><td id="p5ebpv_568"><p><code class="code" id="p5ebpv_570">920m</code></p></td><td id="p5ebpv_569"><p><code class="code" id="p5ebpv_571">15h 20m</code></p></td></tr><tr id="p5ebpv_539"><td id="p5ebpv_572"><p>Duration.seconds(1.546).toString()</p></td><td id="p5ebpv_573"><p><code class="code" id="p5ebpv_575">1.55s</code></p></td><td id="p5ebpv_574"><p><code class="code" id="p5ebpv_576">1.546s</code></p></td></tr><tr id="p5ebpv_540"><td id="p5ebpv_577"><p>Duration.milliseconds(25.12).toString()</p></td><td id="p5ebpv_578"><p><code class="code" id="p5ebpv_580">25.1ms</code></p></td><td id="p5ebpv_579"><p><code class="code" id="p5ebpv_581">25.12ms</code></p></td></tr></tbody></table></div><p id="p5ebpv_520">The way negative durations are represented has also been changed. A negative duration is prefixed with a minus sign (<code class="code" id="p5ebpv_582">-</code>), and if it consists of multiple components, it is surrounded with parentheses: <code class="code" id="p5ebpv_583">-12m</code> and <code class="code" id="p5ebpv_584">-(1h 30m)</code>.</p><p id="p5ebpv_521">Note that small durations of less than one second are represented as a single number with one of the subsecond units. For example, <code class="code" id="p5ebpv_585">ms</code> (milliseconds), <code class="code" id="p5ebpv_586">us</code> (microseconds), or <code class="code" id="p5ebpv_587">ns</code> (nanoseconds): <code class="code" id="p5ebpv_588">140.884ms</code>, <code class="code" id="p5ebpv_589">500us</code>, <code class="code" id="p5ebpv_590">24ns</code>. Scientific notation is no longer used to represent them.</p><p id="p5ebpv_522">If you want to express duration in a single unit, use the overloaded <code class="code" id="p5ebpv_591">Duration.toString(unit, decimals)</code> function.</p><aside class="prompt" data-type="note" data-title="" id="p5ebpv_523"><p id="p5ebpv_592">We recommend using <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-iso-string.html" id="p5ebpv_593" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_597">Duration.toIsoString()</code></a> in certain cases, including serialization and interchange. <code class="code" id="p5ebpv_594">Duration.toIsoString()</code> uses the stricter <a href="https://www.iso.org/iso-8601-date-and-time-format.html" id="p5ebpv_595" data-external="true" rel="noopener noreferrer" target="_blank">ISO-8601</a> format instead of <code class="code" id="p5ebpv_596">Duration.toString()</code>.</p></aside></section><section class="chapter"><h3 id="parsing-duration-from-string" data-toc="parsing-duration-from-string">Parsing Duration from String</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_598"><p id="p5ebpv_605">The Duration API is <a href="components-stability.html" id="p5ebpv_606" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate hearing your feedback on it in <a href="https://github.com/Kotlin/KEEP/issues/190" id="p5ebpv_607" data-external="true" rel="noopener noreferrer" target="_blank">this issue</a>.</p></aside><p id="p5ebpv_599">In Kotlin 1.5.30, there are new functions in the Duration API:</p><ul class="list _bullet" id="p5ebpv_600"><li class="list__item" id="p5ebpv_608"><p id="p5ebpv_611"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/parse.html" id="p5ebpv_613" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_614">parse()</code></a>, which supports parsing the outputs of:</p><ul class="list _bullet" id="p5ebpv_612"><li class="list__item" id="p5ebpv_615"><p id="p5ebpv_618"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-string.html" id="p5ebpv_619" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_620">toString()</code></a>.</p></li><li class="list__item" id="p5ebpv_616"><p id="p5ebpv_621"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-string.html" id="p5ebpv_622" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_623">toString(unit, decimals)</code></a>.</p></li><li class="list__item" id="p5ebpv_617"><p id="p5ebpv_624"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/to-iso-string.html" id="p5ebpv_625" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_626">toIsoString()</code></a>.</p></li></ul></li><li class="list__item" id="p5ebpv_609"><p id="p5ebpv_627"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/parse-iso-string.html" id="p5ebpv_628" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_630">parseIsoString()</code></a>, which only parses from the format produced by <code class="code" id="p5ebpv_629">toIsoString()</code>.</p></li><li class="list__item" id="p5ebpv_610"><p id="p5ebpv_631"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/parse-or-null.html" id="p5ebpv_632" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_636">parseOrNull()</code></a> and <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/parse-iso-string-or-null.html" id="p5ebpv_633" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_637">parseIsoStringOrNull()</code></a>, which behave like the functions above but return <code class="code" id="p5ebpv_634">null</code> instead of throwing <code class="code" id="p5ebpv_635">IllegalArgumentException</code> on invalid duration formats.</p></li></ul><p id="p5ebpv_601">Here are some examples of <code class="code" id="p5ebpv_638">parse()</code> and <code class="code" id="p5ebpv_639">parseOrNull()</code> usages:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
import kotlin.time.Duration
import kotlin.time.ExperimentalTime

@ExperimentalTime
fun main() {
//sampleStart
    val isoFormatString = &quot;PT1H30M&quot;
    val defaultFormatString = &quot;1h 30m&quot;
    val singleUnitFormatString = &quot;1.5h&quot;
    val invalidFormatString = &quot;1 hour 30 minutes&quot;
    println(Duration.parse(isoFormatString)) // &quot;1h 30m&quot;
    println(Duration.parse(defaultFormatString)) // &quot;1h 30m&quot;
    println(Duration.parse(singleUnitFormatString)) // &quot;1h 30m&quot;
    //println(Duration.parse(invalidFormatString)) // throws exception
    println(Duration.parseOrNull(invalidFormatString)) // &quot;null&quot;
//sampleEnd
}
</div><p id="p5ebpv_603">And here are some examples of <code class="code" id="p5ebpv_640">parseIsoString()</code> and <code class="code" id="p5ebpv_641">parseIsoStringOrNull()</code> usages:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
import kotlin.time.Duration
import kotlin.time.ExperimentalTime

@ExperimentalTime
fun main() {
//sampleStart
    val isoFormatString = &quot;PT1H30M&quot;
    val defaultFormatString = &quot;1h 30m&quot;
    println(Duration.parseIsoString(isoFormatString)) // &quot;1h 30m&quot;
    //println(Duration.parseIsoString(defaultFormatString)) // throws exception
    println(Duration.parseIsoStringOrNull(defaultFormatString)) // &quot;null&quot;
//sampleEnd
}
</div></section><section class="chapter"><h3 id="matching-with-regex-at-a-particular-position" data-toc="matching-with-regex-at-a-particular-position">Matching with Regex at a particular position</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_642"><p id="p5ebpv_648"><code class="code" id="p5ebpv_649">Regex.matchAt()</code> and <code class="code" id="p5ebpv_650">Regex.matchesAt()</code> functions are <a href="components-stability.html" id="p5ebpv_651" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. They may be dropped or changed at any time. Use them only for evaluation purposes. We would appreciate hearing your feedback on them in <a href="https://youtrack.jetbrains.com/issue/KT-34021" id="p5ebpv_652" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_643">The new <code class="code" id="p5ebpv_653">Regex.matchAt()</code> and <code class="code" id="p5ebpv_654">Regex.matchesAt()</code> functions provide a way to check whether a regex has an exact match at a particular position in a <code class="code" id="p5ebpv_655">String</code> or <code class="code" id="p5ebpv_656">CharSequence</code>.</p><p id="p5ebpv_644"><code class="code" id="p5ebpv_657">matchesAt()</code> returns a boolean result:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
fun main(){
//sampleStart
    val releaseText = &quot;Kotlin 1.5.30 is released!&quot;
    // regular expression: one digit, dot, one digit, dot, one or more digits
    val versionRegex = &quot;\\d[.]\\d[.]\\d+&quot;.toRegex()
    println(versionRegex.matchesAt(releaseText, 0)) // &quot;false&quot;
    println(versionRegex.matchesAt(releaseText, 7)) // &quot;true&quot;
//sampleEnd
}
</div><p id="p5ebpv_646"><code class="code" id="p5ebpv_658">matchAt()</code> returns the match if one is found or <code class="code" id="p5ebpv_659">null</code> if one isn't:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
fun main(){
//sampleStart
    val releaseText = &quot;Kotlin 1.5.30 is released!&quot;
    val versionRegex = &quot;\\d[.]\\d[.]\\d+&quot;.toRegex()
    println(versionRegex.matchAt(releaseText, 0)) // &quot;null&quot;
    println(versionRegex.matchAt(releaseText, 7)?.value) // &quot;1.5.30&quot;
//sampleEnd
}
</div></section><section class="chapter"><h3 id="splitting-regex-to-a-sequence" data-toc="splitting-regex-to-a-sequence">Splitting Regex to a sequence</h3><aside class="prompt" data-type="warning" data-title="" id="p5ebpv_660"><p id="p5ebpv_665"><code class="code" id="p5ebpv_666">Regex.splitToSequence()</code> and <code class="code" id="p5ebpv_667">CharSequence.splitToSequence(Regex)</code> functions are <a href="components-stability.html" id="p5ebpv_668" data-tooltip="The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as Stable, which means that they were evolved in a…">Experimental</a>. They may be dropped or changed at any time. Use them only for evaluation purposes. We would appreciate hearing your feedback on them in <a href="https://youtrack.jetbrains.com/issue/KT-23351" id="p5ebpv_669" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="p5ebpv_661">The new <code class="code" id="p5ebpv_670">Regex.splitToSequence()</code> function is a lazy counterpart of <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/split.html" id="p5ebpv_671" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="p5ebpv_673">split()</code></a>. It splits the string around matches of the given regex, but it returns the result as a <a href="sequences.html" id="p5ebpv_672" data-tooltip="Along with collections, the Kotlin standard library contains another type – sequences (Sequence&lt;T&gt;). Unlike collections, sequences don't contain elements, they produce them while iterating. Sequences offer the same functions as Iterable but implement another approach to…">Sequence</a> so that all operations on this result are executed lazily.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5">
fun main(){
//sampleStart
    val colorsText = &quot;green, red , brown&amp;blue, orange, pink&amp;green&quot;
    val regex = &quot;[,\\s]+&quot;.toRegex()
    val mixedColor = regex.splitToSequence(colorsText)
        .onEach { println(it) }
        .firstOrNull { it.contains('&amp;') }
    println(mixedColor) // &quot;brown&amp;blue&quot;
//sampleEnd
}
</div><p id="p5ebpv_663">A similar function was also added to <code class="code" id="p5ebpv_674">CharSequence</code>:</p><div class="code-block" data-lang="kotlin">
    val mixedColor = colorsText.splitToSequence(regex)
</div></section></section><section class="chapter"><h2 id="serialization-1-3-0-rc" data-toc="serialization-1-3-0-rc">Serialization 1.3.0-RC</h2><p id="p5ebpv_675"><code class="code" id="p5ebpv_678">kotlinx.serialization</code> <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.3.0-RC" id="p5ebpv_679" data-external="true" rel="noopener noreferrer" target="_blank">1.3.0-RC</a> is here with new JSON serialization capabilities:</p><ul class="list _bullet" id="p5ebpv_676"><li class="list__item" id="p5ebpv_680"><p id="p5ebpv_684">Java IO streams serialization</p></li><li class="list__item" id="p5ebpv_681"><p id="p5ebpv_685">Property-level control over default values</p></li><li class="list__item" id="p5ebpv_682"><p id="p5ebpv_686">An option to exclude null values from serialization</p></li><li class="list__item" id="p5ebpv_683"><p id="p5ebpv_687">Custom class discriminators in polymorphic serialization</p></li></ul><p id="p5ebpv_677">Learn more in the <a href="https://github.com/Kotlin/kotlinx.serialization/releases/tag/v1.3.0-RC" id="p5ebpv_688" data-external="true" rel="noopener noreferrer" target="_blank">changelog</a>.</p></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew16.html" class="navigation-links__prev">What's new in Kotlin 1.6.0</a><a href="whatsnew1520.html" class="navigation-links__next">What's new in Kotlin 1.5.20</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>