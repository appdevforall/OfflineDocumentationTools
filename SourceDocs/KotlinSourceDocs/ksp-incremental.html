<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:01.256895764"><title>Incremental processing | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"aggregating-vs-isolating","level":0,"title":"Aggregating vs Isolating","anchor":"#aggregating-vs-isolating"},{"id":"how-it-is-implemented","level":1,"title":"How it is implemented","anchor":"#how-it-is-implemented"},{"id":"example-1","level":0,"title":"Example 1","anchor":"#example-1"},{"id":"example-2","level":0,"title":"Example 2","anchor":"#example-2"},{"id":"how-file-dirtiness-is-determined","level":0,"title":"How file dirtiness is determined","anchor":"#how-file-dirtiness-is-determined"},{"id":"reporting-bugs","level":0,"title":"Reporting bugs","anchor":"#reporting-bugs"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Incremental processing | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/ksp-incremental.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Incremental processing | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/ksp-incremental.html#webpage",
    "url": "writerside-documentation/ksp-incremental.html",
    "name": "Incremental processing | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="ksp-incremental" data-main-title="Incremental processing" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Compiler and plugins///Kotlin Symbol Processing API"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ksp-incremental" id="ksp-incremental.md">Incremental processing</h1><p id="ylad2o_2">Incremental processing is a processing technique that avoids re-processing of sources as much as possible. The primary goal of incremental processing is to reduce the turn-around time of a typical change-compile-test cycle. For general information, see Wikipedia's article on <a href="https://en.wikipedia.org/wiki/Incremental_computing" id="ylad2o_12" data-external="true" rel="noopener noreferrer" target="_blank">incremental computing</a>.</p><p id="ylad2o_3">To determine which sources are <span class="emphasis" id="ylad2o_13">dirty</span> (those that need to be reprocessed), KSP needs processors' help to identify which input sources correspond to which generated outputs. To help with this often cumbersome and error-prone process, KSP is designed to require only a minimal set of <span class="emphasis" id="ylad2o_14">root sources</span> that processors use as starting points to navigate the code structure. In other words, a processor needs to associate an output with the sources of the corresponding <code class="code" id="ylad2o_15">KSNode</code> if the <code class="code" id="ylad2o_16">KSNode</code> is obtained from any of the following:</p><ul class="list _bullet" id="ylad2o_4"><li class="list__item" id="ylad2o_17"><p id="ylad2o_21"><code class="code" id="ylad2o_22">Resolver.getAllFiles</code></p></li><li class="list__item" id="ylad2o_18"><p id="ylad2o_23"><code class="code" id="ylad2o_24">Resolver.getSymbolsWithAnnotation</code></p></li><li class="list__item" id="ylad2o_19"><p id="ylad2o_25"><code class="code" id="ylad2o_26">Resolver.getClassDeclarationByName</code></p></li><li class="list__item" id="ylad2o_20"><p id="ylad2o_27"><code class="code" id="ylad2o_28">Resolver.getDeclarationsFromPackage</code></p></li></ul><p id="ylad2o_5">Incremental processing is currently enabled by default. To disable it, set the Gradle property <code class="code" id="ylad2o_29">ksp.incremental=false</code>. To enable logs that dump the dirty set according to dependencies and outputs, use <code class="code" id="ylad2o_30">ksp.incremental.log=true</code>. You can find these log files in the <code class="code" id="ylad2o_31">build</code> output directory with a <code class="code" id="ylad2o_32">.log</code> file extension.</p><p id="ylad2o_6">On the JVM, classpath changes, as well as Kotlin and Java source changes, are tracked by default. To track only Kotlin and Java source changes, disable classpath tracking by setting the <code class="code" id="ylad2o_33">ksp.incremental.intermodule=false</code> Gradle property.</p><section class="chapter"><h2 id="aggregating-vs-isolating" data-toc="aggregating-vs-isolating">Aggregating vs Isolating</h2><p id="ylad2o_34">Similar to the concepts in <a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_annotation_processing" id="ylad2o_43" data-external="true" rel="noopener noreferrer" target="_blank">Gradle annotation processing</a>, KSP supports both <span class="emphasis" id="ylad2o_44">aggregating</span> and <span class="emphasis" id="ylad2o_45">isolating</span> modes. Note that unlike Gradle annotation processing, KSP categorizes each output as either aggregating or isolating, rather than the entire processor.</p><p id="ylad2o_35">An aggregating output can potentially be affected by any input changes, except removing files that don't affect other files. This means that any input change results in a rebuild of all aggregating outputs, which in turn means reprocessing of all corresponding registered, new, and modified source files.</p><p id="ylad2o_36">As an example, an output that collects all symbols with a particular annotation is considered an aggregating output.</p><p id="ylad2o_37">An isolating output depends only on its specified sources. Changes to other sources do not affect an isolating output. Note that unlike Gradle annotation processing, you can define multiple source files for a given output.</p><p id="ylad2o_38">As an example, a generated class that is dedicated to an interface it implements is considered isolating.</p><p id="ylad2o_39">To summarize, if an output might depend on new or any changed sources, it is considered aggregating. Otherwise, the output is isolating.</p><p id="ylad2o_40">Here's a summary for readers familiar with Java annotation processing:</p><ul class="list _bullet" id="ylad2o_41"><li class="list__item" id="ylad2o_46"><p id="ylad2o_48">In an isolating Java annotation processor, all the outputs are isolating in KSP.</p></li><li class="list__item" id="ylad2o_47"><p id="ylad2o_49">In an aggregating Java annotation processor, some outputs can be isolating and some can be aggregating in KSP.</p></li></ul><section class="chapter"><h3 id="how-it-is-implemented" data-toc="how-it-is-implemented">How it is implemented</h3><p id="ylad2o_50">The dependencies are calculated by the association of input and output files, instead of annotations. This is a many-to-many relation.</p><p id="ylad2o_51">The dirtiness propagation rules due to input-output associations are:</p><ol class="list _decimal" id="ylad2o_52" type="1"><li class="list__item" id="ylad2o_55"><p id="ylad2o_58">If an input file is changed, it will always be reprocessed.</p></li><li class="list__item" id="ylad2o_56"><p id="ylad2o_59">If an input file is changed, and it is associated with an output, then all other input files associated with the same output will also be reprocessed. This is transitive, namely, invalidation happens repeatedly until there is no new dirty file.</p></li><li class="list__item" id="ylad2o_57"><p id="ylad2o_60">All input files that are associated with one or more aggregating outputs will be reprocessed. In other words, if an input file isn't associated with any aggregating outputs, it won't be reprocessed (unless it meets 1. or 2. in the above).</p></li></ol><p id="ylad2o_53">Reasons are:</p><ol class="list _decimal" id="ylad2o_54" type="1"><li class="list__item" id="ylad2o_61"><p id="ylad2o_64">If an input is changed, new information can be introduced and therefore processors need to run again with the input.</p></li><li class="list__item" id="ylad2o_62"><p id="ylad2o_65">An output is made out of a set of inputs. Processors may need all the inputs to regenerate the output.</p></li><li class="list__item" id="ylad2o_63"><p id="ylad2o_66"><code class="code" id="ylad2o_67">aggregating=true</code> means that an output may potentially depend on new information, which can come from either new files, or changed, existing files. <code class="code" id="ylad2o_68">aggregating=false</code> means that processor is sure that the information only comes from certain input files and never from other or new files.</p></li></ol></section></section><section class="chapter"><h2 id="example-1" data-toc="example-1">Example 1</h2><p id="ylad2o_69">A processor generates <code class="code" id="ylad2o_71">outputForA</code> after reading class <code class="code" id="ylad2o_72">A</code> in <code class="code" id="ylad2o_73">A.kt</code> and class <code class="code" id="ylad2o_74">B</code> in <code class="code" id="ylad2o_75">B.kt</code>, where <code class="code" id="ylad2o_76">A</code> extends <code class="code" id="ylad2o_77">B</code>. The processor got <code class="code" id="ylad2o_78">A</code> by <code class="code" id="ylad2o_79">Resolver.getSymbolsWithAnnotation</code> and then got <code class="code" id="ylad2o_80">B</code> by <code class="code" id="ylad2o_81">KSClassDeclaration.superTypes</code> from <code class="code" id="ylad2o_82">A</code>. Because the inclusion of <code class="code" id="ylad2o_83">B</code> is due to <code class="code" id="ylad2o_84">A</code>, <code class="code" id="ylad2o_85">B.kt</code> doesn't need to be specified in <code class="code" id="ylad2o_86">dependencies</code> for <code class="code" id="ylad2o_87">outputForA</code>. You can still specify <code class="code" id="ylad2o_88">B.kt</code> in this case, but it is unnecessary.</p><div class="code-block" data-lang="kotlin">
// A.kt
@Interesting
class A : B()

// B.kt
open class B

// Example1Processor.kt
class Example1Processor : SymbolProcessor {
    override fun process(resolver: Resolver) {
        val declA = resolver.getSymbolsWithAnnotation(&quot;Interesting&quot;).first() as KSClassDeclaration
        val declB = declA.superTypes.first().resolve().declaration
        // B.kt isn't required, because it can be deduced as a dependency by KSP
        val dependencies = Dependencies(aggregating = true, declA.containingFile!!)
        // outputForA.kt
        val outputName = &quot;outputFor${declA.simpleName.asString()}&quot;
        // outputForA depends on A.kt and B.kt
        val output = codeGenerator.createNewFile(dependencies, &quot;com.example&quot;, outputName, &quot;kt&quot;)
        output.write(&quot;// $declA : $declB\n&quot;.toByteArray())
        output.close()
    }
    // ...
}
</div></section><section class="chapter"><h2 id="example-2" data-toc="example-2">Example 2</h2><p id="ylad2o_89">Consider that a processor generates <code class="code" id="ylad2o_96">outputA</code> after reading <code class="code" id="ylad2o_97">sourceA</code> and <code class="code" id="ylad2o_98">outputB</code> after reading <code class="code" id="ylad2o_99">sourceB</code>.</p><p id="ylad2o_90">When <code class="code" id="ylad2o_100">sourceA</code> is changed:</p><ul class="list _bullet" id="ylad2o_91"><li class="list__item" id="ylad2o_101"><p id="ylad2o_103">If <code class="code" id="ylad2o_104">outputB</code> is aggregating, both <code class="code" id="ylad2o_105">sourceA</code> and <code class="code" id="ylad2o_106">sourceB</code> are reprocessed.</p></li><li class="list__item" id="ylad2o_102"><p id="ylad2o_107">If <code class="code" id="ylad2o_108">outputB</code> is isolating, only <code class="code" id="ylad2o_109">sourceA</code> is reprocessed.</p></li></ul><p id="ylad2o_92">When <code class="code" id="ylad2o_110">sourceC</code> is added:</p><ul class="list _bullet" id="ylad2o_93"><li class="list__item" id="ylad2o_111"><p id="ylad2o_113">If <code class="code" id="ylad2o_114">outputB</code> is aggregating, both <code class="code" id="ylad2o_115">sourceC</code> and <code class="code" id="ylad2o_116">sourceB</code> are reprocessed.</p></li><li class="list__item" id="ylad2o_112"><p id="ylad2o_117">If <code class="code" id="ylad2o_118">outputB</code> is isolating, only <code class="code" id="ylad2o_119">sourceC</code> is reprocessed.</p></li></ul><p id="ylad2o_94">When <code class="code" id="ylad2o_120">sourceA</code> is removed, nothing needs to be reprocessed.</p><p id="ylad2o_95">When <code class="code" id="ylad2o_121">sourceB</code> is removed, nothing needs to be reprocessed.</p></section><section class="chapter"><h2 id="how-file-dirtiness-is-determined" data-toc="how-file-dirtiness-is-determined">How file dirtiness is determined</h2><p id="ylad2o_122">A dirty file is either directly <span class="emphasis" id="ylad2o_125">changed</span> by users or indirectly <span class="emphasis" id="ylad2o_126">affected</span> by other dirty files. KSP propagates dirtiness in two steps:</p><ul class="list _bullet" id="ylad2o_123"><li class="list__item" id="ylad2o_127"><p id="ylad2o_129">Propagation by <span class="emphasis" id="ylad2o_130">resolution tracing</span>: Resolving a type reference (implicitly or explicitly) is the only way to navigate from one file to another. When a type reference is resolved by a processor, a changed or affected file that contains a change that may potentially affect the resolution result will affect the file containing that reference.</p></li><li class="list__item" id="ylad2o_128"><p id="ylad2o_131">Propagation by <span class="emphasis" id="ylad2o_132">input-output correspondence</span>: If a source file is changed or affected, all other source files having some output in common with that file are affected.</p></li></ul><p id="ylad2o_124">Note that both of them are transitive and the second forms equivalence classes.</p></section><section class="chapter"><h2 id="reporting-bugs" data-toc="reporting-bugs">Reporting bugs</h2><p id="ylad2o_133">To report a bug, please set Gradle properties <code class="code" id="ylad2o_138">ksp.incremental=true</code> and <code class="code" id="ylad2o_139">ksp.incremental.log=true</code>, and perform a clean build. This build produces two log files:</p><ul class="list _bullet" id="ylad2o_134"><li class="list__item" id="ylad2o_140"><p id="ylad2o_142"><code class="code" id="ylad2o_143">build/kspCaches/&lt;source set&gt;/logs/kspDirtySet.log</code></p></li><li class="list__item" id="ylad2o_141"><p id="ylad2o_144"><code class="code" id="ylad2o_145">build/kspCaches/&lt;source set&gt;/logs/kspSourceToOutputs.log</code></p></li></ul><p id="ylad2o_135">You can then run successive incremental builds, which will generate two additional log files:</p><ul class="list _bullet" id="ylad2o_136"><li class="list__item" id="ylad2o_146"><p id="ylad2o_148"><code class="code" id="ylad2o_149">build/kspCaches/&lt;source set&gt;/logs/kspDirtySetByDeps.log</code></p></li><li class="list__item" id="ylad2o_147"><p id="ylad2o_150"><code class="code" id="ylad2o_151">build/kspCaches/&lt;source set&gt;/logs/kspDirtySetByOutputs.log</code></p></li></ul><p id="ylad2o_137">These logs contain file names of sources and outputs, plus the timestamps of the builds.</p></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ksp-reference.html" class="navigation-links__prev">Java annotation processing to KSP reference</a><a href="ksp-multi-round.html" class="navigation-links__next">Multiple round processing</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>