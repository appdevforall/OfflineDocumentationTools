<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-04-23T13:00:00.432116958"><title>Comparison to Java | Kotlin</title><script type="application/json" id="virtual-toc-data">[{"id":"some-java-issues-addressed-in-kotlin","level":0,"title":"Some Java issues addressed in Kotlin","anchor":"#some-java-issues-addressed-in-kotlin"},{"id":"what-java-has-that-kotlin-does-not","level":0,"title":"What Java has that Kotlin does not","anchor":"#what-java-has-that-kotlin-does-not"},{"id":"what-kotlin-has-that-java-does-not","level":0,"title":"What Kotlin has that Java does not","anchor":"#what-kotlin-has-that-java-does-not"},{"id":"what-s-next","level":0,"title":"What\u0027s next?","anchor":"#what-s-next"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="frontend/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" type="image/png" sizes="32x32" href="writerside_32.png"><link rel="icon" type="image/png" sizes="64x64" href="writerside_64.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Comparison to Java | Kotlin"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/comparison-to-java.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Comparison to Java | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/comparison-to-java.html#webpage",
    "url": "writerside-documentation/comparison-to-java.html",
    "name": "Comparison to Java | Kotlin",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --></head><body data-id="comparison-to-java" data-main-title="Comparison to Java" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///JVM"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="comparison-to-java" id="comparison-to-java.md">Comparison to Java</h1><section class="chapter"><h2 id="some-java-issues-addressed-in-kotlin" data-toc="some-java-issues-addressed-in-kotlin">Some Java issues addressed in Kotlin</h2><p id="pth1h1_6">Kotlin fixes a series of issues that Java suffers from:</p><ul class="list _bullet" id="pth1h1_7"><li class="list__item" id="pth1h1_8"><p id="pth1h1_15">Null references are <a href="null-safety.html" id="pth1h1_16" data-tooltip="Null safety is a Kotlin feature designed to significantly reduce the risk of null references, also known as The Billion-Dollar Mistake.">controlled by the type system</a>.</p></li><li class="list__item" id="pth1h1_9"><p id="pth1h1_17"><a href="java-interop.html#java-generics-in-kotlin" id="pth1h1_18" data-tooltip="Kotlin's generics are a little different from Java's (see Generics). When importing Java types to Kotlin, the following conversions are done:">No raw types</a></p></li><li class="list__item" id="pth1h1_10"><p id="pth1h1_19">Arrays in Kotlin are <a href="arrays.html" id="pth1h1_20" data-tooltip="An array is a data structure that holds a fixed number of values of the same type or its subtypes. The most common type of array in Kotlin is the object-type array, represented by the Array class.">invariant</a></p></li><li class="list__item" id="pth1h1_11"><p id="pth1h1_21">Kotlin has proper <a href="lambdas.html#function-types" id="pth1h1_22" data-tooltip="Kotlin uses function types, such as (Int) -&gt; String, for declarations that deal with functions: val onClick: () -&gt; Unit = ....">function types</a>, as opposed to Java's SAM-conversions</p></li><li class="list__item" id="pth1h1_12"><p id="pth1h1_23"><a href="generics.html#use-site-variance-type-projections" id="pth1h1_24" data-tooltip="It is very easy to declare a type parameter T as out and avoid trouble with subtyping on the use site, but some classes can't actually be restricted to only return T's! A good example of this is Array:">Use-site variance</a> without wildcards</p></li><li class="list__item" id="pth1h1_13"><p id="pth1h1_25">Kotlin does not have checked <a href="exceptions.html" id="pth1h1_26" data-tooltip="Exceptions help your code run more predictably, even when runtime errors occur that could disrupt program execution. Kotlin treats all exceptions as unchecked by default. Unchecked exceptions simplify the exception handling process: you can catch exceptions, but you don't need to…">exceptions</a></p></li><li class="list__item" id="pth1h1_14"><p id="pth1h1_27"><a href="collections-overview.html" id="pth1h1_28" data-tooltip="The Kotlin Standard Library provides a comprehensive set of tools for managing collections – groups of a variable number of items (possibly zero) that are significant to the problem being solved and are commonly operated on.">Separate interfaces for read-only and mutable collections</a></p></li></ul></section><section class="chapter"><h2 id="what-java-has-that-kotlin-does-not" data-toc="what-java-has-that-kotlin-does-not">What Java has that Kotlin does not</h2><ul class="list _bullet" id="pth1h1_29"><li class="list__item" id="pth1h1_30"><p id="pth1h1_38"><a href="exceptions.html" id="pth1h1_39" data-tooltip="Exceptions help your code run more predictably, even when runtime errors occur that could disrupt program execution. Kotlin treats all exceptions as unchecked by default. Unchecked exceptions simplify the exception handling process: you can catch exceptions, but you don't need to…">Checked exceptions</a></p></li><li class="list__item" id="pth1h1_31"><p id="pth1h1_40"><a href="basic-types.html" id="pth1h1_41" data-tooltip="In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable. While certain types have an optimized internal representation as primitive values at runtime (such as numbers, characters, booleans and others), they appear and behave…">Primitive types</a> that are not classes. The byte-code uses primitives where possible, but they are not explicitly available.</p></li><li class="list__item" id="pth1h1_32"><p id="pth1h1_42"><a href="classes.html" id="pth1h1_43" data-tooltip="Classes in Kotlin are declared using the keyword class:">Static members</a> are replaced with <a href="object-declarations.html#companion-objects" id="pth1h1_44" data-tooltip="Companion objects allow you to define class-level functions and properties. This makes it easy to create factory methods, hold constants, and access shared utilities.">companion objects</a>, <a href="functions.html" id="pth1h1_45" data-tooltip="Kotlin functions are declared using the fun keyword:">top-level functions</a>, <a href="extensions.html#extension-functions" id="pth1h1_46" data-tooltip="To declare an extension function, prefix its name with a receiver type, which refers to the type being extended. The following adds a swap function to MutableList&lt;Int&gt;:">extension functions</a>, or <a href="java-to-kotlin-interop.html#static-methods" id="pth1h1_47" data-tooltip="As mentioned above, Kotlin represents package-level functions as static methods. Kotlin can also generate static methods for functions defined in named objects or companion objects if you annotate those functions as @JvmStatic. If you use this annotation, the compiler will generate…">@JvmStatic</a>.</p></li><li class="list__item" id="pth1h1_33"><p id="pth1h1_48"><a href="generics.html" id="pth1h1_49" data-tooltip="Classes in Kotlin can have type parameters, just like in Java:">Wildcard-types</a> are replaced with <a href="generics.html#declaration-site-variance" id="pth1h1_50" data-tooltip="Let's suppose that there is a generic interface Source&lt;T&gt; that does not have any methods that take T as a parameter, only methods that return T:">declaration-site variance</a> and <a href="generics.html#type-projections" id="pth1h1_51" data-tooltip="It is very easy to declare a type parameter T as out and avoid trouble with subtyping on the use site, but some classes can't actually be restricted to only return T's! A good example of this is Array:">type projections</a>.</p></li><li class="list__item" id="pth1h1_34"><p id="pth1h1_52"><a href="control-flow.html#if-expression" id="pth1h1_53" data-tooltip="In Kotlin, if is an expression: it returns a value. Therefore, there is no ternary operator (condition ? then : else) because ordinary if works fine in this role.">Ternary-operator <code class="code" id="pth1h1_55">a ? b : c</code></a> is replaced with <a href="control-flow.html#if-expression" id="pth1h1_54" data-tooltip="In Kotlin, if is an expression: it returns a value. Therefore, there is no ternary operator (condition ? then : else) because ordinary if works fine in this role.">if expression</a>.</p></li><li class="list__item" id="pth1h1_35"><p id="pth1h1_56"><a href="https://openjdk.org/jeps/395" id="pth1h1_57" data-external="true" rel="noopener noreferrer" target="_blank">Records</a></p></li><li class="list__item" id="pth1h1_36"><p id="pth1h1_58"><a href="https://openjdk.org/projects/amber/design-notes/patterns/pattern-matching-for-java" id="pth1h1_59" data-external="true" rel="noopener noreferrer" target="_blank">Pattern Matching</a></p></li><li class="list__item" id="pth1h1_37"><p id="pth1h1_60">package-private <a href="visibility-modifiers.html" id="pth1h1_61" data-tooltip="Classes, objects, interfaces, constructors, and functions, as well as properties and their setters, can have visibility modifiers. Getters always have the same visibility as their properties.">visibility modifier</a></p></li></ul></section><section class="chapter"><h2 id="what-kotlin-has-that-java-does-not" data-toc="what-kotlin-has-that-java-does-not">What Kotlin has that Java does not</h2><ul class="list _bullet" id="pth1h1_62"><li class="list__item" id="pth1h1_63"><p id="pth1h1_85"><a href="lambdas.html" id="pth1h1_86" data-tooltip="Kotlin functions are first-class, which means they can be stored in variables and data structures, and can be passed as arguments to and returned from other higher-order functions. You can perform any operations on functions that are possible for other non-function values.">Lambda expressions</a> + <a href="inline-functions.html" id="pth1h1_87" data-tooltip="Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure. A closure is a scope of variables that can be accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls…">Inline functions</a> = performant custom control structures</p></li><li class="list__item" id="pth1h1_64"><p id="pth1h1_88"><a href="extensions.html" id="pth1h1_89" data-tooltip="Kotlin provides the ability to extend a class or an interface with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called extensions.">Extension functions</a></p></li><li class="list__item" id="pth1h1_65"><p id="pth1h1_90"><a href="null-safety.html" id="pth1h1_91" data-tooltip="Null safety is a Kotlin feature designed to significantly reduce the risk of null references, also known as The Billion-Dollar Mistake.">Null-safety</a></p></li><li class="list__item" id="pth1h1_66"><p id="pth1h1_92"><a href="typecasts.html" id="pth1h1_93" data-tooltip="In Kotlin, you can perform type checks to check the type of an object at runtime. Type casts enable you to convert objects to a different type.">Smart casts</a> (<span class="control" id="pth1h1_94">Java 16</span>: <a href="https://openjdk.org/jeps/394" id="pth1h1_95" data-external="true" rel="noopener noreferrer" target="_blank">Pattern Matching for instanceof</a>)</p></li><li class="list__item" id="pth1h1_67"><p id="pth1h1_96"><a href="strings.html" id="pth1h1_97" data-tooltip="Strings in Kotlin are represented by the type String.">String templates</a> (<span class="control" id="pth1h1_98">Java 21</span>: <a href="https://openjdk.org/jeps/430" id="pth1h1_99" data-external="true" rel="noopener noreferrer" target="_blank">String Templates (Preview)</a>)</p></li><li class="list__item" id="pth1h1_68"><p id="pth1h1_100"><a href="properties.html" id="pth1h1_101" data-tooltip="Properties in Kotlin classes can be declared either as mutable, using the var keyword, or as read-only, using the val keyword.">Properties</a></p></li><li class="list__item" id="pth1h1_69"><p id="pth1h1_102"><a href="classes.html" id="pth1h1_103" data-tooltip="Classes in Kotlin are declared using the keyword class:">Primary constructors</a></p></li><li class="list__item" id="pth1h1_70"><p id="pth1h1_104"><a href="delegation.html" id="pth1h1_105" data-tooltip="The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code.">First-class delegation</a></p></li><li class="list__item" id="pth1h1_71"><p id="pth1h1_106"><a href="basic-types.html" id="pth1h1_107" data-tooltip="In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable. While certain types have an optimized internal representation as primitive values at runtime (such as numbers, characters, booleans and others), they appear and behave…">Type inference for variable and property types</a> (<span class="control" id="pth1h1_108">Java 10</span>: <a href="https://openjdk.org/jeps/286" id="pth1h1_109" data-external="true" rel="noopener noreferrer" target="_blank">Local-Variable Type Inference</a>)</p></li><li class="list__item" id="pth1h1_72"><p id="pth1h1_110"><a href="object-declarations.html" id="pth1h1_111" data-tooltip="In Kotlin, objects allow you to define a class and create an instance of it in a single step. This is useful when you need either a reusable singleton instance or a one-time object. To handle these scenarios, Kotlin provides two key approaches: object declarations for creating…">Singletons</a></p></li><li class="list__item" id="pth1h1_73"><p id="pth1h1_112"><a href="generics.html" id="pth1h1_113" data-tooltip="Classes in Kotlin can have type parameters, just like in Java:">Declaration-site variance &amp; Type projections</a></p></li><li class="list__item" id="pth1h1_74"><p id="pth1h1_114"><a href="ranges.html" id="pth1h1_115" data-tooltip="Ranges and progressions define sequences of values in Kotlin, supporting range operators, iteration, custom step values, and arithmetic progressions.">Range expressions</a></p></li><li class="list__item" id="pth1h1_75"><p id="pth1h1_116"><a href="operator-overloading.html" id="pth1h1_117" data-tooltip="Kotlin allows you to provide custom implementations for the predefined set of operators on types. These operators have predefined symbolic representation (like + or *) and precedence. To implement an operator, provide a member function or an extension function with a specific name…">Operator overloading</a></p></li><li class="list__item" id="pth1h1_76"><p id="pth1h1_118"><a href="classes.html#companion-objects" id="pth1h1_119" data-tooltip="If you need to write a function that can be called without having a class instance but that needs access to the internals of a class (such as a factory method), you can write it as a member of an object declaration inside that class.">Companion objects</a></p></li><li class="list__item" id="pth1h1_77"><p id="pth1h1_120"><a href="data-classes.html" id="pth1h1_121" data-tooltip="Data classes in Kotlin are primarily used to hold data. For each data class, the compiler automatically generates additional member functions that allow you to print an instance to readable output, compare instances, copy instances, and more. Data classes are marked with data:">Data classes</a></p></li><li class="list__item" id="pth1h1_78"><p id="pth1h1_122"><a href="coroutines-overview.html" id="pth1h1_123" data-tooltip="Asynchronous or non-blocking programming is an important part of the development landscape. When creating server-side, desktop, or mobile applications, it's important to provide an experience that is not only fluid from the user's perspective, but also scalable when needed.">Coroutines</a></p></li><li class="list__item" id="pth1h1_79"><p id="pth1h1_124"><a href="functions.html" id="pth1h1_125" data-tooltip="Kotlin functions are declared using the fun keyword:">Top-level functions</a></p></li><li class="list__item" id="pth1h1_80"><p id="pth1h1_126"><a href="functions.html#default-arguments" id="pth1h1_127" data-tooltip="Function parameters can have default values, which are used when you skip the corresponding argument. This reduces the number of overloads:">Default arguments</a></p></li><li class="list__item" id="pth1h1_81"><p id="pth1h1_128"><a href="functions.html#named-arguments" id="pth1h1_129" data-tooltip="You can name one or more of a function's arguments when calling it. This can be helpful when a function has many arguments and it's difficult to associate a value with an argument, especially if it's a boolean or null value.">Named parameters</a></p></li><li class="list__item" id="pth1h1_82"><p id="pth1h1_130"><a href="functions.html#infix-notation" id="pth1h1_131" data-tooltip="Functions marked with the infix keyword can also be called using the infix notation (omitting the dot and the parentheses for the call). Infix functions must meet the following requirements:">Infix functions</a></p></li><li class="list__item" id="pth1h1_83"><p id="pth1h1_132"><a href="multiplatform-expect-actual.html" id="pth1h1_133" data-tooltip="Expected and actual declarations allow you to access platform-specific APIs from Kotlin Multiplatform modules. You can provide platform-agnostic APIs in the common code.">Expect and actual declarations</a></p></li><li class="list__item" id="pth1h1_84"><p id="pth1h1_134"><a href="whatsnew14.html#explicit-api-mode-for-library-authors" id="pth1h1_135" data-tooltip="Kotlin compiler offers explicit API mode for library authors. In this mode, the compiler performs additional checks that help make the library's API clearer and more consistent. It adds the following requirements for declarations exposed to the library's public API:">Explicit API mode</a> and <a href="opt-in-requirements.html" id="pth1h1_136" data-tooltip="The Kotlin standard library provides a mechanism for requiring and giving explicit consent to use certain API elements. This mechanism allows library authors to inform users about specific conditions that require opt-in, such as when an API is in an experimental state and is likely…">better control of API surface</a></p></li></ul></section><section class="chapter"><h2 id="what-s-next" data-toc="what-s-next">What's next?</h2><p id="pth1h1_137">Learn how to:</p><ul class="list _bullet" id="pth1h1_138"><li class="list__item" id="pth1h1_139"><p id="pth1h1_142">Perform <a href="java-to-kotlin-idioms-strings.html" id="pth1h1_143" data-tooltip="This guide contains examples of how to perform typical tasks with strings in Java and Kotlin. It will help you migrate from Java to Kotlin and write your code in the authentically Kotlin way.">typical tasks with strings in Java and Kotlin</a>.</p></li><li class="list__item" id="pth1h1_140"><p id="pth1h1_144">Perform <a href="java-to-kotlin-collections-guide.html" id="pth1h1_145" data-tooltip="Collections are groups of a variable number of items (possibly zero) that are significant to the problem being solved and are commonly operated on. This guide explains and compares collection concepts and operations in Java and Kotlin. It will help you migrate from Java to Kotlin…">typical tasks with collections in Java and Kotlin</a>.</p></li><li class="list__item" id="pth1h1_141"><p id="pth1h1_146"><a href="java-to-kotlin-nullability-guide.html" id="pth1h1_147" data-tooltip="Nullability is the ability of a variable to hold a null value. When a variable contains null, an attempt to dereference the variable leads to a NullPointerException. There are many ways to write code in order to minimize the probability of receiving null pointer exceptions.">Handle nullability in Java and Kotlin</a>.</p></li></ul></section><div class="last-modified">21 April 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="jvm-get-started.html" class="navigation-links__prev">Get started with Kotlin/JVM</a><a href="java-interop.html" class="navigation-links__next">Calling Java from Kotlin</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="frontend/app.js"></script></body></html>